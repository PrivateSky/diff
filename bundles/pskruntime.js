pskruntimeRequire=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"@msgpack/msgpack":[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.MessagePack=t():e.MessagePack=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n=function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return s},i=function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e},o="undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function s(e){for(var t=e.length,r=0,n=0;n<t;){var i=e.charCodeAt(n++);if(0!=(4294967168&i))if(0==(4294965248&i))r+=2;else{if(i>=55296&&i<=56319&&n<t){var o=e.charCodeAt(n);56320==(64512&o)&&(++n,i=((1023&i)<<10)+(1023&o)+65536)}r+=0==(4294901760&i)?3:4}else r++}return r}var a=o?new TextEncoder:void 0;var h=a&&a.encodeInto?function(e,t,r){a.encodeInto(e,t.subarray(r))}:function(e,t,r){t.set(a.encode(e),r)},u=65536;function c(e,t,r){for(var n=t,o=n+r,s=[],a="";n<o;){var h=e[n++];if(0==(128&h))s.push(h);else if(192==(224&h)){var c=63&e[n++];s.push((31&h)<<6|c)}else if(224==(240&h)){c=63&e[n++];var f=63&e[n++];s.push((31&h)<<12|c<<6|f)}else if(240==(248&h)){var l=(7&h)<<18|(c=63&e[n++])<<12|(f=63&e[n++])<<6|63&e[n++];l>65535&&(l-=65536,s.push(l>>>10&1023|55296),l=56320|1023&l),s.push(l)}else s.push(h);s.length-4>=u&&(a+=String.fromCharCode.apply(String,i(s)),s.length=0)}return s.length>0&&(a+=String.fromCharCode.apply(String,i(s))),a}var f=o?new TextDecoder:null;var l=function(e,t){this.type=e,this.data=t};function p(e,t,r){var n=Math.floor(r/4294967296),i=r;e.setUint32(t,n),e.setUint32(t+4,i)}function d(e,t){return 4294967296*e.getInt32(t)+e.getUint32(t+4)}var y=4294967295,w=17179869183;function v(e){var t=e.sec,r=e.nsec;if(t>=0&&r>=0&&t<=w){if(0===r&&t<=y){var n=new Uint8Array(4);return(s=new DataView(n.buffer)).setUint32(0,t),n}var i=t/4294967296,o=4294967295&t;n=new Uint8Array(8);return(s=new DataView(n.buffer)).setUint32(0,r<<2|3&i),s.setUint32(4,o),n}var s;n=new Uint8Array(12);return(s=new DataView(n.buffer)).setUint32(0,r),p(s,4,t),n}function g(e){var t=e.getTime(),r=Math.floor(t/1e3),n=1e6*(t-1e3*r),i=Math.floor(n/1e9);return{sec:r+i,nsec:n-1e9*i}}function b(e){return e instanceof Date?v(g(e)):null}function m(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength);switch(e.byteLength){case 4:return{sec:t.getUint32(0),nsec:0};case 8:var r=t.getUint32(0);return{sec:4294967296*(3&r)+t.getUint32(4),nsec:r>>>2};case 12:return{sec:d(t,4),nsec:t.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+e.length)}}function U(e){var t=m(e);return new Date(1e3*t.sec+t.nsec/1e6)}var x={type:-1,encode:b,decode:U},S=function(){function e(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(x)}return e.prototype.register=function(e){var t=e.type,r=e.encode,n=e.decode;if(t>=0)this.encoders[t]=r,this.decoders[t]=n;else{var i=1+t;this.builtInEncoders[i]=r,this.builtInDecoders[i]=n}},e.prototype.tryToEncode=function(e){for(var t=0;t<this.builtInEncoders.length;t++){if(null!=(r=this.builtInEncoders[t]))if(null!=(n=r(e)))return new l(-1-t,n)}for(t=0;t<this.encoders.length;t++){var r,n;if(null!=(r=this.encoders[t]))if(null!=(n=r(e)))return new l(t,n)}return e instanceof l?e:null},e.prototype.decode=function(e,t){var r=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return r?r(e,t):new l(t,e)},e.defaultCodec=new e,e}();function E(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Uint8Array.from(e)}var B=null,A=!!B;function L(e,t,r){var n=e.length,i=2*n,o=B.malloc(i);!function(e,t,r,n){for(var i=new DataView(B.memory.buffer,e,t),o=0;o<n;o++)i.setUint16(2*o,r.charCodeAt(o))}(o,i,e,n);var s=B.malloc(5+4*n);try{var a=B.utf8EncodeUint16Array(s,o,n);return t.set(new Uint8Array(B.memory.buffer,s,a),r),a}finally{B.free(o),B.free(s)}}var I=65536;function T(e,t,r){var n,i,o,s=B.malloc(r),a=B.malloc(2*r);try{n=s,i=e.subarray(t,t+r),o=r,new Uint8Array(B.memory.buffer,n,o).set(i);var h=B.utf8DecodeToUint16Array(a,s,r);return function(e){if(e.length<=I)return String.fromCharCode.apply(String,e);for(var t="",r=0;r<e.length;r++){var n=e.subarray(r*I,(r+1)*I);t+=String.fromCharCode.apply(String,n)}return t}(new Uint16Array(B.memory.buffer,a,h))}finally{B.free(s),B.free(a)}}var k=function(e){var t="function"==typeof Symbol&&e[Symbol.iterator],r=0;return t?t.call(e):{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}},M=100,z=2048,C=function(){function e(e,t,r,n,i){void 0===e&&(e=S.defaultCodec),void 0===t&&(t=M),void 0===r&&(r=z),void 0===n&&(n=!1),void 0===i&&(i=!1),this.extensionCodec=e,this.maxDepth=t,this.initialBufferSize=r,this.sortKeys=n,this.forceFloat32=i,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return e.prototype.encode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth "+t);null==e?this.encodeNil():"boolean"==typeof e?this.encodeBoolean(e):"number"==typeof e?this.encodeNumber(e):"string"==typeof e?this.encodeString(e):this.encodeObject(e,t)},e.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},e.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(2*t)},e.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),r=new Uint8Array(t),n=new DataView(t);r.set(this.bytes),this.view=n,this.bytes=r},e.prototype.encodeNil=function(){this.writeU8(192)},e.prototype.encodeBoolean=function(e){!1===e?this.writeU8(194):this.writeU8(195)},e.prototype.encodeNumber=function(e){Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},e.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too long string: "+e+" bytes in UTF-8");this.writeU8(219),this.writeU32(e)}},e.prototype.encodeString=function(e){var t=e.length;if(o&&t>200){var r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),h(e,this.bytes,this.pos),this.pos+=r}else{if(A&&t>1024){var n=5+4*t;this.ensureBufferSizeToWrite(n);var i=L(e,this.bytes,this.pos);return void(this.pos+=i)}r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),function(e,t,r){for(var n=e.length,i=r,o=0;o<n;){var s=e.charCodeAt(o++);if(0!=(4294967168&s)){if(0==(4294965248&s))t[i++]=s>>6&31|192;else{if(s>=55296&&s<=56319&&o<n){var a=e.charCodeAt(o);56320==(64512&a)&&(++o,s=((1023&s)<<10)+(1023&a)+65536)}0==(4294901760&s)?(t[i++]=s>>12&15|224,t[i++]=s>>6&63|128):(t[i++]=s>>18&7|240,t[i++]=s>>12&63|128,t[i++]=s>>6&63|128)}t[i++]=63&s|128}else t[i++]=s}}(e,this.bytes,this.pos),this.pos+=r}},e.prototype.encodeObject=function(e,t){var r=this.extensionCodec.tryToEncode(e);if(null!=r)this.encodeExtension(r);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else{if("object"!=typeof e)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(e));this.encodeMap(e,t)}},e.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large binary: "+t);this.writeU8(198),this.writeU32(t)}var r=E(e);this.writeU8a(r)},e.prototype.encodeArray=function(e,t){var r,n,i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error("Too large array: "+i);this.writeU8(221),this.writeU32(i)}try{for(var o=k(e),s=o.next();!s.done;s=o.next()){var a=s.value;this.encode(a,t+1)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}},e.prototype.encodeMap=function(e,t){var r=Object.keys(e);this.sortKeys&&r.sort();var n=r.length;if(n<16)this.writeU8(128+n);else if(n<65536)this.writeU8(222),this.writeU16(n);else{if(!(n<4294967296))throw new Error("Too large map object: "+n);this.writeU8(223),this.writeU32(n)}for(var i=0;i<n;i++){var o=r[i];this.encodeString(o),this.encode(e[o],t+1)}},e.prototype.encodeExtension=function(e){var t=e.data.length;if(1===t)this.writeU8(212);else if(2===t)this.writeU8(213);else if(4===t)this.writeU8(214);else if(8===t)this.writeU8(215);else if(16===t)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large extension object: "+t);this.writeU8(201),this.writeU32(t)}this.writeI8(e.type),this.writeU8a(e.data)},e.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},e.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},e.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},e.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},e.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},e.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},e.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},e.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},e.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},e.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),function(e,t,r){var n=r/4294967296,i=r;e.setUint32(t,n),e.setUint32(t+4,i)}(this.view,this.pos,e),this.pos+=8},e.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),p(this.view,this.pos,e),this.pos+=8},e}(),D={};function P(e,t){void 0===t&&(t=D);var r=new C(t.extensionCodec,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32);return r.encode(e,1),r.getUint8Array()}function j(e){return(e<0?"-":"")+"0x"+Math.abs(e).toString(16).padStart(2,"0")}var F=16,W=16,O=function(){function e(e,t){void 0===e&&(e=F),void 0===t&&(t=W),this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(var r=0;r<this.maxKeyLength;r++)this.caches.push([])}return e.prototype.canBeCached=function(e){return e>0&&e<=this.maxKeyLength},e.prototype.get=function(e,t,r){var n=this.caches[r-1],i=n.length;e:for(var o=0;o<i;o++){for(var s=n[o],a=s.bytes,h=0;h<r;h++)if(a[h]!==e[t+h])continue e;return s.value}return null},e.prototype.store=function(e,t){var r=this.caches[e.length-1],n={bytes:e,value:t};r.length>=this.maxLengthPerKey?r[Math.random()*r.length|0]=n:r.push(n)},e.prototype.decode=function(e,t,r){var n=this.get(e,t,r);if(n)return n;var i=c(e,t,r),o=Uint8Array.prototype.slice.call(e,t,t+r);return this.store(o,i),i},e}(),_=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){e.done?i(e.value):new r(function(t){t(e.value)}).then(s,a)}h((n=n.apply(e,t||[])).next())})},K=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},V=function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise(function(n,i){(function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)})(n,i,(t=e[r](t)).done,t.value)})}}},N=function(e){return this instanceof N?(this.v=e,this):new N(e)},R=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof N?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}},H=-1,G=new DataView(new ArrayBuffer(0)),X=new Uint8Array(G.buffer),q=function(){try{G.getInt8(0)}catch(e){return e.constructor}throw new Error("never reached")}(),J=new q("Insufficient data"),Q=4294967295,Y=new O,Z=function(){function e(e,t,r,n,i,o){void 0===e&&(e=S.defaultCodec),void 0===t&&(t=Q),void 0===r&&(r=Q),void 0===n&&(n=Q),void 0===i&&(i=Q),void 0===o&&(o=Q),this.extensionCodec=e,this.maxStrLength=t,this.maxBinLength=r,this.maxArrayLength=n,this.maxMapLength=i,this.maxExtLength=o,this.totalPos=0,this.pos=0,this.view=G,this.bytes=X,this.headByte=H,this.stack=[],this.cachedKeyDecoder=Y}return e.prototype.setBuffer=function(e){this.bytes=E(e),this.view=function(e){if(e instanceof ArrayBuffer)return new DataView(e);var t=E(e);return new DataView(t.buffer,t.byteOffset,t.byteLength)}(this.bytes),this.pos=0},e.prototype.appendBuffer=function(e){if(this.headByte!==H||this.hasRemaining()){var t=this.bytes.subarray(this.pos),r=E(e),n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),this.setBuffer(n)}else this.setBuffer(e)},e.prototype.hasRemaining=function(e){return void 0===e&&(e=1),this.view.byteLength-this.pos>=e},e.prototype.createNoExtraBytesError=function(e){var t=this.view,r=this.pos;return new RangeError("Extra "+(t.byteLength-r)+" byte(s) found at buffer["+e+"]")},e.prototype.decodeSingleSync=function(){var e=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return e},e.prototype.decodeSingleAsync=function(e){var t,r,n,i;return _(this,void 0,void 0,function(){var o,s,a,h,u,c,f,l;return K(this,function(p){switch(p.label){case 0:o=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),t=V(e),p.label=2;case 2:return[4,t.next()];case 3:if((r=p.sent()).done)return[3,5];if(a=r.value,o)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(a);try{s=this.decodeSync(),o=!0}catch(e){if(!(e instanceof q))throw e}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return h=p.sent(),n={error:h},[3,12];case 7:return p.trys.push([7,,10,11]),r&&!r.done&&(i=t.return)?[4,i.call(t)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(n)throw n.error;return[7];case 11:return[7];case 12:if(o){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,s]}throw c=(u=this).headByte,f=u.pos,l=u.totalPos,new RangeError("Insufficient data in parcing "+j(c)+" at "+l+" ("+f+" in the current buffer)")}})})},e.prototype.decodeArrayStream=function(e){return this.decodeMultiAsync(e,!0)},e.prototype.decodeStream=function(e){return this.decodeMultiAsync(e,!1)},e.prototype.decodeMultiAsync=function(e,t){return R(this,arguments,function(){var r,n,i,o,s,a,h,u,c;return K(this,function(f){switch(f.label){case 0:r=t,n=-1,f.label=1;case 1:f.trys.push([1,13,14,19]),i=V(e),f.label=2;case 2:return[4,N(i.next())];case 3:if((o=f.sent()).done)return[3,12];if(s=o.value,t&&0===n)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(s),r&&(n=this.readArraySize(),r=!1,this.complete()),f.label=4;case 4:f.trys.push([4,9,,10]),f.label=5;case 5:return[4,N(this.decodeSync())];case 6:return[4,f.sent()];case 7:return f.sent(),0==--n?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((a=f.sent())instanceof q))throw a;return[3,10];case 10:this.totalPos+=this.pos,f.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return h=f.sent(),u={error:h},[3,19];case 14:return f.trys.push([14,,17,18]),o&&!o.done&&(c=i.return)?[4,N(c.call(i))]:[3,16];case 15:f.sent(),f.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}})})},e.prototype.decodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){if(0!==(n=e-128)){this.pushMapState(n),this.complete();continue e}t={}}else if(e<160){if(0!==(n=e-144)){this.pushArrayState(n),this.complete();continue e}t=[]}else{var r=e-160;t=this.decodeUtf8String(r,0)}else if(192===e)t=null;else if(194===e)t=!1;else if(195===e)t=!0;else if(202===e)t=this.readF32();else if(203===e)t=this.readF64();else if(204===e)t=this.readU8();else if(205===e)t=this.readU16();else if(206===e)t=this.readU32();else if(207===e)t=this.readU64();else if(208===e)t=this.readI8();else if(209===e)t=this.readI16();else if(210===e)t=this.readI32();else if(211===e)t=this.readI64();else if(217===e){r=this.lookU8();t=this.decodeUtf8String(r,1)}else if(218===e){r=this.lookU16();t=this.decodeUtf8String(r,2)}else if(219===e){r=this.lookU32();t=this.decodeUtf8String(r,4)}else if(220===e){if(0!==(n=this.readU16())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(221===e){if(0!==(n=this.readU32())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(222===e){if(0!==(n=this.readU16())){this.pushMapState(n),this.complete();continue e}t={}}else if(223===e){if(0!==(n=this.readU32())){this.pushMapState(n),this.complete();continue e}t={}}else if(196===e){var n=this.lookU8();t=this.decodeBinary(n,1)}else if(197===e){n=this.lookU16();t=this.decodeBinary(n,2)}else if(198===e){n=this.lookU32();t=this.decodeBinary(n,4)}else if(212===e)t=this.decodeExtension(1,0);else if(213===e)t=this.decodeExtension(2,0);else if(214===e)t=this.decodeExtension(4,0);else if(215===e)t=this.decodeExtension(8,0);else if(216===e)t=this.decodeExtension(16,0);else if(199===e){n=this.lookU8();t=this.decodeExtension(n,1)}else if(200===e){n=this.lookU16();t=this.decodeExtension(n,2)}else{if(201!==e)throw new Error("Unrecognized type byte: "+j(e));n=this.lookU32();t=this.decodeExtension(n,4)}this.complete();for(var i=this.stack;i.length>0;){var o=i[i.length-1];if(0===o.type){if(o.array[o.position]=t,o.position++,o.position!==o.size)continue e;i.pop(),t=o.array}else{if(1===o.type){if("string"!=typeof t)throw new Error("The type of key must be string but "+typeof t);o.key=t,o.type=2;continue e}if(2===o.type){if(o.map[o.key]=t,o.readCount++,o.readCount!==o.size){o.key=null,o.type=1;continue e}i.pop(),t=o.map}}}return t}},e.prototype.readHeadByte=function(){return this.headByte===H&&(this.headByte=this.readU8()),this.headByte},e.prototype.complete=function(){this.headByte=H},e.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:if(e<160)return e-144;throw new Error("Unrecognized array type byte: "+j(e))}},e.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new Error("Max length exceeded: map length ("+e+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:e,key:null,readCount:0,map:{}})},e.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+e+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:e,array:new Array(e),position:0})},e.prototype.decodeUtf8String=function(e,t){if(e>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+e+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+t+e)throw J;var r,n=this.pos+t;return r=this.stateIsMapKey()&&this.cachedKeyDecoder.canBeCached(e)?this.cachedKeyDecoder.decode(this.bytes,n,e):o&&e>200?function(e,t,r){var n=e.subarray(t,t+r);return f.decode(n)}(this.bytes,n,e):A&&e>1024?T(this.bytes,n,e):c(this.bytes,n,e),this.pos+=t+e,r},e.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},e.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+e+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(e+t))throw J;var r=this.pos+t,n=this.bytes.subarray(r,r+e);return this.pos+=t+e,n},e.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+e+") > maxExtLength ("+this.maxExtLength+")");var r=this.view.getInt8(this.pos+t),n=this.decodeBinary(e,t+1);return this.extensionCodec.decode(n,r)},e.prototype.lookU8=function(){return this.view.getUint8(this.pos)},e.prototype.lookU16=function(){return this.view.getUint16(this.pos)},e.prototype.lookU32=function(){return this.view.getUint32(this.pos)},e.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},e.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},e.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},e.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},e.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},e.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},e.prototype.readU64=function(){var e,t,r=(e=this.view,t=this.pos,4294967296*e.getUint32(t)+e.getUint32(t+4));return this.pos+=8,r},e.prototype.readI64=function(){var e=d(this.view,this.pos);return this.pos+=8,e},e.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},e.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},e}(),$={};function ee(e,t){void 0===t&&(t=$);var r=new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength);return r.setBuffer(e),r.decodeSingleSync()}var te=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},re=function(e){return this instanceof re?(this.v=e,this):new re(e)},ne=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof re?Promise.resolve(r.value.v).then(h,u):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function h(e){a("next",e)}function u(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}};function ie(e){return null!=e[Symbol.asyncIterator]?e:function(e){return ne(this,arguments,function(){var t,r,n,i;return te(this,function(o){switch(o.label){case 0:t=e.getReader(),o.label=1;case 1:o.trys.push([1,,9,10]),o.label=2;case 2:return[4,re(t.read())];case 3:return r=o.sent(),n=r.done,i=r.value,n?[4,re(void 0)]:[3,5];case 4:return[2,o.sent()];case 5:return[4,re(i)];case 6:return[4,o.sent()];case 7:return o.sent(),[3,2];case 8:return[3,10];case 9:return t.releaseLock(),[7];case 10:return[2]}})})}(e)}var oe=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{h(n.next(e))}catch(e){o(e)}}function a(e){try{h(n.throw(e))}catch(e){o(e)}}function h(e){e.done?i(e.value):new r(function(t){t(e.value)}).then(s,a)}h((n=n.apply(e,t||[])).next())})},se=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}};function ae(e,t){return void 0===t&&(t=$),oe(this,void 0,void 0,function(){var r;return se(this,function(n){return r=ie(e),[2,new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeSingleAsync(r)]})})}function he(e,t){void 0===t&&(t=$);var r=ie(e);return new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeArrayStream(r)}function ue(e,t){void 0===t&&(t=$);var r=ie(e);return new Z(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeStream(r)}r.d(t,"encode",function(){return P}),r.d(t,"decode",function(){return ee}),r.d(t,"decodeAsync",function(){return ae}),r.d(t,"decodeArrayStream",function(){return he}),r.d(t,"decodeStream",function(){return ue}),r.d(t,"Decoder",function(){return Z}),r.d(t,"Encoder",function(){return C}),r.d(t,"ExtensionCodec",function(){return S}),r.d(t,"ExtData",function(){return l}),r.d(t,"EXT_TIMESTAMP",function(){return-1}),r.d(t,"encodeDateToTimeSpec",function(){return g}),r.d(t,"encodeTimeSpecToTimestamp",function(){return v}),r.d(t,"decodeTimestampToTimeSpec",function(){return m}),r.d(t,"encodeTimestampExtension",function(){return b}),r.d(t,"decodeTimestampExtension",function(){return U}),r.d(t,"__WASM_AVAILABLE",function(){return A})}])});

},{}],"C:\\Users\\Public\\privatesky\\builds\\tmp\\pskruntime.js":[function(require,module,exports){
require("../../modules/callflow/lib/overwriteRequire")

require("./pskruntime_intermediar");

require("callflow");

console.log("Loading runtime: callflow module ready");
},{"../../modules/callflow/lib/overwriteRequire":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\overwriteRequire.js","./pskruntime_intermediar":"C:\\Users\\Public\\privatesky\\builds\\tmp\\pskruntime_intermediar.js","callflow":"callflow"}],"C:\\Users\\Public\\privatesky\\builds\\tmp\\pskruntime_intermediar.js":[function(require,module,exports){
(function (global){
global.pskruntimeLoadModules = function(){ 
	$$.__runtimeModules["callflow"] = require("callflow");
	$$.__runtimeModules["launcher"] = require("launcher");
	$$.__runtimeModules["double-check"] = require("double-check");
	$$.__runtimeModules["pskcrypto"] = require("pskcrypto");
	$$.__runtimeModules["dicontainer"] = require("dicontainer");
	$$.__runtimeModules["swarmutils"] = require("swarmutils");
	$$.__runtimeModules["soundpubsub"] = require("soundpubsub");
	$$.__runtimeModules["pskbuffer"] = require("pskbuffer");
	$$.__runtimeModules["foldermq"] = require("foldermq");
	$$.__runtimeModules["domainBase"] = require("domainBase");
	$$.__runtimeModules["utils"] = require("utils");
	$$.__runtimeModules["@msgpack/msgpack"] = require("@msgpack/msgpack");
	$$.__runtimeModules["psklogger"] = require("psklogger");
}
if (false) {
	pskruntimeLoadModules();
}; 
global.pskruntimeRequire = require;
if (typeof $$ !== "undefined") {            
    $$.requireBundle("pskruntime");
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@msgpack/msgpack":"@msgpack/msgpack","callflow":"callflow","dicontainer":"dicontainer","domainBase":"domainBase","double-check":"double-check","foldermq":"foldermq","launcher":"launcher","pskbuffer":"pskbuffer","pskcrypto":"pskcrypto","psklogger":"psklogger","soundpubsub":"soundpubsub","swarmutils":"swarmutils","utils":"utils"}],"C:\\Users\\Public\\privatesky\\libraries\\domainBase\\domainPubSub.js":[function(require,module,exports){
var pubSub = $$.require("soundpubsub").soundPubSub;
const path = require("path");
const fs = require("fs");

exports.create = function(folder, codeFolder ){

    $$.PSK_PubSub = pubSub;
    var sandBoxesRoot = path.join(folder, "sandboxes");

    try{
        fs.mkdirSync(sandBoxesRoot, {recursive: true});
    }catch(err){
        console.log("Failed to create sandboxes dir structure!", err);
        //TODO: maybe it is ok to call process.exit ???
    }

    $$.SandBoxManager = require("../../psknode/core/sandboxes/util/SandBoxManager").create(sandBoxesRoot, codeFolder, function(err, res){
        console.log($$.DI_components.sandBoxReady, err, res);
        $$.container.resolve($$.DI_components.sandBoxReady, true);
    });

    return pubSub;
};

},{"../../psknode/core/sandboxes/util/SandBoxManager":"C:\\Users\\Public\\privatesky\\psknode\\core\\sandboxes\\util\\SandBoxManager.js","fs":false,"path":"path"}],"C:\\Users\\Public\\privatesky\\libraries\\launcher\\components.js":[function(require,module,exports){
$$.DI_components = {
   swarmIsReady:"SwarmIsReady",
   configLoaded:"configLoaded",
   sandBoxReady:"SandBoxReady",
   localNodeAPIs:"localNodeAPIs"
}

},{}],"C:\\Users\\Public\\privatesky\\libraries\\utils\\FSExtension.js":[function(require,module,exports){
(function (__dirname){
const fs = require("fs");
const path = require("path");
const os = require("os");
const child_process = require('child_process');
const crypto = require('crypto');

// if this is set to true, the logs will be available. Default (false)
const DEBUG =  process.env.DEPLOYER_DEBUG || false;

function FSExtention(){

    /**
     * Base path used to resolve all relative paths in the actions bellow.
     * Default is set to two levels up from the current directory. This can be changed using __setBasePath.
     * @type {*|string}
     */
    var basePath = path.join(__dirname, "../../");

    /**
     * Set the base path to a different absolute directory path.
     * @param wd {String} absolute directory path.
     * @private
     */
    var __setBasePath = function(wd) {
        basePath = path.resolve(wd);
    }

    /**
     * Resolve path into an absolute path. If filePath is relative, the path is resolved using the basePath as first argument.
     * @param filePath {String} relative or absolute file path.
     * @returns {String} absolute path
     * @private
     */
    var __resolvePath = function(filePath) {
        if(path.isAbsolute(filePath)) {
            return filePath;
        }

        return path.resolve(basePath, filePath);
    }

    /**
     * If the directory structure does not exist, it is created. Like mkdir -p
     * @param dir {String} dir path
     * @private
     */
    var __createDir = function(dir) {
        dir = __resolvePath(dir);
        if (fs.existsSync(dir)) {
            log(dir + " already exist! Continuing ...")
            return;
        }

        var isWin = (os.platform() === 'win32');
        var cmd = isWin ? "mkdir " : "mkdir -p ";

        child_process.execSync(cmd + "\""+dir+"\"", {stdio:[0,1,2]});
    }

    /**
     * Copy a file or directory. The directory can have recursive contents. Like copy -r.
     * NOTE: If src is a directory it will copy everything inside of the directory, not the entire directory itself.
     * NOTE: If src is a file, target cannot be a directory.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source file|directory path.
     * @param dest {String} Destination file|directory path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing file or directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __copy = function (src, dest, options, callback) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        callback = callback || function(){};
        let rethrow = false;

        try{
            if (!fs.existsSync(src)) {
                rethrow = true;
                throw `Source directory or file "${src}" does not exists!`;
            }

            let srcStat = fs.lstatSync(src);
            if(srcStat.isDirectory()) {
                __copyDir(src, dest, options);
            } else if(srcStat.isFile()) {
                // destination must be a file too
                __copyFile(src, dest, options);
            }
        } catch (err) {
            if(rethrow){
                throw err;
            }
            log(err, true);
            callback(err);
            return;
        }

        callback();
    }

    /**
     * Copy a directory. The directory can have recursive contents. Like copy -r.
     * NOTE: Itt will copy everything inside of the directory, not the entire directory itself.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source directory path.
     * @param dest {String} Destination directory path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @private
     */
    var __copyDir = function(src, dest, options) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        __createDir(dest);

        var files = fs.readdirSync(src);
        for(var i = 0; i < files.length; i++) {
            let current = fs.lstatSync(path.join(src, files[i]));
            let newSrc = path.join(src, files[i]);
            let newDest = path.join(dest, files[i]);

            if(current.isDirectory()) {
                __copyDir(newSrc, newDest, options);
            } else if(current.isSymbolicLink()) {
                var symlink = fs.readlinkSync(newSrc);
                fs.symlinkSync(symlink, newDest);
            } else {
                __copyFile(newSrc, newDest, options);
            }
        }
    };

    /**
     * Copy a file.
     * NOTE: If src is a file, target cannot be a directory.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source file path.
     * @param dest {String} Destination file path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing file or directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __copyFile = function(src, dest, options) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        if(options && options.overwrite === false) {
            if (fs.existsSync(dest)) {
                // silently fail if overwrite is set to false and the destination exists.
                let error = `Silent fail - cannot copy. Destination file ${dest} already exists and overwrite option is set to false! Continuing...`;
                log(error, true);
                return;
            }
        }
        __createDir(path.dirname(dest));

        var content = fs.readFileSync(src, "utf8");
        fs.writeFileSync(dest, content);
    }

    /**
     * Removes a file or directory. The directory can have recursive contents. Like rm -rf
     * @param src {String} Path
     * @param callback {Function}
     * @private
     */
    var __remove = function(src, callback) {
        src = __resolvePath(src);

        callback = callback || function(){};

        log(`Removing ${src}`);

        try{
            let current = fs.lstatSync(src);
            if(current.isDirectory()) {
                __rmDir(src);
            } else if(current.isFile()) {
                __rmFile(src);
            }
        } catch (err) {
            if(err.code && err.code === "ENOENT"){
                //ignoring errors like "file/directory does not exist"
                err = null;
            }else{
                log(err, true);
            }
            callback(err);
            return;
        }

        callback();
    }

    /**
     * Removes a directory. The directory can have recursive contents. Like rm -rf
     * @param dir {String} Path
     * @private
     */
    var __rmDir = function (dir) {
        dir = __resolvePath(dir);

        if (!fs.existsSync(dir)) {
            log(`Directory ${dir} does not exist!`, true);
            return;
        }

        var list = fs.readdirSync(dir);
        for (var i = 0; i < list.length; i++) {
            var filename = path.join(dir, list[i]);
            var stat = fs.lstatSync(filename);

            if (stat.isDirectory()) {
                __rmDir(filename, null);
            } else {
                // rm filename
                fs.unlinkSync(filename);
            }
        }

        fs.rmdirSync(dir);
    }

    /**
     * Removes a file.
     * @param file {String} Path
     * @private
     */
    var __rmFile = function(file) {
        file = __resolvePath(file);
        if (!fs.existsSync(file)) {
            log(`File ${file} does not exist!`, true);
            return;
        }

        fs.unlinkSync(file);
    }

    /**
     * Writes data to a file, replacing the file if it already exists.
     * @param file {String} Path.
     * @param data {String}
     * @private
     */
    var __createFile = function(file, data, options) {
        file = __resolvePath(file)
        fs.writeFileSync(file, data, options);
    }

    /**
     * Moves a file or directory.
     * @param src {String} Source path.
     * @param dest {String} Destination path.
     * @param options {Object}. Optional parameters for copy action. Available options:
     *  - overwrite <boolean>: overwrite existing file or directory, default is false. Note that the move operation will silently fail if you set this to true and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __move = function(src, dest, options, callback) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        callback = callback || function(){};

        try {
            if(options && options.overwrite === false) {
                if (fs.existsSync(dest)) {
                    // silently fail if overwrite is set to false and the destination exists.
                    let error = `Silent fail - cannot move. Destination file ${dest} already exists and overwrite option is set to false! Continuing...`;
                    log(error, true);
                    callback();
                    return;
                }
            }

            __copy(src, dest, options);
            __remove(src);
        }catch(err) {
            callback(err);
            return;
        }
        callback();
    }

    /**
     * Computes checksum to a file or a directory based on their contents only.
     * If the source is directory, the checksum is a hash of all concatenated file hashes.
     * @param src {String} Path of a file or directory.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Checksum of the file or directory.
     * @private
     */
    var __checksum = function(src, algorithm, encoding) {
        src = __resolvePath(src);

        if (!fs.existsSync(src)) {
            throw `Path ${src} does not exists!`;
        }

        var checksum = "";
        let current = fs.lstatSync(src);
        if(current.isDirectory()) {
            let hashDir = __hashDir(src, algorithm, encoding);
            checksum = hashDir["hash"];
        } else if(current.isFile()) {
            checksum = __hashFile(src, algorithm, encoding);
        }

        return checksum;
    }

    /**
     * Computes hash of a string.
     * @param str {String}
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the string.
     * @private
     */
    var __hash =  function(str, algorithm, encoding) {
        return crypto
            .createHash(algorithm || 'md5')
            .update(str, 'utf8')
            .digest(encoding || 'hex')
    }

    /**
     * Computes hash of a file based on its content only.
     * @param src {String} Path of a file.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the file.
     * @private
     */
    var __hashFile = function(src, algorithm, encoding) {
        src = __resolvePath(src);
        if (!fs.existsSync(src)) {
            throw `${src} does not exist!`;
        }

        var content = fs.readFileSync(src, "utf8");
        return __hash(content, algorithm, encoding);
    }

    /**
     * Computes hash of a directory based on its content only.
     * If directory has multiple files, the result is a hash of all concatenated file hashes.
     * @param src {String} Path of a directory.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the directory.
     * @private
     */
    var __hashDir = function(dir, algorithm, encoding) {
        dir = __resolvePath(dir);
        if (!fs.existsSync(dir)) {
            throw `Directory ${dir} does not exist!`;
        }
        var hashes = {};
        var list = fs.readdirSync(dir);
        for (var i = 0; i < list.length; i++) {
            var filename = path.join(dir, list[i]);
            var stat = fs.lstatSync(filename);

            if (stat.isDirectory()) {
                let tempHashes = __hashDir(filename, algorithm, encoding);
                hashes = Object.assign(hashes, tempHashes["sub-hashes"]);
            } else {
                let tempHash = __hashFile(filename, algorithm, encoding);
                hashes[filename] = tempHash;
            }
        }

        // compute dir hash
        let dirContent = Object.keys(hashes).reduce(function (previous, key) {
            return previous += hashes[key];
        }, "");

        let dirHash = __hash(dirContent, algorithm, encoding);

        return {
            "hash": dirHash,
            "sub-hashes": hashes
        }
    }

    /**
     * Generates a guid (global unique identifier).
     * @returns {String} Guid in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
     * @private
     */
    var __guid = function guid() {
        function _make_group(s) {
            var p = (Math.random().toString(16)+"000000000").substr(2,8);
            return s ? "-" + p.substr(0,4) + "-" + p.substr(4,4) : p ;
        }
        return _make_group() + _make_group(true) + _make_group(true) + _make_group();
    }

    /**
     * Logs wrapper.
     * @param message {String}
     * @param isError {Boolean}
     */
    function log(message, isError) {
        let logger = isError ? console.error : console.log;

        if(DEBUG) {
            logger(message);
        }
    }

    return {
        setBasePath: __setBasePath,
        resolvePath: __resolvePath,
        createDir: __createDir,
        copyDir: __copyDir,
        rmDir: __rmDir,
        rmFile: __rmFile,
        createFile: __createFile,
        copy: __copy,
        move: __move,
        remove: __remove,
        checksum: __checksum,
        guid: __guid
    }
}

module.exports.fsExt = new FSExtention();
}).call(this,"/libraries/utils")

},{"child_process":false,"crypto":"crypto","fs":false,"os":"os","path":"path"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\constants.js":[function(require,module,exports){
$$.CONSTANTS = {
    SWARM_FOR_EXECUTION:"swarm_for_execution",
    INBOUND:"inbound",
    OUTBOUND:"outbound",
    PDS:"PrivateDataSystem",
    CRL:"CommunicationReplicationLayer",
    SWARM_RETURN: 'swarm_return',
    BEFORE_INTERCEPTOR: 'before',
    AFTER_INTERCEPTOR: 'after',
};


},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\InterceptorRegistry.js":[function(require,module,exports){
// related to: SwarmSpace.SwarmDescription.createPhase()

function InterceptorRegistry() {
    const rules = new Map();

     _CLASS_NAME = 'InterceptorRegistry';

    /************* PRIVATE METHODS *************/

    function _throwError(err, msg) {
        console.error(err.message, `${_CLASS_NAME} error message:`, msg);
        throw err;
    }

    function _warning(msg) {
        console.warn(`${_CLASS_NAME} warning message:`, msg);
    }

    const getWhenOptions = (function () {
        let WHEN_OPTIONS;
        return function () {
            if (WHEN_OPTIONS === undefined) {
                WHEN_OPTIONS = Object.freeze([
                    $$.CONSTANTS.BEFORE_INTERCEPTOR,
                    $$.CONSTANTS.AFTER_INTERCEPTOR
                ]);
            }
            return WHEN_OPTIONS;
        };
    })();

    function verifyWhenOption(when) {
        if (!getWhenOptions().includes(when)) {
            _throwError(new RangeError(`Option '${when}' is wrong!`),
                `it should be one of: ${getWhenOptions()}`);
        }
    }

    function verifyIsFunctionType(fn) {
        if (typeof fn !== 'function') {
            _throwError(new TypeError(`Parameter '${fn}' is wrong!`),
                `it should be a function, not ${typeof fn}!`);
        }
    }

    function resolveNamespaceResolution(swarmTypeName) {
        if (swarmTypeName === '*') {
            return swarmTypeName;
        }

        return (swarmTypeName.includes(".") ? swarmTypeName : ($$.libraryPrefix + "." + swarmTypeName));
    }

    /**
     * Transforms an array into a generator with the particularity that done is set to true on the last element,
     * not after it finished iterating, this is helpful in optimizing some other functions
     * It is useful if you want call a recursive function over the array elements but without popping the first
     * element of the Array or sending the index as an extra parameter
     * @param {Array<*>} arr
     * @return {IterableIterator<*>}
     */
    function* createArrayGenerator(arr) {
        const len = arr.length;

        for (let i = 0; i < len - 1; ++i) {
            yield arr[i];
        }

        return arr[len - 1];
    }

    /**
     * Builds a tree like structure over time (if called on the same root node) where internal nodes are instances of
     * Map containing the name of the children nodes (each child name is the result of calling next on `keysGenerator)
     * and a reference to them and on leafs it contains an instance of Set where it adds the function given as parameter
     * (ex: for a keyGenerator that returns in this order ("key1", "key2") the resulting structure will be:
     * {"key1": {"key1": Set([fn])}} - using JSON just for illustration purposes because it's easier to represent)
     * @param {Map} rulesMap
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @param {function} fn
     */
    function registerRecursiveRule(rulesMap, keysGenerator, fn) {
        const {value, done} = keysGenerator.next();

        if (!done) { // internal node
            const nextKey = rulesMap.get(value);

            if (typeof nextKey === 'undefined') { // if value not found in rulesMap
                rulesMap.set(value, new Map());
            }

            registerRecursiveRule(rulesMap.get(value), keysGenerator, fn);
        } else { // reached leaf node
            if (!rulesMap.has(value)) {

                rulesMap.set(value, new Set([fn]));
            } else {
                const set = rulesMap.get(value);

                if (set.has(fn)) {
                    _warning(`Duplicated interceptor for '${key}'`);
                }

                set.add(fn);
            }
        }
    }

    /**
     * Returns the corresponding set of functions for the given key if found
     * @param {string} key - formatted as a path without the first '/' (ex: swarmType/swarmPhase/before)
     * @return {Array<Set<function>>}
     */
    function getInterceptorsForKey(key) {
        if (key.startsWith('/')) {
            _warning(`Interceptor called on key ${key} starting with '/', automatically removing it`);
            key = key.substring(1);
        }

        const keyElements = key.split('/');
        const keysGenerator = createArrayGenerator(keyElements);

        return getValueRecursively([rules], keysGenerator);
    }

    /**
     * It works like a BFS search returning the leafs resulting from traversing the internal nodes with corresponding
     * names given for each level (depth) by `keysGenerator`
     * @param {Array<Map>} searchableNodes
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @return {Array<Set<function>>}
     */
    function getValueRecursively(searchableNodes, keysGenerator) {
        const {value: nodeName, done} = keysGenerator.next();

        const nextNodes = [];

        for (const nodeInRules of searchableNodes) {
            const nextNodeForAll = nodeInRules.get('*');
            const nextNode = nodeInRules.get(nodeName);

            if (typeof nextNode !== "undefined") {
                nextNodes.push(nextNode);
            }

            if (typeof nextNodeForAll !== "undefined") {
                nextNodes.push(nextNodeForAll);
            }

        }

        if (done) {
            return nextNodes;
        }

        return getValueRecursively(nextNodes, keysGenerator);
    }


    /************* PUBLIC METHODS *************/

    this.register = function (swarmTypeName, phaseName, when, fn) {
        verifyWhenOption(when);
        verifyIsFunctionType(fn);

        const resolvedSwarmTypeName = resolveNamespaceResolution(swarmTypeName);
        const keys = createArrayGenerator([resolvedSwarmTypeName, phaseName, when]);

        registerRecursiveRule(rules, keys, fn);
    };

    // this.unregister = function () { }

    this.callInterceptors = function (key, targetObject, args) {
        const interceptors = getInterceptorsForKey(key);

        if (interceptors) {
            for (const interceptorSet of interceptors) {
                for (const fn of interceptorSet) { // interceptors on key '*' are called before those specified by name
                    fn.apply(targetObject, args);
                }
            }
        }
    };
}


exports.createInterceptorRegistry = function () {
    return new InterceptorRegistry();
};

},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\SwarmDebug.js":[function(require,module,exports){
/*
 Initial License: (c) Axiologic Research & Alboaie Snic.
 Contributors: Axiologic Research , PrivateSky project
 Code License: LGPL or MIT.
 */

var util = require("util");
var fs = require("fs");
cprint = console.log;
wprint = console.warn;
dprint = console.debug;
eprint = console.error;


/**
 * Shortcut to JSON.stringify
 * @param obj
 */
J = function (obj) {
    return JSON.stringify(obj);
}


/**
 * Print swarm contexts (Messages) and easier to read compared with J
 * @param obj
 * @return {string}
 */
exports.cleanDump = function (obj) {
    var o = obj.valueOf();
    var meta = {
        swarmTypeName:o.meta.swarmTypeName
    };
    return "\t swarmId: " + o.meta.swarmId + "{\n\t\tmeta: "    + J(meta) +
        "\n\t\tpublic: "        + J(o.publicVars) +
        "\n\t\tprotected: "     + J(o.protectedVars) +
        "\n\t\tprivate: "       + J(o.privateVars) + "\n\t}\n";
}

//M = exports.cleanDump;
/**
 * Experimental functions
 */


/*

 logger      = monitor.logger;
 assert      = monitor.assert;
 throwing    = monitor.exceptions;


 var temporaryLogBuffer = [];

 var currentSwarmComImpl = null;

 logger.record = function(record){
 if(currentSwarmComImpl===null){
 temporaryLogBuffer.push(record);
 } else {
 currentSwarmComImpl.recordLog(record);
 }
 }

 var container = require("dicontainer").container;

 container.service("swarmLoggingMonitor", ["swarmingIsWorking", "swarmComImpl"], function(outOfService,swarming, swarmComImpl){

 if(outOfService){
 if(!temporaryLogBuffer){
 temporaryLogBuffer = [];
 }
 } else {
 var tmp = temporaryLogBuffer;
 temporaryLogBuffer = [];
 currentSwarmComImpl = swarmComImpl;
 logger.record = function(record){
 currentSwarmComImpl.recordLog(record);
 }

 tmp.forEach(function(record){
 logger.record(record);
 });
 }
 })

 */
uncaughtExceptionString = "";
uncaughtExceptionExists = false;
if(typeof globalVerbosity == 'undefined'){
    globalVerbosity = false;
}

var DEBUG_START_TIME = new Date().getTime();

function getDebugDelta(){
    var currentTime = new Date().getTime();
    return currentTime - DEBUG_START_TIME;
}

/**
 * Debug functions, influenced by globalVerbosity global variable
 * @param txt
 */
dprint = function (txt) {
    if (globalVerbosity == true) {
        if (thisAdapter.initilised ) {
            console.log("DEBUG: [" + thisAdapter.nodeName + "](" + getDebugDelta()+ "):"+txt);
        }
        else {
            console.log("DEBUG: (" + getDebugDelta()+ "):"+txt);
            console.log("DEBUG: " + txt);
        }
    }
}

/**
 * obsolete!?
 * @param txt
 */
aprint = function (txt) {
    console.log("DEBUG: [" + thisAdapter.nodeName + "]: " + txt);
}



/**
 * Utility function usually used in tests, exit current process after a while
 * @param msg
 * @param timeout
 */
delayExit = function (msg, retCode,timeout) {
    if(retCode == undefined){
        retCode = ExitCodes.UnknownError;
    }

    if(timeout == undefined){
        timeout = 100;
    }

    if(msg == undefined){
        msg = "Delaying exit with "+ timeout + "ms";
    }

    console.log(msg);
    setTimeout(function () {
        process.exit(retCode);
    }, timeout);
}


function localLog (logType, message, err) {
    var time = new Date();
    var now = time.getDate() + "-" + (time.getMonth() + 1) + "," + time.getHours() + ":" + time.getMinutes();
    var msg;

    msg = '[' + now + '][' + thisAdapter.nodeName + '] ' + message;

    if (err != null && err != undefined) {
        msg += '\n     Err: ' + err.toString();
        if (err.stack && err.stack != undefined)
            msg += '\n     Stack: ' + err.stack + '\n';
    }

    cprint(msg);
    if(thisAdapter.initilised){
        try{
            fs.appendFileSync(getSwarmFilePath(thisAdapter.config.logsPath + "/" + logType), msg);
        } catch(err){
            console.log("Failing to write logs in ", thisAdapter.config.logsPath );
        }

    }
}


// printf = function (...params) {
//     var args = []; // empty array
//     // copy all other arguments we want to "pass through"
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     var out = util.format.apply(this, args);
//     console.log(out);
// }
//
// sprintf = function (...params) {
//     var args = []; // empty array
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     return util.format.apply(this, args);
// }


},{"fs":false,"util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\swarm.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	return require("../utilityFunctions/base").createForObject(valueObject, thisObject, localId);
};
},{"../utilityFunctions/base":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\base.js"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\swarmInstancesManager.js":[function(require,module,exports){


function SwarmsInstancesManager(){
    var swarmAliveInstances = {

    }

    this.waitForSwarm = function(callback, swarm, keepAliveCheck){

        function doLogic(){
            var swarmId = swarm.getInnerValue().meta.swarmId;
            var watcher = swarmAliveInstances[swarmId];
            if(!watcher){
                watcher = {
                    swarm:swarm,
                    callback:callback,
                    keepAliveCheck:keepAliveCheck
                }
                swarmAliveInstances[swarmId] = watcher;
            }
        }

        function filter(){
            return swarm.getInnerValue().meta.swarmId;
        }

        //$$.uidGenerator.wait_for_condition(condition,doLogic);
        swarm.observe(doLogic, null, filter);
    }

    function cleanSwarmWaiter(swarmSerialisation){ // TODO: add better mechanisms to prevent memory leaks
        var swarmId = swarmSerialisation.meta.swarmId;
        var watcher = swarmAliveInstances[swarmId];

        if(!watcher){
            $$.warn("Invalid swarm received: " + swarmId);
            return;
        }

        var args = swarmSerialisation.meta.args;
        args.push(swarmSerialisation);

        watcher.callback.apply(null, args);
        if(!watcher.keepAliveCheck()){
            delete swarmAliveInstances[swarmId];
        }
    }

    this.revive_swarm = function(swarmSerialisation){


        var swarmId     = swarmSerialisation.meta.swarmId;
        var swarmType   = swarmSerialisation.meta.swarmTypeName;
        var instance    = swarmAliveInstances[swarmId];

        var swarm;

        if(instance){
            swarm = instance.swarm;
            swarm.update(swarmSerialisation);

        } else {
            swarm = $$.swarm.start(swarmType);
            if(!swarm){
                throw new Error(`Unknown swarm type <${swarmType}>. Check if swarm type is present in domain constituion!`);
            }else{
                swarm.update(swarmSerialisation);
            }

            /*swarm = $$.swarm.start(swarmType, swarmSerialisation);*/
        }

        if (swarmSerialisation.meta.command == "asyncReturn") {
            var co = $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_RETURN, swarmSerialisation);
            console.log("Subscribers listening on", $$.CONSTANTS.SWARM_RETURN, co);
            // cleanSwarmWaiter(swarmSerialisation);
        } else if (swarmSerialisation.meta.command == "executeSwarmPhase") {
            swarm.runPhase(swarmSerialisation.meta.phaseName, swarmSerialisation.meta.args);
        } else {
            console.log("Unknown command", swarmSerialisation.meta.command, "in swarmSerialisation.meta.command");
        }

        return swarm;
    }
}


$$.swarmsInstancesManager = new SwarmsInstancesManager();



},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\loadLibrary.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Snic.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/

//var fs = require("fs");
//var path = require("path");


function SwarmLibrary(prefixName, folder){
    var self = this;
    function wrapCall(original, prefixName){
        return function(...args){
            //console.log("prefixName", prefixName)
            var previousPrefix = $$.libraryPrefix;
            var previousLibrary = $$.__global.currentLibrary;

            $$.libraryPrefix = prefixName;
            $$.__global.currentLibrary = self;
            try{
                var ret = original.apply(this, args);
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
            }catch(err){
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
                throw err;
            }
            return ret;
        }
    }

    $$.libraries[prefixName] = this;
    var prefixedRequire = wrapCall(function(path){
        return require(path);
    }, prefixName);

    function includeAllInRoot(folder) {
        if(typeof folder != "string"){
            //we assume that it is a library module properly required with require and containing $$.library
            for(var v in folder){
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  folder[v]);
            }

            var newNames = $$.__global.requireLibrariesNames[prefixName];
            for(var v in newNames){
                self[v] =  newNames[v];
            }
            return folder;
        }


        var res = prefixedRequire(folder); // a library is just a module
        if(typeof res.__autogenerated_privatesky_libraryName != "undefined"){
            var swarms = $$.__global.requireLibrariesNames[res.__autogenerated_privatesky_libraryName];
        } else {
            var swarms = $$.__global.requireLibrariesNames[folder];
        }
            var existingName;
            for(var v in swarms){
                existingName = swarms[v];
                self[v] = existingName;
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  existingName);
            }
        return res;
    }

    function wrapSwarmRelatedFunctions(space, prefixName){
        var ret = {};
        var names = ["create", "describe", "start", "restart"];
        for(var i = 0; i<names.length; i++ ){
            ret[names[i]] = wrapCall(space[names[i]], prefixName);
        }
        return ret;
    }

    this.callflows        = this.callflow   = wrapSwarmRelatedFunctions($$.callflows, prefixName);
    this.swarms           = this.swarm      = wrapSwarmRelatedFunctions($$.swarms, prefixName);
    this.contracts        = this.contract   = wrapSwarmRelatedFunctions($$.contracts, prefixName);
    includeAllInRoot(folder, prefixName);
}

exports.loadLibrary = function(prefixName, folder){
    var existing = $$.libraries[prefixName];
    if(existing ){
        if(!(existing instanceof SwarmLibrary)){
            var sL = new SwarmLibrary(prefixName, folder);
            for(var prop in existing){
                sL[prop] = existing[prop];
            }
            return sL;
        }
        if(folder) {
            $$.syntaxError("Reusing already loaded library " + prefixName + "could be an error!");
        }
        return existing;
    }
    //var absolutePath = path.resolve(folder);
    return new SwarmLibrary(prefixName, folder);
}


},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\overwriteRequire.js":[function(require,module,exports){
(function (global){
/*
 require and $$.require are overwriting the node.js defaults in loading modules for increasing security,speed and making it work to the privatesky runtime build with browserify.
 The privatesky code for domains should work in node and browsers.
 */


if (typeof(window) !== "undefined") {
    global = window;
}


if (typeof(global.$$) == "undefined") {
    global.$$ = {};
    $$.__global = {};
}

if (typeof($$.__global) == "undefined") {
    $$.__global = {};
}

if (typeof($$.__global.requireLibrariesNames) == "undefined") {
    $$.__global.currentLibraryName = null;
    $$.__global.requireLibrariesNames = {};
}


if (typeof($$.__runtimeModules) == "undefined") {
    $$.__runtimeModules = {};
}

require("./../standardGlobalSymbols");

if (typeof(global.functionUndefined) == "undefined") {
    global.functionUndefined = function () {
        console.log("Called of an undefined function!!!!");
        throw new Error("Called of an undefined function");
    };
    if (typeof(global.webshimsRequire) == "undefined") {
        global.webshimsRequire = global.functionUndefined;
    }

    if (typeof(global.domainRequire) == "undefined") {
        global.domainRequire = global.functionUndefined;
    }

    if (typeof(global.pskruntimeRequire) == "undefined") {
        global.pskruntimeRequire = global.functionUndefined;
    }
}

const weAreInbrowser = (typeof ($$.browserRuntime) != "undefined");
const weAreInSandbox = (typeof global.require !== 'undefined');


const pastRequests = {};

function preventRecursiveRequire(request) {
    if (pastRequests[request]) {
        const err = new Error("Preventing recursive require for " + request);
        err.type = "PSKIgnorableError";
        throw err;
    }

}

function disableRequire(request) {
    pastRequests[request] = true;
}

function enableRequire(request) {
    pastRequests[request] = false;
}


function requireFromCache(request) {
    const existingModule = $$.__runtimeModules[request];
    return existingModule;
}

function wrapStep(callbackName) {
    const callback = global[callbackName];

    if (callback === undefined) {
        return null;
    }

    if (callback === global.functionUndefined) {
        return null;
    }

    return function (request) {
        const result = callback(request);
        $$.__runtimeModules[request] = result;
        return result;
    }
}

function tryRequireSequence(originalRequire, request) {
    let arr;
    if (originalRequire) {
        arr = $$.__requireFunctionsChain.slice();
        arr.push(originalRequire);
    } else {
        arr = $$.__requireFunctionsChain;
    }

    preventRecursiveRequire(request);
    disableRequire(request);
    let result;
    const previousRequire = $$.__global.currentLibraryName;
    let previousRequireChanged = false;

    if (!previousRequire) {
        // console.log("Loading library for require", request);
        $$.__global.currentLibraryName = request;

        if (typeof $$.__global.requireLibrariesNames[request] == "undefined") {
            $$.__global.requireLibrariesNames[request] = {};
            //$$.__global.requireLibrariesDescriptions[request]   = {};
        }
        previousRequireChanged = true;
    }
    for (let i = 0; i < arr.length; i++) {
        const func = arr[i];
        try {

            if (func === global.functionUndefined) continue;
            result = func(request);

            if (result) {
                break;
            }

        } catch (err) {
            if (err.type !== "PSKIgnorableError") {
                $$.log("Require encountered an error while loading ", request, "\nCause:\n", err.stack);
            }
        }
    }

    if (!result) {
        $$.log("Failed to load module ", request, result);
    }

    enableRequire(request);
    if (previousRequireChanged) {
        //console.log("End loading library for require", request, $$.__global.requireLibrariesNames[request]);
        $$.__global.currentLibraryName = null;
    }
    return result;
}

if (typeof($$.require) == "undefined") {

    $$.__requireList = ["webshimsRequire", "pskruntimeRequire"];
    $$.__requireFunctionsChain = [];

    $$.requireBundle = function (name) {
        name += "Require";
        $$.__requireList.push(name);
        const arr = [requireFromCache];
        $$.__requireList.forEach(function (item) {
            const callback = wrapStep(item);
            if (callback) {
                arr.push(callback);
            }
        });

        $$.__requireFunctionsChain = arr;
    };

    $$.requireBundle("init");

    if (weAreInbrowser) {
        $$.log("Defining global require in browser");


        global.require = function (request) {

            ///*[requireFromCache, wrapStep(webshimsRequire), , wrapStep(pskruntimeRequire), wrapStep(domainRequire)*]
            return tryRequireSequence(null, request);
        }
    } else
        if (weAreInSandbox) {
        // require should be provided when code is loaded in browserify
        const bundleRequire = require;

        $$.requireBundle('sandboxBase');
        // this should be set up by sandbox prior to
        const sandboxRequire = global.require;
        global.crypto = require('crypto');

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            // console.log('trying to load ', request);

            function tryBundleRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = sandboxRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = sandboxRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            let res;


            res = tryRequireSequence(tryBundleRequire, request);


            return res;
        }

        global.require = newLoader;

    } else {  //we are in node
        const path = require("path");
        $$.__runtimeModules["crypto"] = require("crypto");
        $$.__runtimeModules["util"] = require("util");

        const Module = require('module');
        $$.__runtimeModules["module"] = Module;

        $$.log("Redefining require for node");

        $$.__originalRequire = Module._load;
        const moduleOriginalRequire = Module.prototype.require;

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            function originalRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = moduleOriginalRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = moduleOriginalRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            function currentFolderRequire(request) {
                return
            }

            //[requireFromCache, wrapStep(pskruntimeRequire), wrapStep(domainRequire), originalRequire]
            return tryRequireSequence(originalRequire, request);
        }

        Module.prototype.require = newLoader;
    }

    $$.require = require;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../standardGlobalSymbols":"C:\\Users\\Public\\privatesky\\modules\\callflow\\standardGlobalSymbols.js","crypto":"crypto","module":false,"path":"path","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\parallelJoinPoint.js":[function(require,module,exports){

var globalJoinCounter = 0;

function ParallelJoinPoint(swarm, callback, args){
    globalJoinCounter++;
    var channelId = "ParallelJoinPoint" + globalJoinCounter;
    var self = this;
    var counter = 0;
    var stopOtherExecution     = false;

    function executionStep(stepFunc, localArgs, stop){

        this.doExecute = function(){
            if(stopOtherExecution){
                return false;
            }
            try{
                stepFunc.apply(swarm, localArgs);
                if(stop){
                    stopOtherExecution = true;
                    return false;
                }
                return true; //everyting is fine
            } catch(err){
                args.unshift(err);
                sendForSoundExecution(callback, args, true);
                return false; //stop it, do not call again anything
            }
        }
    }

    if(typeof callback !== "function"){
        $$.syntaxError("invalid join",swarm, "invalid function at join in swarm");
        return;
    }

    $$.PSK_PubSub.subscribe(channelId,function(forExecution){
        if(stopOtherExecution){
            return ;
        }

        try{
            if(forExecution.doExecute()){
                decCounter();
            } // had an error...
        } catch(err){
            $$.info(err);
            //$$.errorHandler.syntaxError("__internal__",swarm, "exception in the execution of the join function of a parallel task");
        }
    });

    function incCounter(){
        if(testIfUnderInspection()){
            //preventing inspector from increasing counter when reading the values for debug reason
            //console.log("preventing inspection");
            return;
        }
        counter++;
    }

    function testIfUnderInspection(){
        var res = false;
        var constArgv = process.execArgv.join();
        if(constArgv.indexOf("inspect")!==-1 || constArgv.indexOf("debug")!==-1){
            //only when running in debug
            var callstack = new Error().stack;
            if(callstack.indexOf("DebugCommandProcessor")!==-1){
                console.log("DebugCommandProcessor detected!");
                res = true;
            }
        }
        return res;
    }

    function sendForSoundExecution(funct, args, stop){
        var obj = new executionStep(funct, args, stop);
        $$.PSK_PubSub.publish(channelId, obj); // force execution to be "sound"
    }

    function decCounter(){
        counter--;
        if(counter == 0) {
            args.unshift(null);
            sendForSoundExecution(callback, args, false);
        }
    }

    var inner = swarm.getInnerValue();

    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return {
            text:"Parallel execution progress event",
            swarm:swarm,
            args:args,
            currentResult:res
        };
    }

    function mkFunction(name){
        return function(...args){
            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }
            var args = $$.__intern.mkArgs(args, 0);
            sendForSoundExecution(f, args, false);
            return __proxyObject;
        }
    }


    this.get = function(target, prop, receiver){
        if(inner.myFunctions.hasOwnProperty(prop) || prop == "progress"){
            incCounter();
            return mkFunction(prop);
        }
        return swarm[prop];
    };

    var __proxyObject;

    this.__setProxyObject = function(p){
        __proxyObject = p;
    }
}

exports.createJoinPoint = function(swarm, callback, args){
    var jp = new ParallelJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.__setProxyObject(p);
    return p;
};
},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\serialJoinPoint.js":[function(require,module,exports){

var joinCounter = 0;

function SerialJoinPoint(swarm, callback, args){

    joinCounter++;

    var self = this;
    var channelId = "SerialJoinPoint" + joinCounter;

    if(typeof callback !== "function"){
        $$.syntaxError("unknown", swarm, "invalid function given to serial in swarm");
        return;
    }

    var inner = swarm.getInnerValue();


    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return res;
    }


    var functionCounter     = 0;
    var executionCounter    = 0;

    var plannedExecutions   = [];
    var plannedArguments    = {};

    function mkFunction(name, pos){
        //console.log("Creating function ", name, pos);
        plannedArguments[pos] = undefined;

        function triggetNextStep(){
            if(plannedExecutions.length == executionCounter || plannedArguments[executionCounter] )  {
                $$.PSK_PubSub.publish(channelId, self);
            }
        }

        var f = function (...args){
            if(executionCounter != pos) {
                plannedArguments[pos] = args;
                //console.log("Delaying function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
                return __proxy;
            } else{
                if(plannedArguments[pos]){
                    //console.log("Executing  function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
					args = plannedArguments[pos];
                } else {
                    plannedArguments[pos] = args;
                    triggetNextStep();
                    return __proxy;
                }
            }

            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }


            try{
                f.apply(self,args);
            } catch(err){
                    args.unshift(err);
                    callback.apply(swarm,args); //error
                    $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
                return; //terminate execution with an error...!
            }
            executionCounter++;

            triggetNextStep();

            return __proxy;
        };

        plannedExecutions.push(f);
        functionCounter++;
        return f;
    }

     var finished = false;

    function runNextFunction(){
        if(executionCounter == plannedExecutions.length ){
            if(!finished){
                args.unshift(null);
                callback.apply(swarm,args);
                finished = true;
                $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
            } else {
                console.log("serial construct is using functions that are called multiple times...");
            }
        } else {
            plannedExecutions[executionCounter]();
        }
    }

    $$.PSK_PubSub.subscribe(channelId,runNextFunction); // force it to be "sound"


    this.get = function(target, prop, receiver){
        if(prop == "progress" || inner.myFunctions.hasOwnProperty(prop)){
            return mkFunction(prop, functionCounter);
        }
        return swarm[prop];
    }

    var __proxy;
    this.setProxyObject = function(p){
        __proxy = p;
    }
}

exports.createSerialJoinPoint = function(swarm, callback, args){
    var jp = new SerialJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.setProxyObject(p);
    return p;
}
},{}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\swarmDescription.js":[function(require,module,exports){
const OwM = require("swarmutils").OwM;

var swarmDescriptionsRegistry = {};
let currentInlineCounter = 0;

$$.registerSwarmDescription =  function(libraryName, shortName, swarmTypeName, description){
    if(!$$.libraries[libraryName]){
        $$.libraries[libraryName] = {};
    }

    if(!$$.__global.requireLibrariesNames[libraryName]){
        $$.__global.requireLibrariesNames[libraryName] = {};
    }

    $$.libraries[libraryName][shortName] = description;
    //console.log("Registering ", libraryName,shortName, $$.__global.currentLibraryName);
    if($$.__global.currentLibraryName){
        $$.__global.requireLibrariesNames[$$.__global.currentLibraryName][shortName] = libraryName + "." + shortName;
    }

    $$.__global.requireLibrariesNames[libraryName][shortName] = swarmTypeName;

    if(typeof description == "string"){
        description = swarmDescriptionsRegistry[description];
    }
    swarmDescriptionsRegistry[swarmTypeName] = description;
}


var currentLibraryCounter = 0;
$$.library = function(callback){
    currentLibraryCounter++;
    var previousCurrentLibrary = $$.__global.currentLibraryName;
    var libraryName = "___privatesky_library"+currentLibraryCounter;
    var ret = $$.__global.requireLibrariesNames[libraryName] = {};
    $$.__global.currentLibraryName = libraryName;
    callback();
    $$.__global.currentLibraryName = previousCurrentLibrary;
    ret.__autogenerated_privatesky_libraryName = libraryName;
    return ret;
}


$$.fixSwarmName = function(shortName){
    let fullName;
    if(shortName && shortName.includes(".")) {
        fullName = shortName;
    } else {
        fullName = $$.libraryPrefix + "." + shortName;
    }
    return fullName;
}

function SwarmSpace(swarmType, utils) {

    let beesHealer = require("swarmutils").beesHealer;

    function getFullName(shortName){
        return $$.fixSwarmName(shortName);
    }

    function VarDescription(desc){
        return {
            init:function(){
                return undefined;
            },
            restore:function(jsonString){
                return JSON.parse(jsonString);
            },
            toJsonString:function(x){
                return JSON.stringify();
            }
        };
    }

    function SwarmDescription(swarmTypeName, description){

        swarmTypeName = getFullName(swarmTypeName);

        var localId = 0;  // unique for each swarm

        function createVars(descr){
            var members = {};
            for(var v in descr){
                members[v] = new VarDescription(descr[v]);
            }
            return members;
        }

        function createMembers(descr){
            var members = {};
            for(var v in description){

                if(v != "public" && v != "private"){
                    members[v] = description[v];
                }
            }
            return members;
        }

        var publicVars = createVars(description.public);
        var privateVars = createVars(description.private);
        var myFunctions = createMembers(description);

        function createPhase(thisInstance, func, phaseName){
            var keyBefore = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.BEFORE_INTERCEPTOR}`;
            var keyAfter = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.AFTER_INTERCEPTOR}`;

            var phase = function(...args){
                var ret;
                try{
                    $$.PSK_PubSub.blockCallBacks();
                    thisInstance.setMetadata('phaseName', phaseName);
                    $$.interceptor.callInterceptors(keyBefore, thisInstance, args);
                    ret = func.apply(thisInstance, args);
                    $$.interceptor.callInterceptors(keyAfter, thisInstance, args);
                    $$.PSK_PubSub.releaseCallBacks();
                }catch(err){
                    $$.PSK_PubSub.releaseCallBacks();
                    throw err;
                }
                return ret;
            }
            //dynamic named func in order to improve callstack
            Object.defineProperty(phase, "name", {get: function(){return swarmTypeName+"."+func.name}});
            return phase;
        }

        this.initialise = function(serialisedValues){

            var result = new OwM({
                publicVars:{

                },
                privateVars:{

                },
                protectedVars:{

                },
                myFunctions:{

                },
                utilityFunctions:{

                },
                meta:{
                    swarmTypeName:swarmTypeName,
                    swarmDescription:description
                }
            });


            for(var v in publicVars){
                result.publicVars[v] = publicVars[v].init();
            };

            for(var v in privateVars){
                result.privateVars[v] = privateVars[v].init();
            };


            if(serialisedValues){
                beesHealer.jsonToNative(serialisedValues, result);
            }
            return result;
        };

        this.initialiseFunctions = function(valueObject, thisObject){

            for(var v in myFunctions){
                valueObject.myFunctions[v] = createPhase(thisObject, myFunctions[v], v);
            };

            localId++;
            valueObject.utilityFunctions = utils.createForObject(valueObject, thisObject, localId);

        }

        this.get = function(target, property, receiver){


            if(publicVars.hasOwnProperty(property))
            {
                return target.publicVars[property];
            }

            if(privateVars.hasOwnProperty(property))
            {
                return target.privateVars[property];
            }

            if(target.utilityFunctions.hasOwnProperty(property))
            {

                return target.utilityFunctions[property];
            }


            if(myFunctions.hasOwnProperty(property))
            {
                return target.myFunctions[property];
            }

            if(target.protectedVars.hasOwnProperty(property))
            {
                return target.protectedVars[property];
            }

            if(typeof property != "symbol") {
                $$.syntaxError(property, target);
            }
            return undefined;
        }

        this.set = function(target, property, value, receiver){

            if(target.utilityFunctions.hasOwnProperty(property) || target.myFunctions.hasOwnProperty(property)) {
                $$.syntaxError(property);
                throw new Error("Trying to overwrite immutable member" + property);
            }

            if(privateVars.hasOwnProperty(property))
            {
                target.privateVars[property] = value;
            } else
            if(publicVars.hasOwnProperty(property))
            {
                target.publicVars[property] = value;
            } else {
                target.protectedVars[property] = value;
            }
            return true;
        }

        this.apply = function(target, thisArg, argumentsList){
            console.log("Proxy apply");
            //var func = target[]
            //swarmGlobals.executionProvider.execute(null, thisArg, func, argumentsList)
        }

        var self = this;

        this.isExtensible = function(target) {
            return false;
        };

        this.has = function(target, prop) {
            if(target.publicVars[prop] || target.protectedVars[prop]) {
                return true;
            }
            return false;
        };

        this.ownKeys = function(target) {
            return Reflect.ownKeys(target.publicVars);
        };

        return function(serialisedValues){
            var valueObject = self.initialise(serialisedValues);
            var result = new Proxy(valueObject,self);
            self.initialiseFunctions(valueObject,result);
			if(!serialisedValues){
				if(!valueObject.getMeta("swarmId")){
					valueObject.setMeta("swarmId", $$.uidGenerator.safe_uuid());  //do not overwrite!!!
				}
				valueObject.utilityFunctions.notify();
			}

			if(result.autoInit){
                result.autoInit();
                $$.fixMe("Reinstate somehow the next comment")
                //result.autoInit = undefined;
            }
			return result;
        }
    }



    this.describe = function describeSwarm(swarmTypeName, description){
        swarmTypeName = getFullName(swarmTypeName);

        var pointPos = swarmTypeName.lastIndexOf('.');
        var shortName = swarmTypeName.substr( pointPos+ 1);
        var libraryName = swarmTypeName.substr(0, pointPos);
        if(!libraryName){
            libraryName = "global";
        }

        var description = new SwarmDescription(swarmTypeName, description);
        if(swarmDescriptionsRegistry[swarmTypeName] != undefined){
            $$.warn("Duplicate swarm description "+ swarmTypeName);
        }

        //swarmDescriptionsRegistry[swarmTypeName] = description;
		$$.registerSwarmDescription(libraryName, shortName, swarmTypeName, description);

        return description;
    }


    var self = this;
    $$.fixMe("This could generate memory leaks. Fix it later");
    this.inline = function inline(description, ...args){
        currentInlineCounter++;
        var desc = self.describe("inlineSwarm" + currentInlineCounter, description);
        var flow = desc();
        flow.start(...args);
        return flow;
    }

    this.create = function(){
        $$.err("Create APIs for creation of swarms was  removed. Use describe!");
    }

    this.continue = function(swarmTypeName, initialValues){
        swarmTypeName = getFullName(swarmTypeName);
        var desc = swarmDescriptionsRegistry[swarmTypeName];

        if(desc){
            return desc(initialValues);
        } else {
            $$.syntaxError(swarmTypeName,initialValues,
                "Failed to restart a swarm with type " + swarmTypeName + "\n Maybe different swarm space (used flow instead of swarm!?)");
        }
    }

    this.start = function(swarmTypeName, ctor, ...params){
        swarmTypeName = getFullName(swarmTypeName);
        var desc = swarmDescriptionsRegistry[swarmTypeName];
        if(!desc){
            $$.syntaxError(null, swarmTypeName);
            return null;
        }
        var res = desc();
        res.setMetadata("homeSecurityContext", $$.securityContext);

        if(ctor){
            res[ctor].apply(res, params);
        }

        return res;
    }
}

exports.createSwarmEngine = function(swarmType, utils){
    if(typeof utils == "undefined"){
        utils = require("./utilityFunctions/callflow");
    }
    return new SwarmSpace(swarmType, utils);
};


},{"./utilityFunctions/callflow":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\callflow.js","swarmutils":"swarmutils"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\asset.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;
	ret.isPersisted  	= function () {
		return thisObject.getMetadata('persisted') === true;
	};

	return ret;
};
},{"./base":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\base.js"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\base.js":[function(require,module,exports){
var beesHealer = require("swarmutils").beesHealer;
var swarmDebug = require("../choreographies/SwarmDebug");

exports.createForObject = function(valueObject, thisObject, localId){
	var ret = {};

	function filterForSerialisable (valueObject){
		return valueObject.meta.swarmId;
	}

	var swarmFunction = function(context, phaseName){
		var args =[];
		for(var i = 2; i < arguments.length; i++){
			args.push(arguments[i]);
		}

		//make the execution at level 0  (after all pending events) and wait to have a swarmId
		ret.observe(function(){
			beesHealer.asJSON(valueObject, phaseName, args, function(err,jsMsg){
				jsMsg.meta.target = context;
				var subscribersCount = $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
				if(!subscribersCount){
					console.log(`Nobody listening for <${$$.CONSTANTS.SWARM_FOR_EXECUTION}>!`);
				}
			});
		},null,filterForSerialisable);

		ret.notify();


		return thisObject;
	};

	var asyncReturn = function(err, result){
		var context = valueObject.protectedVars.context;

		if(!context && valueObject.meta.waitStack){
			context = valueObject.meta.waitStack.pop();
			valueObject.protectedVars.context = context;
		}

		beesHealer.asJSON(valueObject, "__return__", [err, result], function(err,jsMsg){
			jsMsg.meta.command = "asyncReturn";
			if(!context){
				context = valueObject.meta.homeSecurityContext;//TODO: CHECK THIS

			}
			jsMsg.meta.target = context;

			if(!context){
				$$.err(new Error("Asynchronous return inside of a swarm that does not wait for results"));
			} else {
				$$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
			}
		});
	};

	function home(err, result){
		beesHealer.asJSON(valueObject, "home", [err, result], function(err,jsMsg){
			var context = valueObject.meta.homeContext;
			jsMsg.meta.target = context;
			$$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
		});
	}



	function waitResults(callback, keepAliveCheck, swarm){
		if(!swarm){
			swarm = this;
		}
		if(!keepAliveCheck){
			keepAliveCheck = function(){
				return false;
			}
		}
		var inner = swarm.getInnerValue();
		if(!inner.meta.waitStack){
			inner.meta.waitStack = [];
			inner.meta.waitStack.push($$.securityContext)
		}
		$$.swarmsInstancesManager.waitForSwarm(callback, swarm, keepAliveCheck);
	}


	function getInnerValue(){
		return valueObject;
	}

	function runPhase(functName, args){
		var func = valueObject.myFunctions[functName];
		if(func){
			func.apply(thisObject, args);
		} else {
			$$.syntaxError(functName, valueObject, "Function " + functName + " does not exist!");
		}

	}

	function update(serialisation){
		beesHealer.jsonToNative(serialisation,valueObject);
	}


	function valueOf(){
		var ret = {};
		ret.meta                = valueObject.meta;
		ret.publicVars          = valueObject.publicVars;
		ret.privateVars         = valueObject.privateVars;
		ret.protectedVars       = valueObject.protectedVars;
		return ret;
	}

	function toString (){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}


	function createParallel(callback){
		return require("../parallelJoinPoint").createJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function createSerial(callback){
		return require("../serialJoinPoint").createSerialJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function inspect(){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}

	function constructor(){
		return SwarmDescription;
	}

	function ensureLocalId(){
		if(!valueObject.localId){
			valueObject.localId = valueObject.meta.swarmTypeName + "-" + localId;
			localId++;
		}
	}

	function observe(callback, waitForMore, filter){
		if(!waitForMore){
			waitForMore = function (){
				return false;
			}
		}

		ensureLocalId();

		$$.PSK_PubSub.subscribe(valueObject.localId, callback, waitForMore, filter);
	}

	function toJSON(prop){
		//preventing max call stack size exceeding on proxy auto referencing
		//replace {} as result of JSON(Proxy) with the string [Object protected object]
		return "[Object protected object]";
	}

	function getJSON(callback){
		return	beesHealer.asJSON(valueObject, null, null,callback);
	}

	function notify(event){
		if(!event){
			event = valueObject;
		}
		ensureLocalId();
		$$.PSK_PubSub.publish(valueObject.localId, event);
	}

	function getMeta(name){
		return valueObject.getMeta(name);
	}

	function setMeta(name, value){
		return valueObject.setMeta(name, value);
	}

	ret.setMeta			= setMeta;
	ret.getMeta			= getMeta;
	ret.swarm           = swarmFunction;
	ret.notify          = notify;
	ret.getJSON    	    = getJSON;
	ret.toJSON          = toJSON;
	ret.observe         = observe;
	ret.inspect         = inspect;
	ret.join            = createParallel;
	ret.parallel        = createParallel;
	ret.serial          = createSerial;
	ret.valueOf         = valueOf;
	ret.update          = update;
	ret.runPhase        = runPhase;
	ret.onReturn        = waitResults;
	ret.onResult        = waitResults;
	ret.asyncReturn     = asyncReturn;
	ret.return          = asyncReturn;
	ret.getInnerValue   = getInnerValue;
	ret.home            = home;
	ret.toString        = toString;
	ret.constructor     = constructor;
	ret.setMetadata		= valueObject.setMeta.bind(valueObject);
	ret.getMetadata		= valueObject.getMeta.bind(valueObject);

	ret.autoInit		= null;
	return ret;

};

},{"../choreographies/SwarmDebug":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\SwarmDebug.js","../parallelJoinPoint":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\parallelJoinPoint.js","../serialJoinPoint":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\serialJoinPoint.js","swarmutils":"swarmutils"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\callflow.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;

	return ret;
};
},{"./base":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\base.js"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\transaction.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;
	ret.autoInit        = function(){
		thisObject.transaction = $$.blockchain.beginTransaction(thisObject);
	};
	ret.isPersisted  	= function () {
		return thisObject.getMetadata('persisted') === true;
	};

	return ret;
};
},{"./base":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\base.js"}],"C:\\Users\\Public\\privatesky\\modules\\callflow\\standardGlobalSymbols.js":[function(require,module,exports){
let logger = console;

if (process.env.NO_LOGS !== 'true') {
    try {
        const PSKLoggerModule = require('psklogger');
        const PSKLogger = PSKLoggerModule.PSKLogger;
        
        logger = PSKLogger.getLogger();
        
        // TODO: remove this once $$ logger is used instead of console
        PSKLoggerModule.overwriteConsole();

        console.log('Logger init successful', process.pid);
    } catch (e) {
        console.warn('Logger not available, using console', e);
        logger = console;
    }
} else {
    console.log('Environment flag NO_LOGS is set, logging to console');
}

$$.registerGlobalSymbol = function (newSymbol, value) {
    if (typeof $$[newSymbol] == "undefined") {
        Object.defineProperty($$, newSymbol, {
            value: value,
            writable: false
        });
    } else {
        logger.error("Refusing to overwrite $$." + newSymbol);
    }
};

$$.registerGlobalSymbol("autoThrow", function (err) {
    if (!err) {
        throw err;
    }
});

$$.registerGlobalSymbol("propagateError", function (err,callback) {
    if (err) {
        callback(err);
        throw err; //stop execution
    }
});

$$.registerGlobalSymbol("logError", function (err) {
    if (err) {
        console.log(err);
        $$.err(err);
    }
});

console.log("Fix the fixMe to not display on console but put in logs");
$$.registerGlobalSymbol("fixMe", function (...args) {
        //$$.log(...args);
});

$$.registerGlobalSymbol("exception", function (message, type) {
        throw new Error(message);
});

$$.registerGlobalSymbol("throw", function (message, type) {
        throw new Error(message);
});

/* a feature is planned but not implemented (during development) but
also it could remain in production and should be flagged asap*/
$$.registerGlobalSymbol("incomplete", function (...args) {
    args.unshift("Incomplete feature touched:");
    logger.warn(...args);
});

/* used during development and when trying to discover elusive errors*/
$$.registerGlobalSymbol("assert", function (value, explainWhy) {
    if (!value) {
        throw new Error("Assert false " + explainWhy);
    }
});

/* enable/disabale flags that control psk behaviour*/
$$.registerGlobalSymbol("flags", function (flagName, value) {
    $$.incomplete("flags handling not implemented");
});

$$.registerGlobalSymbol("obsolete", function (...args) {
    args.unshift("Obsolete feature:");
    logger.log(...args);
    console.log(...args);
});

$$.registerGlobalSymbol("log", function (...args) {
    args.unshift("Log:");
    logger.log(...args);
    console.log(...args);
});

$$.registerGlobalSymbol("info", function (...args) {
    args.unshift("Info:");
    logger.log(...args);
    console.log(...args);
});


$$.registerGlobalSymbol("err", function (...args) {
    args.unshift("Error:");
    logger.error(...args);
    console.log(...args);
});

$$.registerGlobalSymbol("warn", function (...args) {
    args.unshift("Warn:");
    logger.warn(...args);
    console.log(...args);
});

$$.registerGlobalSymbol("syntaxError", function (...args) {
    args.unshift("Unknown syntaxError:");
    logger.log(...args);
});

$$.invalidMemberName = function (name, swarm) {
    var swarmName = "unknown"
    if(swarm && swarm.meta){
        swarmName = swarm.meta.swarmTypeName;
    }
    var text = "Invalid member name " + name + "in swarm " + swarmName;
    console.log(text);
    logger.log(text);
};

$$.registerGlobalSymbol("invalidSwarmName", function ( swarmName) {
    var text = "Invalid swarm name " + swarmName;
    console.log(text);
    logger.log(text);
});

/* log unknown exceptions*/
$$.registerGlobalSymbol("unknownException", function (...args) {
    args.unshift("unknownException:");
    logger.log(...args);
});

/* PrivateSky event, used by monitoring and statistics*/
$$.registerGlobalSymbol("event", function (event, ...args) {
    if (logger.hasOwnProperty('event')) {
        logger.event(event, ...args);
    } else {
        console.log(event, ...args);
    }
});

/* */
$$.registerGlobalSymbol("redirectLog", function(logType, logObject) {
    logger.redirect(logType, logObject);
});

/* log throttling event // it is just an event?*/
$$.registerGlobalSymbol("throttlingEvent", function (...args) {
    logger.log(...args);
});

},{"psklogger":"psklogger"}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardAsserts.js":[function(require,module,exports){

module.exports.init = function(sf, logger){
    /**
     * Registering handler for failed asserts. The handler is doing logging and is throwing an error.
     * @param explanation {String} - failing reason message.
     */
    let __failWasAlreadyGenerated = false;
    let __assetsCounter = 0;

    setTimeout(function(){
        if(!beginWasCalled){
            sf.assert.begin("Begin was not called, setting exit time for the test in 1 second") ;
        }

    },1000)


    var beginWasCalled = false;
    /**
     * Registering assert for printing a message and asynchronously printing all logs from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param cleanFunctions {Function} - cleaning function
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('begin', function(message, cleanFunctions, timeout){
        //logger.recordAssert(message);
        beginWasCalled = true;
        console.log(message);
        sf.assert.end(cleanFunctions, timeout, true);
    });

    sf.assert.addCheck('preventPrematureEnd', function(){
        beginWasCalled = true;
    });

    function recordFail(...args){ //record fail only once
        if(!__failWasAlreadyGenerated){
            __failWasAlreadyGenerated = true;
            logger.recordAssert(...args);
        }
    }




    sf.exceptions.register('assertFail', function(explanation){
        const message = "Assert or invariant has failed " + (explanation ? explanation : "");
        const err = new Error(message);

        recordFail('[Fail] ' + message, err, true);
        throw err;
    });

    /**
     * Registering assert for equality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails.
     */
    sf.assert.addCheck('equal', function(v1 , v2, explanation){
        if(v1 !== v2){
            if(!explanation){
                explanation =  "Assertion failed: [" + v1 + " !== " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for inequality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notEqual', function(v1, v2, explanation){
        if(v1 === v2){
            if(!explanation){
                explanation =  " ["+ v1 + " == " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to true. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('true', function(b, explanation){
        if(!b){
            if(!explanation){
                explanation =  " expression is false but is expected to be true";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to false. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('false', function(b, explanation){
        if(b){
            if(!explanation){
                explanation =  " expression is true but is expected to be false";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('isNull', function(v1, explanation){
        if(v1 !== null){
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to be not null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notNull', function(v1 , explanation){
        if(v1 === null && typeof v1 === "object"){
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Checks if all properties of the second object are own properties of the first object.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @returns {boolean} - returns true, if the check has passed or false otherwise.
     */
    function objectHasFields(firstObj, secondObj){
        for(let field in secondObj) {
            if (firstObj.hasOwnProperty(field)) {
                if (firstObj[field] !== secondObj[field]) {
                    return false;
                }
            }
            else{
                return false;
            }
        }
        return true;
    }

    function objectsAreEqual(firstObj, secondObj) {
        let areEqual = true;
        if(firstObj !== secondObj) {
            if(typeof firstObj !== typeof secondObj) {
                areEqual = false;
            } else if (Array.isArray(firstObj) && Array.isArray(secondObj)) {
	            firstObj.sort();
	            secondObj.sort();
		        if (firstObj.length !== secondObj.length) {
			        areEqual = false;
		        } else {
			        for (let i = 0; i < firstObj.length; ++i) {
				        if (!objectsAreEqual(firstObj[i], secondObj[i])) {
					        areEqual = false;
					        break;
				        }
			        }
		        }
	        } else if((typeof firstObj === 'function' && typeof secondObj === 'function') ||
		        (firstObj instanceof Date && secondObj instanceof Date) ||
		        (firstObj instanceof RegExp && secondObj instanceof RegExp) ||
		        (firstObj instanceof String && secondObj instanceof String) ||
		        (firstObj instanceof Number && secondObj instanceof Number)) {
                    areEqual = firstObj.toString() === secondObj.toString();
            } else if(typeof firstObj === 'object' && typeof secondObj === 'object') {
                areEqual = objectHasFields(firstObj, secondObj);
            // isNaN(undefined) returns true
            } else if(isNaN(firstObj) && isNaN(secondObj) && typeof firstObj === 'number' && typeof secondObj === 'number') {
                areEqual = true;
            } else {
                areEqual = false;
            }
        }

        return areEqual;
    }

    /**
     * Registering assert for evaluating if all properties of the second object are own properties of the first object.
     * If check fails, the assertFail is invoked.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("objectHasFields", function(firstObj, secondObj, explanation){
        if(!objectHasFields(firstObj, secondObj)) {
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating if all element from the second array are present in the first array.
     * Deep comparison between the elements of the array is used.
     * If check fails, the assertFail is invoked.
     * @param firstArray {Array}- first array
     * @param secondArray {Array} - second array
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("arraysMatch", function(firstArray, secondArray, explanation){
        if(firstArray.length !== secondArray.length){
            sf.exceptions.assertFail(explanation);
        }
        else {
            const result = objectsAreEqual(firstArray, secondArray);
            // const arraysDontMatch = secondArray.every(element => firstArray.indexOf(element) !== -1);
            // let arraysDontMatch = secondArray.some(function (expectedElement) {
            //     let found = firstArray.some(function(resultElement){
            //         return objectHasFields(resultElement,expectedElement);
            //     });
            //     return found === false;
            // });

            if(!result){
                sf.exceptions.assertFail(explanation);
            }
        }
    });

    // added mainly for test purposes, better test frameworks like mocha could be much better

    /**
     * Registering assert for checking if a function is failing.
     * If the function is throwing an exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('fail', function(testName, func){
        try{
            func();
            recordFail("[Fail] " + testName);
        } catch(err){
            logger.recordAssert("[Pass] " + testName);
        }
    });

    /**
     * Registering assert for checking if a function is executed with no exceptions.
     * If the function is not throwing any exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('pass', function(testName, func){
        try{
            func();
            logger.recordAssert("[Pass] " + testName);
        } catch(err){
            recordFail("[Fail] " + testName, err.stack);
        }
    });

    /**
     * Alias for the pass assert.
     */
    sf.assert.alias('test', 'pass');

    /**
     * Registering assert for checking if a callback function is executed before timeout is reached without any exceptions.
     * If the function is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('callback', function(testName, func, timeout){
        __assetsCounter++;
        if(!func || typeof func != "function"){
            throw new Error("Wrong usage of assert.callback!");
        }

        if(!timeout){
            timeout = 500;
        }

        var passed = false;
        function callback(){
            __assetsCounter--;
            if(!passed){
                passed = true;
                logger.recordAssert("[Pass] " + testName);
                successTest();
            } else {
                recordFail("[Fail (multiple calls)] " + testName);
            }
        }
        
        try{
            func(callback);
        } catch(err){
            recordFail("[Fail] " + testName,  err, true);
        }

        function successTest(force){
            if(!passed){
                logger.recordAssert("[Fail Timeout] " + testName );
            }
        }

        setTimeout(successTest, timeout);
    });

    /**
     * Registering assert for checking if an array of callback functions are executed in a waterfall manner,
     * before timeout is reached without any exceptions.
     * If any of the functions is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('steps', function(testName, arr, timeout){
        if(!timeout){
            timeout = 500;
        }

        var currentStep = 0;
        var passed = false;

        function next(){
            if(currentStep === arr.length){
                passed = true;
                logger.recordAssert("[Pass] " + testName );
                return;
            }

            var func = arr[currentStep];
            currentStep++;
            try{
                func(next);
            } catch(err){
                recordFail("[Fail] " + testName  + " [at step " + currentStep + "]", err);
            }
        }

        function successTest(force){
            if(!passed){
                recordFail("[Fail Timeout] " + testName  + " [at step " + currentStep + "]");
            }
        }

        setTimeout(successTest, timeout);
        next();
    });

    /**
     * Alias for the steps assert.
     */
    sf.assert.alias('waterfall', 'steps');


    var cleaningArray = [];
    /**
     * Registering a cleaning function
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('addCleaningFunction', function(func){
        cleaningArray.push(func);
    });

    /**
     * Registering a cleaning function
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('disableCleanings', function(func){
        cleaningArray = [];
    });

    /**
     * Registering assert for asynchronously printing all execution summary from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('end', function(cleaningFunction, timeout, silence){
        if(!timeout){
            timeout = 1000;
        }

        function handler() {
            if(logger.dumpWhys){
                logger.dumpWhys().forEach(function(c){
                    const executionSummary = c.getExecutionSummary();
                    console.log(JSON.stringify(executionSummary, null, 4));
                });
            }

            if(!silence){
                console.log("Forcing exit after", timeout, "ms");
            }

            setTimeout(function(){
                if(__failWasAlreadyGenerated || __assetsCounter != 0){
                    process.exit(1);
                }  else {
                    process.exit(0);
                }
            }, 1000)

            cleaningArray.map(function(func){
                func();
            })
            if(cleaningFunction){
                cleaningFunction();
            }
        }

        setTimeout(handler, timeout);
    });





};
},{}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardChecks.js":[function(require,module,exports){
/*
    checks are like asserts but are intended to be used in production code to help debugging and signaling wrong behaviours

 */

exports.init = function(sf){
    sf.exceptions.register('checkFail', function(explanation, err){
        var stack;
        if(err){
            stack = err.stack;
        }
        console.log("Check failed ", explanation, stack);
    });

    sf.check.addCheck('equal', function(v1 , v2, explanation){

        if(v1 !== v2){
            if(!explanation){
                explanation =  " ["+ v1 + " != " + v2 + "]";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('true', function(b, explanation){
        if(!b){
            if(!explanation){
                explanation =  " expression is false but is expected to be true";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('false', function(b, explanation){
        if(b){
            if(!explanation){
                explanation =  " expression is true but is expected to be false";
            }

            sf.exceptions.checkFail(explanation);
        }
    });

    sf.check.addCheck('notequal', function(v1 , v2, explanation){
        if(v1 == v2){
            if(!explanation){
                explanation =  " ["+ v1 + " == " + v2 + "]";
            }
            sf.exceptions.checkFail(explanation);
        }
    });


    /*
        added mainly for test purposes, better test frameworks like mocha could be much better :)
    */
    sf.check.addCheck('fail', function(testName ,func){
        try{
            func();
            console.log("[Fail] " + testName );
        } catch(err){
            console.log("[Pass] " + testName );
        }
    });


    sf.check.addCheck('pass', function(testName ,func){
        try{
            func();
            console.log("[Pass] " + testName );
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }
    });


    sf.check.alias('test','pass');


    sf.check.addCheck('callback', function(testName ,func, timeout){
        if(!timeout){
            timeout = 500;
        }
        var passed = false;
        function callback(){
            if(!passed){
                passed = true;
                console.log("[Pass] " + testName );
                SuccessTest();
            } else {
                console.log("[Fail (multiple calls)] " + testName );
            }
        }
        try{
            func(callback);
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName );
            }
        }

        setTimeout(SuccessTest, timeout);
    });


    sf.check.addCheck('steps', function(testName , arr, timeout){
        var  currentStep = 0;
        var passed = false;
        if(!timeout){
            timeout = 500;
        }

        function next(){
            if(currentStep === arr.length){
                passed = true;
                console.log("[Pass] " + testName );
                return ;
            }
            var func = arr[currentStep];
            currentStep++;
            try{
                func(next);
            } catch(err){
                console.log("[Fail] " + testName  ,"\n\t" , err.stack + "\n\t" , " [at step ", currentStep + "]");
            }
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName + "\n\t" , " [at step ", currentStep+ "]");
            }
        }

        setTimeout(SuccessTest, timeout);
        next();
    });

    sf.check.alias('waterfall','steps');
    sf.check.alias('notEqual','notequal');

    sf.check.addCheck('end', function(timeOut, silence){
        if(!timeOut){
            timeOut = 1000;
        }

        setTimeout(function(){
            if(!silence){
                console.log("Forcing exit after", timeOut, "ms");
            }
            process.exit(0);
        }, timeOut);
    });


    sf.check.addCheck('begin', function(message, timeOut){
        console.log(message);
        sf.check.end(timeOut, true);
    });


};
},{}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardExceptions.js":[function(require,module,exports){
exports.init = function(sf){
    /**
     * Registering unknown exception handler.
     */
    sf.exceptions.register('unknown', function(explanation){
        explanation = explanation || "";
        const message = "Unknown exception" + explanation;
        throw(message);
    });

    /**
     * Registering resend exception handler.
     */
    sf.exceptions.register('resend', function(exceptions){
        throw(exceptions);
    });

    /**
     * Registering notImplemented exception handler.
     */
    sf.exceptions.register('notImplemented', function(explanation){
        explanation = explanation || "";
        const message = "notImplemented exception" + explanation;
        throw(message);
    });

    /**
     * Registering security exception handler.
     */
    sf.exceptions.register('security', function(explanation){
        explanation = explanation || "";
        const message = "security exception" + explanation;
        throw(message);
    });

    /**
     * Registering duplicateDependency exception handler.
     */
    sf.exceptions.register('duplicateDependency', function(variable){
        variable = variable || "";
        const message = "duplicateDependency exception" + variable;
        throw(message);
    });
};
},{}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardLogs.js":[function(require,module,exports){
const LOG_LEVELS = {
    HARD_ERROR: 0,  // system level critical error: hardError
    ERROR: 1,  // potentially causing user's data loosing error: error
    LOG_ERROR: 2,  // minor annoyance, recoverable error:   logError
    UX_ERROR: 3,  // user experience causing issues error:  uxError
    WARN: 4,  // warning,possible isues but somehow unclear behaviour: warn
    INFO: 5,  // store general info about the system working: info
    DEBUG: 6,  // system level debug: debug
    LOCAL_DEBUG: 7,  // local node/service debug: ldebug
    USER_DEBUG: 8,  // user level debug; udebug
    DEV_DEBUG: 9,  // development time debug: ddebug
    WHYS: 10, // whyLog for code reasoning
    TEST_RESULT: 11, // testResult to log running tests
};

exports.init = function (sf) {

    /**
     * Records log messages from various use cases.
     * @param record {String} - log message.
     */
    sf.logger.record = function (record) {
        const triggerStrings = ["pskruntime", "double-check"];
        var displayOnConsole = true;
        if (process.send) {
            process.send(record);
            displayOnConsole = false;
        }

        function removeLines(str, nb) {
            function removeLine(str,  force) {
                var pos = str.indexOf("\n");
                var willBeRemoved = str.slice(0, pos);

                if (!force) {
                    var foundMatch = false;
                    for(var i=0; i< triggerStrings.length;i++){
                        let item = triggerStrings[i];
                        if (willBeRemoved.indexOf(item) != -1) {
                            foundMatch = true;
                        }
                    }
                    if (!foundMatch) {
                        throw foundMatch;
                    }
                }
                return str.slice(pos + 1, str.length);
            }

            let ret = str;
            for (let v = 0; v < nb; v++) {
                try {
                    ret = removeLine(ret, v==0);
                } catch (err) {
                    // nothing... exit for
                }
            }
            return ret;
        }

        if (displayOnConsole) {
            //const prettyLog = JSON.stringify(record, null, 2);
            //console.log(prettyLog);
            console.log(record.message, typeof (record.stack));
            if (record.stack) {
                var pos = record.stack.indexOf("\n");
                var message = record.stack.slice(0, pos);
                console.log(message);
                console.log(removeLines(record.stack, 3));
            }
        }
    };

    /**
     * Adding case for logging system level critical errors.
     */
    sf.logger.addCase('hardError', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.HARD_ERROR, 'systemError', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging potentially causing user's data loosing errors.
     */
    sf.logger.addCase('error', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.ERROR, 'error', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        },
        {
            'exception': 'exception'
        }
    ]);

    /**
     * Adding case for logging minor annoyance, recoverable errors.
     */
    sf.logger.addCase('logError', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOG_ERROR, 'logError', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        },
        {
            'exception': 'exception'
        }
    ]);

    /**
     * Adding case for logging user experience causing issues errors.
     */
    sf.logger.addCase('uxError', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.UX_ERROR, 'uxError', message, null, false));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging throttling messages.
     */
    sf.logger.addCase('throttling', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'throttling', message, null, false));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging warning, possible issues, but somehow unclear behaviours.
     */
    sf.logger.addCase('warning', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'warning', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    sf.logger.alias('warn', 'warning');

    /**
     * Adding case for logging general info about the system working.
     */
    sf.logger.addCase('info', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.INFO, 'info', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging system level debug messages.
     */
    sf.logger.addCase('debug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEBUG, 'debug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);


    /**
     * Adding case for logging local node/service debug messages.
     */
    sf.logger.addCase('ldebug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOCAL_DEBUG, 'ldebug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging user level debug messages.
     */
    sf.logger.addCase('udebug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.USER_DEBUG, 'udebug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging development debug messages.
     */
    sf.logger.addCase('devel', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEV_DEBUG, 'devel', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging "whys" reasoning messages.
     */
    sf.logger.addCase("logWhy", function (logOnlyCurrentWhyContext) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WHYS, 'logwhy', undefined, undefined, undefined, undefined, undefined, undefined, logOnlyCurrentWhyContext));
    });

    /**
     * Adding case for logging asserts messages to running tests.
     */
    sf.logger.addCase("recordAssert", function (message, error, showStack) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.TEST_RESULT, 'assert', message, error, showStack));
    });

    /**
     * Generic method to create structured debug records based on the log level.
     * @param level {Number} - number from 1-11, used to identify the level of attention that a log entry should get from operations point of view
     * @param type {String} - identifier name for log type
     * @param message {String} - description of the debug record
     * @param exception {String} - exception details if any
     * @param saveStack {Boolean} - if set to true, the exception call stack will be added to the debug record
     * @param args {Array} - arguments of the caller function
     * @param pos {Number} - position
     * @param data {String|Number|Array|Object} - payload information
     * @param logOnlyCurrentWhyContext - if whys is enabled, only the current context will be logged
     * @returns Debug record model {Object} with the following fields:
     * [required]: level: *, type: *, timestamp: number, message: *, data: * and
     * [optional]: stack: *, exception: *, args: *, whyLog: *
     */
    function createDebugRecord(level, type, message, exception, saveStack, args, pos, data, logOnlyCurrentWhyContext) {

        var ret = {
            level: level,
            type: type,
            timestamp: (new Date()).getTime(),
            message: message,
            data: data
        };

        if (saveStack) {
            var stack = '';
            if (exception) {
                stack = exception.stack;
            } else {
                stack = (new Error()).stack;
            }
            ret.stack = stack;
        }

        if (exception) {
            ret.exception = exception.message;
        }

        if (args) {
            ret.args = JSON.parse(JSON.stringify(args));
        }

        if (process.env.RUN_WITH_WHYS) {
            var why = require('whys');
            if (logOnlyCurrentWhyContext) {
                ret['whyLog'] = why.getGlobalCurrentContext().getExecutionSummary();
            } else {
                ret['whyLog'] = why.getAllContexts().map(function (context) {
                    return context.getExecutionSummary();
                });
            }
        }
        return ret;
    }

}
;


},{"whys":false}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\testRunner.js":[function(require,module,exports){
(function (Buffer,__dirname){
const fs = require("fs");
const path = require("path");
const forker = require('child_process');

const DEFAULT_TIMEOUT = 2000;

var globToRegExp =  require("./utils/glob-to-regexp");

var defaultConfig = {
    confFileName: "double-check.json",      // name of the conf file
    fileExt: ".js",                         // test file supported by extension
    matchDirs: [ 'test', 'tests' ],           // dirs names for tests - case insensitive (used in discovery process)
    testsDir: process.cwd(),                // path to the root tests location
    reports: {
        basePath: process.cwd(),            // path where the reports will be saved
        prefix: "Report-",                  // prefix for report files, filename pattern: [prefix]-{timestamp}{ext}
        ext: ".txt"                         // report file extension
    }
};

const TAG = "[TEST_RUNNER]";
const MAX_WORKERS = process.env['DOUBLE_CHECK_POOL_SIZE'] || 10;
const DEBUG = typeof v8debug === 'object';

const TEST_STATES = {
    READY: 'ready',
    RUNNING: 'running',
    FINISHED: 'finished',
    TIMEOUT: 'timeout'
};

// Session object
var defaultSession = {
    testCount: 0,
    currentTestIndex: 0,
    debugPort: process.debugPort,   // current process debug port. The child process will be increased from this port
    workers: {
        running: 0,
        terminated: 0
    }
};

// Template structure for test reports.
var reportFileStructure = {
    count: 0,
    suites: {
        count: 0,
        items: []
    },
    passed: {
        count: 0,
        items: []
    },
    failed: {
        count: 0,
        items: []
    },
};

exports.init = function(sf){
    sf.testRunner = {
        /**
         * Initialization of the test runner.
         * @param config {Object} - settings object that will be merged with the default one
         * @private
         */
        __init: function(config) {
            this.config = this.__extend(defaultConfig, config);
            this.testTree = {};
            this.testList = [];

            this.session = defaultSession;

            // create reports directory if not exist
            if (!fs.existsSync(this.config.reports.basePath)){
                fs.mkdirSync(this.config.reports.basePath);
            }
        },
        /**
         * Main entry point. It will start the flow runner flow.
         * @param config {Object} - object containing settings such as conf file name, test dir.
         * @param callback {Function} - handler(error, result) invoked when an error occurred or the runner has completed all jobs.
         */
        start: function(config, callback) {

            // wrapper for provided callback, if any
            this.callback = function(err, result) {
                if(err) {
                    this.__debugInfo(err.message || err);
                }

                if(callback) {
                    return callback(err, result);
                }
            };

            this.__init(config);

            this.__consoleLog("Discovering tests ...");
            this.testTree = this.__discoverTestFiles(this.config.testsDir, config);
            this.testList = this.__toTestTreeToList(this.testTree);
            this.__launchTests();
        },
        /**
         * Reads configuration settings from a json file.
         * @param confPath {String} - absolute path to the configuration file.
         * @returns {Object} - configuration object {{}}
         * @private
         */
        __readConf: function(confPath) {
            var config = {};
            try{
                config = require(confPath);
            } catch(error) {
                console.error(error);
            }

            return config;
        },
        /**
         * Discovers test files recursively starting from a path. The dir is the root of the test files. It can contains
         * test files and test sub directories. It will create a tree structure with the test files discovered.
         * Notes: Only the config.matchDirs will be taken into consideration. Also, based on the conf (double-check.json)
         * it will include the test files or not.
         * @param dir {String} - path where the discovery process starts
         * @param parentConf {String} - configuration object (double-check.json) from the parent directory
         * @returns The root node object of the file structure tree. E.g. {*|{__meta, data, result, items}}
         * @private
         */
        __discoverTestFiles: function(dir, parentConf) {
            const stat = fs.statSync(dir);
            if(!stat.isDirectory()){
                throw new Error(dir + " is not a directory!");
            }

            let currentConf = parentConf;

            let currentNode = this.__getDefaultNodeStructure();
            currentNode.__meta.parent = path.dirname(dir);
            currentNode.__meta.isDirectory = true;

            let files = fs.readdirSync(dir);
            // first look for conf file
            if(files.indexOf(this.config.confFileName) !== -1) {
                let fd = path.join(dir, this.config.confFileName);
                let conf = this.__readConf(fd);
                if(conf) {
                    currentNode.__meta.conf = conf;
                    currentConf = conf;
                }
            }

            currentNode.data.name = path.basename(dir);
            currentNode.data.path = dir;
            currentNode.items = [];

            for(let i = 0, len = files.length; i < len; i++) {
                let item = files[i];

                let fd = path.join(dir, item);
                let stat = fs.statSync(fd);
                let isDir = stat.isDirectory();
                let isTestDir = this.__isTestDir(fd);

                if(isDir && !isTestDir) {
                    continue; // ignore dirs that does not follow the naming rule for test dirs
                }

                if(!isDir && item.match(this.config.confFileName)){
                    continue; // already processed
                }

                // exclude files based on glob patterns
                if(currentConf) {
                    // currentConf['ignore'] - array of regExp
                    if(currentConf['ignore']) {
                        const isMatch = this.__isAnyMatch(currentConf['ignore'], item);
                        if(isMatch) {continue;}
                    }
                }

                let childNode = this.__getDefaultNodeStructure();
                childNode.__meta.conf = {};
                childNode.__meta.isDirectory = isDir;
                childNode.__meta.parent = path.dirname(fd);

                if (isDir) {
                    let tempChildNode = this.__discoverTestFiles(fd, currentConf);
                    childNode = Object.assign(childNode, tempChildNode);
                    currentNode.items.push(childNode);
                }
                else if(path.extname(fd) ===  this.config.fileExt){
                    childNode.__meta.conf.runs = currentConf['runs'] || 1;
                    childNode.__meta.conf.silent = currentConf['silent'];
                    childNode.__meta.conf.timeout = currentConf['timeout'] || DEFAULT_TIMEOUT;

                    childNode.data.name = item;
                    childNode.data.path = fd;

                    currentNode.items.push(childNode);
                }
            }

            return currentNode;
        },
        /**
         * Launch collected tests. Initialises session variables, that are specific for the current launch.
         * @private
         */
        __launchTests: function() {
            this.__consoleLog("Launching tests ...");
            this.session.testCount = this.testList.length;
            this.session.processedTestCount = 0;
            this.session.workers.running = 0;
            this.session.workers.terminated = 0;

            if(this.session.testCount > 0) {
                this.__scheduleWork();
            } else {
                this.__doTestReports();
            }
        },
        /**
         * Schedules work based on the MAX available workers, and based on the number of runs of a test.
         * If a test has multiple runs as a option, it will be started in multiple workers. Once all runs are completed,
         * the test is considered as processed.
         * @private
         */
        __scheduleWork: function() {
            while(this.session.workers.running < MAX_WORKERS && this.session.currentTestIndex < this.session.testCount){
                let test = this.testList[this.session.currentTestIndex];
                if(test.result.runs < test.__meta.conf.runs) {
                    test.result.runs++;
                    this.__launchTest(test);
                } else {
                    this.session.currentTestIndex++;
                }
            }
        },
        /**
         * Launch a test into a separate worker (child process).
         * Each worker has handlers for message, exit and error events. Once the exit or error event is invoked,
         * new work is scheduled and session object is updated.
         * Notes: On debug mode, the workers will receive a debug port, that is increased incrementally.
         * @param test {Object} - test object
         * @private
         */
        __launchTest: function(test) {
            this.session.workers.running++;

            test.result.state = TEST_STATES.RUNNING;
            test.result.pass = true;
            test.result.asserts[test.result.runs] = [];
            test.result.messages[test.result.runs] = [];

            let env = process.env;

            let execArgv = [];
            if(DEBUG) {
                const debugPort = ++defaultSession.debugPort;
                const debugFlag = '--debug=' + debugPort;
                execArgv.push(debugFlag);
            }

            const cwd = test.__meta.parent;

            let worker = forker.fork(test.data.path, [], {'cwd': cwd, 'env': env, 'execArgv': execArgv, stdio: [ 'inherit', "pipe", 'inherit', 'ipc' ], silent:false });

            this.__debugInfo(`Launching test ${test.data.name}, run[${test.result.runs}], on worker pid[${worker.pid}] `+new Date().getTime());

            worker.on("message", onMessageEventHandlerWrapper(test));
            worker.on("exit", onExitEventHandlerWrapper(test));
            worker.on("error", onErrorEventHandlerWrapper(test));

            worker.terminated = false;

            worker.stdout.on('data', function (chunk) {
                let content = new Buffer(chunk).toString('utf8'); //TODO: replace with PSKBUFFER
                if(test.__meta.conf.silent) {
                    this.__consoleLog(content);
                }
            }.bind(this));

            var self = this;
            function onMessageEventHandlerWrapper(test) {
                const currentRun = test.result.runs;
                return function(log) {
                    if(log.type === 'assert'){
                        if(log.message.includes("[Fail")) {
                            test.result.pass = false;
                        }
                        test.result.asserts[currentRun].push(log);
                    } else {
                        test.result.messages[currentRun].push(log);
                    }
                };
            }

            function onExitEventHandlerWrapper(test) {
                return function(code, signal) {
                    clearTimeout(worker.timerVar);
                    self.__debugInfo(`Worker ${worker.pid} - exit event. Code ${code}, signal ${signal} `+new Date().getTime());

                    worker.terminated = true;

                    test.result.state = TEST_STATES.FINISHED;
                    if(code !== null && code!==0 /*&& typeof test.result.pass === 'undefined'*/){
                        test.result.pass = false;
                        test.result.messages[test.result.runs].push( {message: "Process finished with errors!", "Exit code":code, "Signal":signal});
                    }

                    self.session.workers.running--;
                    self.session.workers.terminated++;

                    self.__scheduleWork();
                    self.__checkWorkersStatus();
                };
            }

            // this handler can be triggered when:
            // 1. The process could not be spawned, or
            // 2. The process could not be killed, or
            // 3. Sending a message to the child process failed.
            // IMPORTANT: The 'exit' event may or may not fire after an error has occurred!
            function onErrorEventHandlerWrapper(test) {
                return function(error) {
                    self.__debugInfo(`Worker ${worker.pid} - error event.`, test);
                    self.__debugError(error);

                    self.session.workers.running--;
                    self.session.workers.terminated++;
                };
            }

            // Note: on debug, the timeout is reached before exit event is called
            // when kill is called, the exit event is raised
            worker.timerVar = setTimeout(()=>{
                if(!worker.terminated){
                    this.__consoleLog(`worker pid [${worker.pid}] - timeout event`,new Date().getTime(),  test);

                    if(test.result.state !== TEST_STATES.FINISHED){
                        test.result.pass = false;
                    }
                    worker.kill();
                    test.result.state = TEST_STATES.TIMEOUT;
                }else{
                    console.log("Got something, but don't know what...", test);
                }
            }, test.__meta.conf.timeout);

                self.__debugInfo(`Worker ${worker.pid} - set timeout event at `+new Date().getTime() + " for "+test.__meta.conf.timeout);

        },
        /**
         * Checks if all workers completed their job (finished or have been terminated).
         * If true, then the reporting steps can be started.
         * @private
         */
        __checkWorkersStatus: function() {
            if(this.session.workers.running === 0) {
                this.__doTestReports();
            }
        },
        /**
         * Creates test reports object (JSON) that will be saved in the test report.
         * Filename of the report is using the following pattern: {prefix}-{timestamp}{ext}
         * The file will be saved in config.reports.basePath.
         * @private
         */
        __doTestReports: function() {
            this.__consoleLog("Doing reports ...");
            reportFileStructure.count = this.testList.length;

            // pass/failed tests
            for(let i = 0, len = this.testList.length; i < len; i++) {
                let test = this.testList[i];

                let testPath = this.__toRelativePath(test.data.path);
                let item = {path: testPath};
                if(test.result.pass) {
                    item.reason = this.__getFirstFailReasonPerRun(test);
                    reportFileStructure.passed.items.push(item);
                } else {
                    item.reason = this.__getFirstFailReasonPerRun(test);
                    reportFileStructure.failed.items.push(item);
                }
            }
            reportFileStructure.passed.count = reportFileStructure.passed.items.length;
            reportFileStructure.failed.count = reportFileStructure.failed.items.length;

            // suites (first level of directories)
            for(let i = 0, len = this.testTree.items.length; i < len; i++) {
                let item = this.testTree.items[i];
                if(item.__meta.isDirectory) {
                    let suitePath = this.__toRelativePath(item.data.path);
                    reportFileStructure.suites.items.push(suitePath);
                }
            }
            reportFileStructure.suites.count = reportFileStructure.suites.items.length;

            let numberOfReports = 2;

            let finishReports = (err, res) => {
                if(numberOfReports > 1){
                    numberOfReports -= 1;
                    return;
                }
                if(reportFileStructure.failed.count === 0){
                    this.__consoleLog("\nEverything went well! No failed tests.\n\n");
                }else{
                    this.__consoleLog("\nSome tests failed. Check report files!\n\n");
                }

                this.callback(err, "Done");
            };


            this.__consoleLog(this.config.reports.prefix);
            const fileName = `${this.config.reports.prefix}latest${this.config.reports.ext}`;
            const filePath = path.join(this.config.reports.basePath, fileName);
            this.__saveReportToFile(reportFileStructure, filePath, finishReports);

            const timestamp = new Date().getTime().toString();
            const htmlFileName = `${this.config.reports.prefix}latest.html`;
            const htmlFilePath = path.join(this.config.reports.basePath, htmlFileName);
            this.__saveHtmlReportToFile(reportFileStructure, htmlFilePath, timestamp, finishReports);
        },
        /**
         * Saves test reports object (JSON) in the specified path.
         * @param reportFileStructure {Object} - test reports object (JSON)
         * @param destination {String} - path of the file report (the base path MUST exist)
         * @private
         */
        __saveReportToFile: function(reportFileStructure, destination, callback) {

            var content = JSON.stringify(reportFileStructure, null, 4);
            fs.writeFile(destination, content, 'utf8', function (err) {
                if (err) {
                    const message = "An error occurred while writing the report file, with the following error: " + JSON.stringify(err);
                    this.__debugInfo(message);
                    throw err;
                } else{
                    const message = `Finished writing report to ${destination}`;
                    this.__consoleLog(message);
                }
                callback();
            }.bind(this));
        },
        /**
         * Saves test reports as HTML in the specified path.
         * @param reportFileStructure {Object} - test reports object (JSON)
         * @param destination {String} - path of the file report (the base path MUST exist)
         * @param timestamp {String} - timestamp to be injected in html template
         * @private
         */
        __saveHtmlReportToFile: function (reportFileStructure, destination, timestamp, callback) {
            var folderName = path.resolve(__dirname);
            fs.readFile(path.join(folderName,'/utils/reportTemplate.html'), 'utf8', (err, res) => {
                if (err) {
                    const message = 'An error occurred while reading the html report template file, with the following error: ' + JSON.stringify(err);
                    this.__debugInfo(message);
                    throw err;
                }

                fs.writeFile(destination, res + `<script>init(${JSON.stringify(reportFileStructure)}, ${timestamp});</script>`, 'utf8', (err) => {
                    if (err) {
                        const message = 'An error occurred while writing the html report file, with the following error: ' + JSON.stringify(err);
                        this.__debugInfo(message);
                        throw err;
                    }

                    const message = `Finished writing report to ${destination}`;
                    this.__consoleLog(message);

                    callback();
                });
            });
        },
        /**
         * Converts absolute file path to relative path.
         * @param absolutePath {String} - absolute path
         * @returns {string | void | *} - relative path
         * @private
         */
        __toRelativePath: function(absolutePath) {
            const basePath = path.join(this.config.testsDir, "/");
            const relativePath = absolutePath.replace(basePath, "");
            return relativePath;
        },
        /**
         * Checks if a directory is a test dir, by matching its name against config.matchDirs array.
         * @param dir {String} - directory name
         * @returns {boolean} - returns true if there is a match and false otherwise.
         * @private
         */
        __isTestDir: function(dir) {
            if(!this.config || !this.config.matchDirs ) {
                throw `matchDirs is not defined on config ${JSON.stringify(this.config)} does not exist!`;
            }

            var isTestDir = this.config.matchDirs.some(function(item) {
                return dir.toLowerCase().includes(item.toLowerCase());
            });

            return isTestDir;
        },
        /**
         * For a failed test, it returns only the first fail reason per each run.
         * @param test {Object} - test object
         * @returns {Array} - an array of reasons per each test run.
         * @private
         */
        __getFirstFailReasonPerRun: function(test) {
            const reason = [];
            for(let i = 1; i <= test.result.runs; i++) {
                if(test.result.asserts[i] && test.result.asserts[i].length > 0) {
                    addReason(i, test.result.asserts[i][0]);
                }

                if(test.result.messages[i] && test.result.messages[i].length > 0) {
                    addReason(i, test.result.messages[i][0]);
                }

                function addReason(run, log) {
                    const message = {
                        run: run,
                        log: log
                    };

                    reason.push(message);
                }
            }

            return reason;
        },
        /**
         * Described default tree node structure.
         * @returns {{__meta: {conf: null, parent: null, isDirectory: boolean}, data: {name: null, path: null}, result: {state: string, pass: null, executionTime: number, runs: number, asserts: {}, messages: {}}, items: null}}
         * @private
         */
        __getDefaultNodeStructure: function() {
            return  {
                __meta: {
                    conf: null,
                    parent: null,
                    isDirectory: false
                },
                data: {
                    name: null,
                    path: null,
                },
                result: {
                    state: TEST_STATES.READY, // ready | running | terminated | timeout
                    pass: null,
                    executionTime: 0,
                    runs: 0,
                    asserts: {},
                    messages: {}
                },
                items: null
            };
        },
        /**
         * Match a test file path to a UNIX glob expression array. If its any match returns true, otherwise returns false.
         * @param globExpArray {Array} - an array with glob expression (UNIX style)
         * @param str {String} - the string to be matched
         * @returns {boolean} - returns true if there is any match and false otherwise.
         * @private
         */
        __isAnyMatch: function(globExpArray, str) {
            const hasMatch = function(globExp) {
                const regex = globToRegExp(globExp);
                return regex.test(str);
            };

            return globExpArray.some(hasMatch);
        },
        /**
         * Converts a tree structure into an array list of test nodes. The tree traversal is DFS (Deep-First-Search).
         * @param rootNode {Object} - root node of the test tree.
         * @returns {Array} - List of test nodes.
         * @private
         */
        __toTestTreeToList: function(rootNode) {
            var testList = [];

            traverse(rootNode);

            function traverse(node) {
                if(!node.__meta.isDirectory || !node.items) {
                    return;
                }

                for(let i = 0, len = node.items.length; i < len; i++) {
                    const item = node.items[i];
                    if(item.__meta.isDirectory) {
                        traverse(item);
                    } else {
                        testList.push(item);
                    }
                }
            }

            return testList;
        },
        /**
         * Logging to console wrapper.
         * @param log {String|Object|Number} - log message
         * @private
         */
        __consoleLog: function(log) {
            console.log(TAG, log);
        },
        /**
         * Logging debugging info messages wrapper.
         * Logger: console.info
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debugInfo: function(log) {
            this.__debug(console.info, log);
        },
        /**
         * Logging debugging error messages wrapper.
         * Logger: console.error
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debugError: function(log) {
            this.__debug(console.error, log);
        },
        /**
         *  Logging debugging messages wrapper. One debug mode, the logging is silent.
         * @param logger {Function} - handler for logging
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debug: function(logger, log) {
            if(!DEBUG) {return;}

            // let prettyLog = JSON.stringify(log, null, 2);
            logger("DEBUG", log);
        },
        /**
         * Deep extend one object with properties of another object.
         * If the property exists in both objects the property from the first object is overridden.
         * @param first {Object} - the first object
         * @param second {Object} - the second object
         * @returns {Object} - an object with both properties from the first and second object.
         * @private
         */
        __extend: function (first, second) {
            for (const key in second) {
                if (!first.hasOwnProperty(key)) {
                    first[key] = second[key];
                } else {
                    let val = second[key];
                    if(typeof first[key] === 'object') {
                        val = this.__extend(first[key], second[key]);
                    }

                    first[key] = val;
                }
            }

            return first;
        }
    };
};

}).call(this,require("buffer").Buffer,"/modules/double-check/lib")

},{"./utils/glob-to-regexp":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\utils\\glob-to-regexp.js","buffer":"buffer","child_process":false,"fs":false,"path":"path"}],"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\utils\\glob-to-regexp.js":[function(require,module,exports){

// globToRegExp turns a UNIX glob expression into a RegEx expression.
//  Supports all simple glob patterns. Examples: *.ext, /foo/*, ../../path, ^foo.*
// - single character matching, matching ranges of characters etc. group matching are no supported
// - flags are not supported
var globToRegExp = function (globExp) {
    if (typeof globExp !== 'string') {
        throw new TypeError('Glob Expression must be a string!');
    }

    var regExp = "";

    for (let i = 0, len = globExp.length; i < len; i++) {
        let c = globExp[i];

        switch (c) {
            case "/":
            case "$":
            case "^":
            case "+":
            case ".":
            case "(":
            case ")":
            case "=":
            case "!":
            case "|":
                regExp += "\\" + c;
                break;

            case "*":
                // treat any number of "*" as one
                while(globExp[i + 1] === "*") {
                    i++;
                }
                regExp += ".*";
                break;

            default:
                regExp += c;
        }
    }

    // set the regular expression with ^ & $
    regExp = "^" + regExp + "$";

    return new RegExp(regExp);
};

module.exports = globToRegExp;
},{}],"C:\\Users\\Public\\privatesky\\modules\\foldermq\\lib\\folderMQ.js":[function(require,module,exports){
const utils = require("swarmutils");
const OwM = utils.OwM;
var beesHealer = utils.beesHealer;
var fs = require("fs");
var path = require("path");


//TODO: prevent a class of race condition type of errors by signaling with files metadata to the watcher when it is safe to consume

function FolderMQ(folder, callback = () => {}){

	if(typeof callback !== "function"){
		throw new Error("Second parameter should be a callback function");
	}

	folder = path.normalize(folder);

	fs.mkdir(folder, {recursive: true}, function(err, res){
		fs.exists(folder, function(exists) {
			if (exists) {
				return callback(null, folder);
			} else {
				return callback(err);
			}
		});
	});

	function mkFileName(swarmRaw){
		let meta = OwM.prototype.getMetaFrom(swarmRaw);
		let name = `${folder}${path.sep}${meta.swarmId}.${meta.swarmTypeName}`;
		const unique = meta.phaseId || $$.uidGenerator.safe_uuid();

		name = name+`.${unique}`;
		return path.normalize(name);
	}

	this.getHandler = function(){
		if(producer){
			throw new Error("Only one consumer is allowed!");
		}
		producer = true;
		return {
			sendSwarmSerialization: function(serialization, callback){
				if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}
				writeFile(mkFileName(JSON.parse(serialization)), serialization, callback);
			},
			addStream : function(stream, callback){
				if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				if(!stream || !stream.pipe || typeof stream.pipe !== "function"){
					return callback(new Error("Something wrong happened"));
				}

				let swarm = "";
				stream.on('data', (chunk) =>{
					swarm += chunk;
				});

				stream.on("end", () => {
					writeFile(mkFileName(JSON.parse(swarm)), swarm, callback);
				});

				stream.on("error", (err) =>{
					callback(err);
				});
			},
			addSwarm : function(swarm, callback){
				if(!callback){
					callback = $$.defaultErrorHandlingImplementation;
				}else if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				beesHealer.asJSON(swarm,null, null, function(err, res){
					if (err) {
						console.log(err);
					}
					writeFile(mkFileName(res), J(res), callback);
				});
			},
			sendSwarmForExecution: function(swarm, callback){
				if(!callback){
					callback = $$.defaultErrorHandlingImplementation;
				}else if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				beesHealer.asJSON(swarm, OwM.prototype.getMetaFrom(swarm, "phaseName"), OwM.prototype.getMetaFrom(swarm, "args"), function(err, res){
					if (err) {
						console.log(err);
					}
					var file = mkFileName(res);
					var content = JSON.stringify(res);

					//if there are no more FD's for files to be written we retry.
					function wrapper(error, result){
						if(error){
							console.log(`Caught an write error. Retry to write file [${file}]`);
							setTimeout(()=>{
								writeFile(file, content, wrapper);
							}, 10);
						}else{
							return callback(error, result);
						}
					}

					writeFile(file, content, wrapper);
				});
			}
		};
	};

	var recipient;
	this.setIPCChannel = function(processChannel){
		if(processChannel && !processChannel.send || (typeof processChannel.send) != "function"){
			throw new Error("Recipient is not instance of process/child_process or it was not spawned with IPC channel!");
		}
		recipient = processChannel;
		if(consumer){
			console.log(`Channel updated`);
			(recipient || process).on("message", receiveEnvelope);
		}
	};


	var consumedMessages = {};

	function checkIfConsummed(name, message){
		const shortName = path.basename(name);
		const previousSaved = consumedMessages[shortName];
		let result = false;
		if(previousSaved && !previousSaved.localeCompare(message)){
			result = true;
		}
		return result;
	}

	function save2History(envelope){
		consumedMessages[path.basename(envelope.name)] = envelope.message;
	}

	function buildEnvelopeConfirmation(envelope, saveHistory){
		if(saveHistory){
			save2History(envelope);
		}
		return `Confirm envelope ${envelope.timestamp} sent to ${envelope.dest}`;
	}

	function buildEnvelope(name, message){
		return {
			dest: folder,
			src: process.pid,
			timestamp: new Date().getTime(),
			message: message,
			name: name
		};
	}

	function receiveEnvelope(envelope){
		if(!envelope || typeof envelope !== "object"){
			return;
		}
		//console.log("received envelope", envelope, folder);

		if(envelope.dest !== folder && folder.indexOf(envelope.dest)!== -1 && folder.length === envelope.dest+1){
			console.log("This envelope is not for me!");
			return;
		}

		let message = envelope.message;

		if(callback){
			//console.log("Sending confirmation", process.pid);
			recipient.send(buildEnvelopeConfirmation(envelope, true));
			consumer(null, JSON.parse(message));
		}
	}

	this.registerAsIPCConsumer = function(callback){
		if(typeof callback !== "function"){
			throw new Error("The argument should be a callback function");
		}
		registeredAsIPCConsumer = true;
		//will register as normal consumer in order to consume all existing messages but without setting the watcher
		this.registerConsumer(callback, true, (watcher) => !watcher);

		//console.log("Registered as IPC Consummer", );
		(recipient || process).on("message", receiveEnvelope);
	};

	this.registerConsumer = function (callback, shouldDeleteAfterRead = true, shouldWaitForMore = (watcher) => true) {
		if(typeof callback !== "function"){
			throw new Error("First parameter should be a callback function");
		}
		if (consumer) {
			throw new Error("Only one consumer is allowed! " + folder);
		}

		consumer = callback;

		fs.mkdir(folder, {recursive: true}, function (err, res) {
			if (err && (err.code !== 'EEXIST')) {
				console.log(err);
			}
			consumeAllExisting(shouldDeleteAfterRead, shouldWaitForMore);
		});
	};

	this.writeMessage = writeFile;

	this.unlinkContent = function (messageId, callback) {
		const messagePath = path.join(folder, messageId);

		fs.unlink(messagePath, (err) => {
			callback(err);
		});
	};

	this.dispose = function(force){
		if(typeof folder != "undefined"){
			var files;
			try{
				files = fs.readdirSync(folder);
			}catch(error){
				//..
			}

			if(files && files.length > 0 && !force){
				console.log("Disposing a channel that still has messages! Dir will not be removed!");
				return false;
			}else{
				try{
					fs.rmdirSync(folder);
				}catch(err){
					//..
				}
			}

			folder = null;
		}

		if(producer){
			//no need to do anything else
		}

		if(typeof consumer != "undefined"){
			consumer = () => {};
		}

		if(watcher){
			watcher.close();
			watcher = null;
		}

		return true;
	};


	/* ---------------- protected  functions */
	var consumer = null;
	var registeredAsIPCConsumer = false;
	var producer = null;

	function buildPathForFile(filename){
		return path.normalize(path.join(folder, filename));
	}

	function consumeMessage(filename, shouldDeleteAfterRead, callback) {
		var fullPath = buildPathForFile(filename);

		fs.readFile(fullPath, "utf8", function (err, data) {
			if (!err) {
				if (data !== "") {
					try {
						var message = JSON.parse(data);
					} catch (error) {
						console.log("Parsing error", error);
						err = error;
					}

					if(checkIfConsummed(fullPath, data)){
						//console.log(`message already consumed [${filename}]`);
						return ;
					}

					if (shouldDeleteAfterRead) {

						fs.unlink(fullPath, function (err, res) {
							if (err) {throw err;};
						});

					}
					return callback(err, message);
				}
			} else {
				console.log("Consume error", err);
				return callback(err);
			}
		});
	}

	function consumeAllExisting(shouldDeleteAfterRead, shouldWaitForMore) {

		let currentFiles = [];

		fs.readdir(folder, 'utf8', function (err, files) {
			if (err) {
				$$.errorHandler.error(err);
				return;
			}
			currentFiles = files;
			iterateAndConsume(files);

		});

		function startWatching(){
			if (shouldWaitForMore(true)) {
				watchFolder(shouldDeleteAfterRead, shouldWaitForMore);
			}
		}

		function iterateAndConsume(files, currentIndex = 0) {
			if (currentIndex === files.length) {
				//console.log("start watching", new Date().getTime());
				startWatching();
				return;
			}

			if (path.extname(files[currentIndex]) !== in_progress) {
				consumeMessage(files[currentIndex], shouldDeleteAfterRead, (err, data) => {
					if (err) {
						iterateAndConsume(files, ++currentIndex);
						return;
					}
					consumer(null, data, path.basename(files[currentIndex]));
					if (shouldWaitForMore()) {
						iterateAndConsume(files, ++currentIndex);
					}
				});
			} else {
				iterateAndConsume(files, ++currentIndex);
			}
		}
	}

	function writeFile(filename, content, callback){
		if(recipient){
			var envelope = buildEnvelope(filename, content);
			//console.log("Sending to", recipient.pid, recipient.ppid, "envelope", envelope);
			recipient.send(envelope);
			var confirmationReceived = false;

			function receiveConfirmation(message){
				if(message === buildEnvelopeConfirmation(envelope)){
					//console.log("Received confirmation", recipient.pid);
					confirmationReceived = true;
					try{
						recipient.off("message", receiveConfirmation);
					}catch(err){
						//...
					}

				}
			}

			recipient.on("message", receiveConfirmation);

			setTimeout(()=>{
				if(!confirmationReceived){
					//console.log("No confirmation...", process.pid);
					hidden_writeFile(filename, content, callback);
				}else{
					if(callback){
						return callback(null, content);
					}
				}
			}, 200);
		}else{
			hidden_writeFile(filename, content, callback);
		}
	}

	const in_progress = ".in_progress";
	function hidden_writeFile(filename, content, callback){
		var tmpFilename = filename+in_progress;
		try{
			if(fs.existsSync(tmpFilename) || fs.existsSync(filename)){
				console.log(new Error(`Overwriting file ${filename}`));
			}
			fs.writeFileSync(tmpFilename, content);
			fs.renameSync(tmpFilename, filename);
		}catch(err){
			return callback(err);
		}
		callback(null, content);
	}

	var alreadyKnownChanges = {};

	function alreadyFiredChanges(filename, change){
		var res = false;
		if(alreadyKnownChanges[filename]){
			res = true;
		}else{
			alreadyKnownChanges[filename] = change;
		}

		return res;
	}

	function watchFolder(shouldDeleteAfterRead, shouldWaitForMore){

		setTimeout(function(){
			fs.readdir(folder, 'utf8', function (err, files) {
				if (err) {
					$$.errorHandler.error(err);
					return;
				}

				for(var i=0; i<files.length; i++){
					watchFilesHandler("change", files[i]);
				}
			});
		}, 1000);

		function watchFilesHandler(eventType, filename){
			//console.log(`Got ${eventType} on ${filename}`);

			if(!filename || path.extname(filename) === in_progress){
				//caught a delete event of a file
				//or
				//file not ready to be consumed (in progress)
				return;
			}

			var f = buildPathForFile(filename);
			if(!fs.existsSync(f)){
				//console.log("File not found", f);
				return;
			}

			//console.log(`Preparing to consume ${filename}`);
			if(!alreadyFiredChanges(filename, eventType)){
				consumeMessage(filename, shouldDeleteAfterRead, (err, data) => {
					//allow a read a the file
					alreadyKnownChanges[filename] = undefined;

					if (err) {
						// ??
						console.log("\nCaught an error", err);
						return;
					}

					consumer(null, data, filename);


					if (!shouldWaitForMore()) {
						watcher.close();
					}
				});
			}else{
				console.log("Something happens...", filename);
			}
		}


		const watcher = fs.watch(folder, watchFilesHandler);

		const intervalTimer = setInterval(()=>{
			fs.readdir(folder, 'utf8', function (err, files) {
				if (err) {
					$$.errorHandler.error(err);
					return;
				}

				if(files.length > 0){
					console.log(`\n\nFound ${files.length} files not consumed yet in ${folder}`, new Date().getTime(),"\n\n");
					//faking a rename event trigger
					watchFilesHandler("rename", files[0]);
				}
			});
		}, 5000);
	}
}

exports.getFolderQueue = function(folder, callback){
	return new FolderMQ(folder, callback);
};

},{"fs":false,"path":"path","swarmutils":"swarmutils"}],"C:\\Users\\Public\\privatesky\\modules\\pskbuffer\\lib\\PSKBuffer.js":[function(require,module,exports){
function PSKBuffer() {}

function getArrayBufferInterface () {
    if(typeof SharedArrayBuffer === 'undefined') {
        return ArrayBuffer;
    } else {
        return SharedArrayBuffer;
    }
}

PSKBuffer.from = function (source) {
    const ArrayBufferInterface = getArrayBufferInterface();

    const buffer = new Uint8Array(new ArrayBufferInterface(source.length));
    buffer.set(source, 0);

    return buffer;
};

PSKBuffer.concat = function ([ ...params ], totalLength) {
    const ArrayBufferInterface = getArrayBufferInterface();

    if (!totalLength && totalLength !== 0) {
        totalLength = 0;
        for (const buffer of params) {
            totalLength += buffer.length;
        }
    }

    const buffer = new Uint8Array(new ArrayBufferInterface(totalLength));
    let offset = 0;

    for (const buf of params) {
        const len = buf.length;

        const nextOffset = offset + len;
        if (nextOffset > totalLength) {
            const remainingSpace = totalLength - offset;
            for (let i = 0; i < remainingSpace; ++i) {
                buffer[offset + i] = buf[i];
            }
        } else {
            buffer.set(buf, offset);
        }

        offset = nextOffset;
    }

    return buffer;
};

PSKBuffer.isBuffer = function (pskBuffer) {
    return !!ArrayBuffer.isView(pskBuffer);
};

PSKBuffer.alloc = function(size) {
    const ArrayBufferInterface = getArrayBufferInterface();

    return new Uint8Array(new ArrayBufferInterface(size));
};

module.exports = PSKBuffer;
},{}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\ECDSA.js":[function(require,module,exports){
const crypto = require('crypto');
const KeyEncoder = require('./keyEncoder');

function ECDSA(curveName){
    this.curve = curveName || 'secp256k1';
    const self = this;

    this.generateKeyPair = function() {
        const result     = {};
        const ec         = crypto.createECDH(self.curve);
        result.public  = ec.generateKeys('hex');
        result.private = ec.getPrivateKey('hex');
        return keysToPEM(result);
    };

    function keysToPEM(keys){
        const result                  = {};
        const ECPrivateKeyASN         = KeyEncoder.ECPrivateKeyASN;
        const SubjectPublicKeyInfoASN = KeyEncoder.SubjectPublicKeyInfoASN;
        const keyEncoder              = new KeyEncoder(self.curve);

        const privateKeyObject        = keyEncoder.privateKeyObject(keys.private,keys.public);
        const publicKeyObject         = keyEncoder.publicKeyObject(keys.public);

        result.private              = ECPrivateKeyASN.encode(privateKeyObject, 'pem', privateKeyObject.pemOptions);
        result.public               = SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', publicKeyObject.pemOptions);

        return result;

    }

    this.sign = function (privateKey,digest) {
        const sign = crypto.createSign("sha256");
        sign.update(digest);

        return sign.sign(privateKey,'hex');
    };

    this.verify = function (publicKey,signature,digest) {
        const verify = crypto.createVerify('sha256');
        verify.update(digest);

        return verify.verify(publicKey,signature,'hex');
    }
}

exports.createECDSA = function (curve){
    return new ECDSA(curve);
};
},{"./keyEncoder":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\keyEncoder.js","crypto":"crypto"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\PskCrypto.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const os = require('os');

const utils = require("./utils/cryptoUtils");

const PassThroughStream = require('./utils/PassThroughStream');

const EventEmitter = require('events');
const tempFolder = os.tmpdir();

function PskCrypto() {

    const self = this;

    const event = new EventEmitter();

    this.on = event.on;
    this.off = event.removeListener;
    this.removeAllListeners = event.removeAllListeners;
    this.emit = event.emit;

    /*--------------------------------------------- ECDSA functions ------------------------------------------*/
    const ecdsa = require("./ECDSA").createECDSA();
    this.generateECDSAKeyPair = function () {
        return ecdsa.generateKeyPair();
    };

    this.sign = function (privateKey, digest) {
        return ecdsa.sign(privateKey, digest);
    };

    this.verify = function (publicKey, signature, digest) {
        return ecdsa.verify(publicKey, signature, digest);
    };

    /*---------------------------------------------Encryption functions -------------------------------------*/

    this.encryptStream = function (inputPath, destinationPath, password, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        archiver.on('progress', (progress) => {
            self.emit('progress', progress);
        });

        fs.open(destinationPath, "wx", function (err, fd) {
            if (err) {
                callback(err);
                return;
            }

            fs.close(fd, function (err) {
                if (err) {
                    return callback(err);
                }

                const ws = fs.createWriteStream(destinationPath, {autoClose: false});
                const keySalt = crypto.randomBytes(32);
                const key = crypto.pbkdf2Sync(password, keySalt, utils.iterations_number, 32, 'sha512');

                const aadSalt = crypto.randomBytes(32);
                const aad = crypto.pbkdf2Sync(password, aadSalt, utils.iterations_number, 32, 'sha512');

                const salt = Buffer.concat([keySalt, aadSalt]);
                const iv = crypto.pbkdf2Sync(password, salt, utils.iterations_number, 12, 'sha512');

                const cipher = crypto.createCipheriv(utils.algorithm, key, iv);
                cipher.setAAD(aad);
                archiver.zipStream(inputPath, cipher, function (err, cipherStream) {

                    if (err) {
                        return callback(err);
                    }

                    cipherStream.on("data", function (chunk) {
                        ws.write(chunk);
                    });
                    cipherStream.on('end', function () {
                        const tag = cipher.getAuthTag();
                        const dataToAppend = Buffer.concat([salt, tag]);
                        ws.end(dataToAppend, function (err) {
                            if (err) {
                                return callback(err);
                            }

                            callback();
                        })
                    });
                });
            });
        });
    };

    this.decryptStream = function (encryptedInputPath, outputFolder, password, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        decryptFile(encryptedInputPath, tempFolder, password, function (err, tempArchivePath) {
            if (err) {
                return callback(err);
            }

            archiver.on('progress', (progress) => {
                self.emit('progress', 10 + 0.9 * progress);
            });


            archiver.unzipStream(tempArchivePath, outputFolder, function (err, unzippedFileNames) {
                if (err) {
                    return callback(err);
                }

                utils.deleteRecursively(tempArchivePath, function (err) {
                    if (err) {
                        return callback(err);
                    }

                    callback(undefined, unzippedFileNames);
                });

            });
        })
    };

    this.encryptObject = function (inputObj, dseed, depth, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        archiver.zipInMemory(inputObj, depth, function (err, zippedObj) {
            if (err) {
                return callback(err);
            }
            const cipherText = utils.encrypt(zippedObj, dseed);
            callback(null, cipherText);
        })
    };

    this.decryptObject = function (encryptedData, dseed, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        const zippedObject = utils.decrypt(encryptedData, dseed);
        archiver.unzipInMemory(zippedObject, function (err, obj) {
            if (err) {
                return callback(err);
            }
            callback(null, obj);
        })
    };

    this.pskHash = function (data) {
        if (Buffer.isBuffer(data)) {
            return utils.createPskHash(data);
        }
        if (data instanceof Object) {
            return utils.createPskHash(JSON.stringify(data));
        }
        return utils.createPskHash(data);
    };

    this.pskHashStream = function (readStream, callback) {
        const pskHash = new utils.PskHash();

        readStream.on('data', (chunk) => {
            pskHash.update(chunk);
        });


        readStream.on('end', () => {
            callback(null, pskHash.digest());
        })
    };


    this.saveData = function (data, password, path, callback) {
        const encryptionKey = this.deriveKey(password, null, null);
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv('aes-256-cfb', encryptionKey, iv);
        let encryptedDSeed = cipher.update(data, 'binary');
        const final = Buffer.from(cipher.final('binary'), 'binary');
        encryptedDSeed = Buffer.concat([iv, encryptedDSeed, final]);
        fs.writeFile(path, encryptedDSeed, function (err) {
            callback(err);
        });
    };


    this.loadData = function (password, path, callback) {

        fs.readFile(path, null, (err, encryptedData) => {
            if (err) {
                callback(err);
            } else {
                const iv = encryptedData.slice(0, 16);
                const encryptedDseed = encryptedData.slice(16);
                const encryptionKey = this.deriveKey(password, null, null);
                const decipher = crypto.createDecipheriv('aes-256-cfb', encryptionKey, iv);
                let dseed = Buffer.from(decipher.update(encryptedDseed, 'binary'), 'binary');
                const final = Buffer.from(decipher.final('binary'), 'binary');
                dseed = Buffer.concat([dseed, final]);
                callback(null, dseed);
            }
        });
    };


    this.generateSafeUid = function (password, additionalData) {
        password = password || Buffer.alloc(0);
        if (!additionalData) {
            additionalData = Buffer.alloc(0);
        }

        if (!Buffer.isBuffer(additionalData)) {
            additionalData = Buffer.from(additionalData);
        }

        return utils.encode(this.pskHash(Buffer.concat([password, additionalData])));
    };

    this.deriveKey = function deriveKey(password, iterations, dkLen) {
        iterations = iterations || 1000;
        dkLen = dkLen || 32;
        const salt = utils.generateSalt(password, 32);
        const dk = crypto.pbkdf2Sync(password, salt, iterations, dkLen, 'sha512');
        return Buffer.from(dk);
    };

    this.randomBytes = crypto.randomBytes;
    this.PskHash = utils.PskHash;

    //-------------------------- Internal functions -----------------------------------
    function decryptFile(encryptedInputPath, tempFolder, password, callback) {
        fs.stat(encryptedInputPath, function (err, stats) {
            if (err) {
                return callback(err, null);
            }

            const fileSizeInBytes = stats.size;

            fs.open(encryptedInputPath, "r", function (err, fd) {
                if (err) {
                    callback(err, null);
                } else {
                    const encryptedAuthData = Buffer.alloc(80);

                    fs.read(fd, encryptedAuthData, 0, 80, fileSizeInBytes - 80, function (err, bytesRead) {
                        const salt = encryptedAuthData.slice(0, 64);
                        const keySalt = salt.slice(0, 32);
                        const aadSalt = salt.slice(-32);

                        const iv = crypto.pbkdf2Sync(password, salt, utils.iterations_number, 12, 'sha512');
                        const key = crypto.pbkdf2Sync(password, keySalt, utils.iterations_number, 32, 'sha512');
                        const aad = crypto.pbkdf2Sync(password, aadSalt, utils.iterations_number, 32, 'sha512');
                        const tag = encryptedAuthData.slice(-16);

                        const decipher = crypto.createDecipheriv(utils.algorithm, key, iv);

                        decipher.setAAD(aad);
                        decipher.setAuthTag(tag);
                        const rs = fs.createReadStream(encryptedInputPath, {start: 0, end: fileSizeInBytes - 81});
                        fs.mkdir(tempFolder, {recursive: true}, function (err) {

                            if (err) {
                                return callback(err);
                            }
                            const tempArchivePath = path.join(tempFolder, path.basename(encryptedInputPath) + ".zip");

                            fs.open(tempArchivePath, "w", function (err, fd) {
                                if (err) {
                                    callback(err);
                                    return;
                                }

                                fs.close(fd, function (err) {

                                    if (err) {
                                        return callback(err);
                                    }

                                    const ptStream = new PassThroughStream();

                                    const ws = fs.createWriteStream(tempArchivePath, {autoClose: false});
                                    ws.on("finish", function () {
                                        callback(null, tempArchivePath);
                                    });


                                    let progressLength = 0;
                                    let totalLength = 0;

                                    /**
                                     * TODO review this
                                     * In browser, piping will block the event loop and the stack queue is not called.
                                     */
                                    rs.on("data", (chunk) => {
                                        progressLength += chunk.length;
                                        totalLength += chunk.length;

                                        if (progressLength > 300000) {
                                            progressLength = 0;
                                            emitProgress(fileSizeInBytes, totalLength)
                                        }
                                    });

                                    rs.pipe(decipher).pipe(ptStream).pipe(ws);

                                });
                            });
                        });

                    });

                }
            });
        });
    }

    function emitProgress(total, processed) {


        if (processed > total) {
            processed = total;
        }

        const progress = (100 * processed) / total;
        self.emit('progress', parseInt(progress));
    }

}

module.exports = new PskCrypto();

}).call(this,require("buffer").Buffer)

},{"./ECDSA":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\ECDSA.js","./psk-archiver":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\psk-archiver.js","./utils/PassThroughStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\PassThroughStream.js","./utils/cryptoUtils":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\cryptoUtils.js","buffer":"buffer","crypto":"crypto","events":"events","fs":false,"os":"os","path":"path"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\api.js":[function(require,module,exports){
var asn1 = require('./asn1');
var inherits = require('util').inherits;

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","util":"util","vm":false}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js":[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('./bignum/bn');

asn1.define = require('./api').define;
asn1.base = require('./base/index');
asn1.constants = require('./constants/index');
asn1.decoders = require('./decoders/index');
asn1.encoders = require('./encoders/index');

},{"./api":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\api.js","./base/index":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\index.js","./bignum/bn":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\bignum\\bn.js","./constants/index":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\constants\\index.js","./decoders/index":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\index.js","./encoders/index":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\index.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\buffer.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\index.js","buffer":"buffer","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\index.js":[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\buffer.js","./node":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\node.js","./reporter":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\reporter.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\node.js":[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
//var assert = require('double-check').assert;

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  //assert.equal(state.parent,null,'state.parent should be null');
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  // assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    // assert.equal(state.children, null, 'state.children should be null');
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    // assert.equal(state.args, null, 'state.args should be null');
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    // assert.equal(state.tag, null, 'state.tag should be null');
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  // assert.equal(state.use, null, 'state.use should be null');
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  // assert.equal(state['default'], null, "state['default'] should be null");
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  // assert.equal(state.explicit,null, 'state.explicit should be null');
  // assert.equal(state.implicit,null, 'state.implicit should be null');

  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

    // assert.equal(state.explicit,null, 'state.explicit should be null');
    // assert.equal(state.implicit,null, 'state.implicit should be null');

    state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  // assert.equal(state.key, null, 'state.key should be null');
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  // assert.equal(state.choice, null,'state.choice should be null');
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  // assert.equal(state.useDecoder._baseState.parent, null, 'state.useDecoder._baseState.parent should be null');
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  // if (!node) {
  //   assert(
  //       false,
  //       data.type + ' not found in ' +
  //           JSON.stringify(Object.keys(state.choice)));
  // }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\index.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\base\\reporter.js":[function(require,module,exports){
var inherits = require('util').inherits;

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\bignum\\bn.js":[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\constants\\der.js":[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\constants\\index.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\constants\\index.js":[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\constants\\der.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\der.js":[function(require,module,exports){
var inherits = require('util').inherits;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\index.js":[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\der.js","./pem":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\pem.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\pem.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","./der":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\decoders\\der.js","buffer":"buffer","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\der.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr')
    return this._createEncoderBuffer(str);
  else if (tag === 'bitstr')
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._createEncoderBuffer(str);
  return this.reporter.error('Encoding of string type: ' + tag +
                             ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (num.sign === false && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","buffer":"buffer","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\index.js":[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\der.js","./pem":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\pem.js"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\pem.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","./der":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\encoders\\der.js","buffer":"buffer","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\keyEncoder.js":[function(require,module,exports){
(function (Buffer){
'use strict'

var asn1 = require('./asn1/asn1');
var BN = require('./asn1/bignum/bn');

var ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {
    this.seq().obj(
        this.key('version').int(),
        this.key('privateKey').octstr(),
        this.key('parameters').explicit(0).objid().optional(),
        this.key('publicKey').explicit(1).bitstr().optional()
    )
})

var SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function() {
    this.seq().obj(
        this.key('algorithm').seq().obj(
            this.key("id").objid(),
            this.key("curve").objid()
        ),
        this.key('pub').bitstr()
    )
})

var curves = {
    secp256k1: {
        curveParameters: [1, 3, 132, 0, 10],
        privatePEMOptions: {label: 'EC PRIVATE KEY'},
        publicPEMOptions: {label: 'PUBLIC KEY'}
    }
}

function assert(val, msg) {
    if (!val) {
        throw new Error(msg || 'Assertion failed')
    }
}

function KeyEncoder(options) {
    if (typeof options === 'string') {
        assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);
        options = curves[options]
    }
    this.options = options;
    this.algorithmID = [1, 2, 840, 10045, 2, 1]
}

KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;

KeyEncoder.prototype.privateKeyObject = function(rawPrivateKey, rawPublicKey) {
    var privateKeyObject = {
        version: new BN(1),
        privateKey: new Buffer(rawPrivateKey, 'hex'),
        parameters: this.options.curveParameters,
        pemOptions: {label:"EC PRIVATE KEY"}
    };

    if (rawPublicKey) {
        privateKeyObject.publicKey = {
            unused: 0,
            data: new Buffer(rawPublicKey, 'hex')
        }
    }

    return privateKeyObject
};

KeyEncoder.prototype.publicKeyObject = function(rawPublicKey) {
    return {
        algorithm: {
            id: this.algorithmID,
            curve: this.options.curveParameters
        },
        pub: {
            unused: 0,
            data: new Buffer(rawPublicKey, 'hex')
        },
        pemOptions: { label :"PUBLIC KEY"}
    }
}

KeyEncoder.prototype.encodePrivate = function(privateKey, originalFormat, destinationFormat) {
    var privateKeyObject

    /* Parse the incoming private key and convert it to a private key object */
    if (originalFormat === 'raw') {
        if (!typeof privateKey === 'string') {
            throw 'private key must be a string'
        }
        var privateKeyObject = this.options.curve.keyFromPrivate(privateKey, 'hex'),
            rawPublicKey = privateKeyObject.getPublic('hex')
        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey)
    } else if (originalFormat === 'der') {
        if (typeof privateKey === 'buffer') {
            // do nothing
        } else if (typeof privateKey === 'string') {
            privateKey = new Buffer(privateKey, 'hex')
        } else {
            throw 'private key must be a buffer or a string'
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!typeof privateKey === 'string') {
            throw 'private key must be a string'
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions)
    } else {
        throw 'invalid private key format'
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return privateKeyObject.privateKey.toString('hex')
    } else if (destinationFormat === 'der') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex')
    } else if (destinationFormat === 'pem') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions)
    } else {
        throw 'invalid destination format for private key'
    }
}

KeyEncoder.prototype.encodePublic = function(publicKey, originalFormat, destinationFormat) {
    var publicKeyObject

    /* Parse the incoming public key and convert it to a public key object */
    if (originalFormat === 'raw') {
        if (!typeof publicKey === 'string') {
            throw 'public key must be a string'
        }
        publicKeyObject = this.publicKeyObject(publicKey)
    } else if (originalFormat === 'der') {
        if (typeof publicKey === 'buffer') {
            // do nothing
        } else if (typeof publicKey === 'string') {
            publicKey = new Buffer(publicKey, 'hex')
        } else {
            throw 'public key must be a buffer or a string'
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!typeof publicKey === 'string') {
            throw 'public key must be a string'
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions)
    } else {
        throw 'invalid public key format'
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return publicKeyObject.pub.data.toString('hex')
    } else if (destinationFormat === 'der') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex')
    } else if (destinationFormat === 'pem') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions)
    } else {
        throw 'invalid destination format for public key'
    }
}

module.exports = KeyEncoder;
}).call(this,require("buffer").Buffer)

},{"./asn1/asn1":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\asn1.js","./asn1/bignum/bn":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\asn1\\bignum\\bn.js","buffer":"buffer"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\psk-archiver.js":[function(require,module,exports){
(function (Buffer){
const path = require("path");
const yazl = require("yazl");
const yauzl = require("yauzl");
const fs = require("fs");
const DuplexStream = require("./utils/DuplexStream");
const PassThroughStream = require("./utils/PassThroughStream");
const isStream = require("./utils/isStream");

const EventEmitter = require('events');

const countFiles = require('./utils/countFiles');

function PskArchiver() {

    const self = this;

    const event = new EventEmitter();

    this.on = event.on;
    this.off = event.off;
    this.emit = event.emit;

    this.zipStream = function (inputPath, output, callback) {
        let ext = "";
        const zipFile = new yazl.ZipFile();
        const ptStream = new PassThroughStream();

        countFiles.computeSize(inputPath, (err, totalSize) => {
            if (err) {
                return callback(err);
            }

            __addToArchiveRecursively(zipFile, inputPath, "", (err) => {
                if (err) {
                    return callback(err);
                }

                zipFile.end();
                const filename = path.basename(inputPath);
                const splitFilename = filename.split(".");
                if (splitFilename.length >= 2) {
                    ext = "." + splitFilename[splitFilename.length - 1];
                }
                const myStream = zipFile.outputStream.pipe(ptStream);

                let progressLength = 0;
                let totalLength = 0;

                /**
                 * TODO review this
                 * In browser, piping will block the event loop and the stack queue is not called.
                 */
                myStream.on("data", (chunk) => {
                    progressLength += chunk.length;
                    totalLength += chunk.length;

                    if (progressLength > 300000) {
                        myStream.pause();
                        progressLength = 0;
                        setTimeout(function () {
                            myStream.resume();
                        }, 10);
                        emitProgress(totalSize, totalLength)
                    }
                });

                myStream.on('end', () => {
                    emitProgress(totalSize, totalSize);
                    emitTotalSize(totalSize);
                });
                if (isStream.isWritable(output)) {
                    callback(null, myStream.pipe(output));
                } else if (typeof output === "string") {
                   fs.mkdir(output, {recursive: true}, () => {
                        const destinationPath = path.join(output, path.basename(inputPath, ext) + ".zip");
                        myStream.pipe(fs.createWriteStream(destinationPath));
                    });
                }
            });

            function __addToArchiveRecursively(zipFile, inputPath, root = '', callback) {
                root = root || '';
                fs.stat(inputPath, (err, stats) => {
                    if (err) {
                        return callback(err);
                    }
                    if (stats.isFile()) {
                        zipFile.addFile(inputPath, path.join(root, path.basename(inputPath)));
                        callback(null);

                    } else {
                        fs.readdir(inputPath, (err, files) => {
                            if (err) {
                                return callback(err);
                            }
                            const f_length = files.length;
                            let f_add_index = 0;

                            const checkStatus = () => {
                                if (f_length === f_add_index) {
                                    callback(null);
                                    return true;
                                }
                                return false;
                            };

                            if (!checkStatus()) {
                                files.forEach(file => {
                                    const tempPath = path.join(inputPath, file);
                                    __addToArchiveRecursively(zipFile, tempPath, path.join(root, path.basename(inputPath)), (err) => {
                                        if (err) {
                                            return callback(err);
                                        }
                                        f_add_index++;
                                        checkStatus();
                                    })
                                });
                            }
                        })
                    }
                });
            }

        });

    };

    this.unzipStream = function (input, outputPath, callback) {

        let size = 0;

        fs.stat(input, (err, stats) => {
            if (err) {
                return callback(err);
            }

            let totalSize = stats.size;


            yauzl.open(input, {lazyEntries: true}, (err, zipFile) => {
                if (err) {
                    return callback(err);
                }

                let progressLength = 0;
                let totalLength = 0;

                const fileNames = [];
                zipFile.readEntry();
                zipFile.once("end", () => {
                    emitProgress(totalSize, totalSize);
                    callback(null, fileNames);
                });
                zipFile.on("entry", (entry) => {
                    if (entry.fileName.endsWith(path.sep)) {
                        zipFile.readEntry();
                    } else {
                        let folder = path.dirname(entry.fileName);
                        fs.mkdir(path.join(outputPath, folder), {recursive: true}, () => {
                            zipFile.openReadStream(entry, (err, readStream) => {
                                if (err) {
                                    return callback(err);
                                }

                                /**
                                 * TODO review this
                                 * In browser, piping will block the event loop and the stack queue is not called.
                                 */

                                readStream.on("data", (chunk) => {
                                    progressLength += chunk.length;
                                    totalLength += chunk.length;

                                    if (progressLength > 300000) {
                                        readStream.pause();
                                        progressLength = 0;
                                        setTimeout(function () {
                                            readStream.resume();
                                        }, 30);
                                        emitProgress(totalSize, totalLength)
                                    }
                                });


                                readStream.on("end", () => {
                                    zipFile.readEntry();
                                });
                                const ptStream = new PassThroughStream();
                                let fileName = path.join(outputPath, entry.fileName);
                                let folder = path.dirname(fileName);
                                const tempStream = readStream.pipe(ptStream);

                                fs.mkdir(folder, {recursive: true}, (err) => {
                                    if (err) {
                                        return callback(err);
                                    }

                                    size += ptStream.getSize();
                                    let output = fs.createWriteStream(fileName);
                                    fileNames.push(fileName);
                                    tempStream.pipe(output);
                                });
                            });
                        });
                    }
                });
            });

        });

    };

    this.zipInMemory = function (inputObj, depth, callback) {
        const zipFile = new yazl.ZipFile();
        const ds = new DuplexStream();
        zipRecursively(zipFile, inputObj, "", depth, (err) => {
            if (err) {
                return callback(err);
            }
            zipFile.end();
            let buffer = Buffer.alloc(0);
            ds.on('data', (chunk) => {
                buffer = Buffer.concat([buffer, chunk]);
            });

            zipFile.outputStream.pipe(ds).on("finish", (err) => {
                if (err) {
                    return callback(err);
                }
                callback(null, buffer);
            });
        })
    };

    this.unzipInMemory = function (inputZip, callback) {

        function unzipInput(zipFile) {
            zipFile.readEntry();
            const obj = {};
            zipFile.once("end", () => {
                callback(null, obj);
            });

            zipFile.on("entry", (entry) => {
                zipFile.openReadStream(entry, (err, readStream) => {
                    const ds = new DuplexStream();
                    let str = '';
                    if (err) {
                        return callback(err);
                    }
                    readStream.on("end", () => {
                        zipFile.readEntry();
                    });
                    ds.on("data", (chunk) => {
                        str += chunk.toString();
                    });

                    readStream.pipe(ds).on("finish", (err) => {
                        if (err) {
                            return callback(err);
                        }
                        const splitEntry = entry.fileName.split("/");
                        const type = splitEntry.pop();
                        addPropsRecursively(obj, splitEntry, type, new Buffer(str));
                    });

                });
            })
        }

        if (Buffer.isBuffer(inputZip)) {
            yauzl.fromBuffer(inputZip, {lazyEntries: true}, (err, zipFile) => {
                if (err) {
                    return callback(err);
                }
                unzipInput(zipFile)
            });
        } else {
            return callback(new Error("input should be a buffer"));
        }

    };

    function zipRecursively(zipFile, obj, root, depth, callback) {
        if (depth === 0) {
            zipFile.addBuffer(new Buffer(JSON.stringify(obj)), root + "/stringify");
            return;
        }

        if (typeof obj === 'undefined') {
            zipFile.addBuffer(Buffer.alloc(0), root + "/undefined");
        } else if (typeof obj === 'number') {
            zipFile.addBuffer(new Buffer(obj.toString()), root + "/number");
        } else if (typeof obj === 'string') {
            zipFile.addBuffer(new Buffer(obj), root + "/string")
        } else if (obj === null) {
            zipFile.addBuffer(Buffer.alloc(0), root + "/null");
        } else if (Buffer.isBuffer(obj)) {
            zipFile.addBuffer(obj, root + "/buffer");
        } else if (isStream.isReadable(obj)) {
            zipFile.addReadStream(obj, root + "/stream");
        } else if (Array.isArray(obj)) {
            for (let i = 0; i < obj.length; i++) {
                if (obj.length === 0) {
                    zipFile.addBuffer(Buffer.alloc(0), root + "/array")
                } else {
                    zipRecursively(zipFile, obj[i], root + "/array/" + i, depth, (err) => {
                        if (err) {
                            return callback(err);
                        }
                    });
                }
            }
        } else if (obj && typeof obj === 'object') {
            let keys = Object.keys(obj);
            if (keys.length === 0 && obj.constructor === Object) {
                zipFile.addBuffer(Buffer.alloc(0), root + "/object");
            } else {
                const encodedObj = {};
                Object.entries(obj).forEach(([key, value]) => {
                    encodedObj[encodeURIComponent(key)] = value;
                });
                obj = encodedObj;
                keys = Object.keys(obj);
                keys.forEach(key => {
                    let entryName;
                    if (root === "") {
                        entryName = key;
                    } else {
                        entryName = root + "/" + key;
                    }
                    zipRecursively(zipFile, obj[key], entryName, depth - 1, (err) => {
                        if (err) {
                            return callback(err);
                        }
                    });
                });
            }
        } else {
            throw new Error('Should never reach this');
        }
        callback(null);
    }

    function addPropsRecursively(obj, splitName, type, data) {
        if (splitName.length >= 1) {
            const prop = decodeURIComponent(splitName.shift());

            if (splitName.length === 0) {
                switch (type) {
                    case 'undefined':
                        obj[prop] = undefined;
                        break;
                    case 'null':
                        obj[prop] = null;
                        break;
                    case 'number':
                        obj[prop] = parseInt(data.toString());
                        break;
                    case 'string':
                        obj[prop] = data.toString();
                        break;
                    case 'stream':
                        obj[prop] = bufferToStream(data);
                        break;
                    case 'array':
                        obj[prop] = [];
                        break;
                    case 'object':
                        obj[prop] = {};
                        break;
                    case 'stringify':
                        obj[prop] = JSON.parse(data.toString());
                        break;
                    default:
                        throw new Error('Should never reach this');
                }
            } else {
                if (splitName[0] === 'array') {
                    if (!obj.hasOwnProperty(prop)) {
                        obj[prop] = [];
                    }
                    splitName.shift();
                    addPropsRecursively(obj[prop], splitName, type, data);
                } else {
                    if (!obj.hasOwnProperty(prop)) {
                        obj[prop] = {};
                    }
                    addPropsRecursively(obj[prop], splitName, type, data);
                }
            }
        }
    }


    function bufferToStream(buffer) {
        let stream = new require('stream').Readable();
        stream.push(buffer);
        stream.push(null);
        return stream;
    }

    function emitProgress(total, processed) {


        if (processed > total) {
            processed = total;
        }

        const progress = (100 * processed) / total;
        self.emit('progress', progress);
    }

    function emitTotalSize(total) {
        self.emit('total', total);
    }


}

module.exports = PskArchiver;
}).call(this,require("buffer").Buffer)

},{"./utils/DuplexStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\DuplexStream.js","./utils/PassThroughStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\PassThroughStream.js","./utils/countFiles":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\countFiles.js","./utils/isStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\isStream.js","buffer":"buffer","events":"events","fs":false,"path":"path","yauzl":false,"yazl":false}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\DuplexStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const Duplex = stream.Duplex;

function DuplexStream(options) {
	if (!(this instanceof DuplexStream)) {
		return new DuplexStream(options);
	}
	Duplex.call(this, options);
}
util.inherits(DuplexStream, Duplex);

DuplexStream.prototype._write = function (chunk, enc, cb) {
	this.push(chunk);
	cb();
};


DuplexStream.prototype._read = function (n) {

};

module.exports = DuplexStream;
},{"stream":"stream","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\PassThroughStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const PassThrough = stream.PassThrough;

function PassThroughStream(options) {
    if (!(this instanceof PassThroughStream)) {
        return new PassThroughStream(options);
    }
    PassThrough.call(this, options);

    let size = 0;

    this.addToSize = function (amount) {
        size += amount;
    };

    this.getSize = function () {
        return size;
    }
}

util.inherits(PassThroughStream, PassThrough);

PassThroughStream.prototype._write = function (chunk, enc, cb) {
    this.addToSize(chunk.length);
    this.push(chunk);
    cb();
};


PassThroughStream.prototype._read = function (n) {

};

module.exports = PassThroughStream;
},{"stream":"stream","util":"util"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\countFiles.js":[function(require,module,exports){
const fs = require('fs');
const path = require('path');
const yauzl = require('yauzl');

function countFiles(inputPath, callback) {
    let total = 0;

    fs.stat(inputPath, (err, stats) => {
        if (err) {
            return callback(err);
        }

        if (stats.isFile()) {
            return callback(undefined, 1);
        }

        fs.readdir(inputPath, (err, files) => {
            if (err) {
                return callback(err);
            }


            total = files.length;
            let count = files.length;

            if (total === 0) {
                return callback(undefined, 0);
            }

            files.forEach(file => {
                fs.stat(path.join(inputPath, file), (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    if (stats.isDirectory()) {
                        --total;
                        countFiles(path.join(inputPath, file), (err, filesNumber) => {
                            if (err) {
                                return callback(err);
                            }

                            total += filesNumber;


                            if (--count === 0) {
                                callback(undefined, total);
                            }
                        });
                    } else {
                        if (!stats.isFile()) {
                            --total;
                        }

                        if (--count === 0) {
                            callback(undefined, total);
                        }
                    }
                });
            })
        });
    });
}

function countZipEntries(inputPath, callback) {
    let processed = 0;

    yauzl.open(inputPath, {lazyEntries: true}, (err, zipFile) => {
        if (err) {
            return callback(err);
        }

        zipFile.readEntry();
        zipFile.once("end", () => {
            callback(null, processed);
        });

        zipFile.on("entry", (entry) => {
            ++processed;

            zipFile.readEntry();
        });
    });
}

function computeSize(inputPath, callback) {
    let totalSize = 0;
    fs.stat(inputPath, (err, stats) => {
        if (err) {
            return callback(err);
        }

        if (stats.isFile()) {
            return callback(undefined, stats.size);
        }

        fs.readdir(inputPath, (err, files) => {
            if (err) {
                return callback(err);
            }


            let count = files.length;

            if (count === 0) {
                return callback(undefined, 0);
            }

            files.forEach(file => {
                fs.stat(path.join(inputPath, file), (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    if (stats.isDirectory()) {
                        computeSize(path.join(inputPath, file), (err, filesSize) => {
                            if (err) {
                                return callback(err);
                            }

                            totalSize += filesSize;

                            if (--count === 0) {
                                callback(undefined, totalSize);
                            }
                        });
                    } else {

                        totalSize += stats.size;

                        if (--count === 0) {
                            callback(undefined, totalSize);
                        }
                    }
                });
            })
        });
    });
}

module.exports = {
    countFiles,
    countZipEntries,
    computeSize
};

},{"fs":false,"path":"path","yauzl":false}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\cryptoUtils.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const fs = require('fs');
const path = require("path");

const algorithm = 'aes-256-gcm';


const iterations_number = 1000;

function encode(buffer) {
	return buffer.toString('base64')
		.replace(/\+/g, '')
		.replace(/\//g, '')
		.replace(/=+$/, '');
}

function deleteRecursively(inputPath, callback) {

	fs.stat(inputPath, function (err, stats) {
		if (err) {
			callback(err, stats);
			return;
		}
		if (stats.isFile()) {
			fs.unlink(inputPath, function (err) {
				if (err) {
					callback(err, null);
				} else {
					callback(null, true);
				}
			});
		} else if (stats.isDirectory()) {
			fs.readdir(inputPath, function (err, files) {
				if (err) {
					callback(err, null);
					return;
				}
				const f_length = files.length;
				let f_delete_index = 0;

				const checkStatus = function () {
					if (f_length === f_delete_index) {
						fs.rmdir(inputPath, function (err) {
							if (err) {
								callback(err, null);
							} else {
								callback(null, true);
							}
						});
						return true;
					}
					return false;
				};
				if (!checkStatus()) {
					files.forEach(function (file) {
						const tempPath = path.join(inputPath, file);
						deleteRecursively(tempPath, function removeRecursiveCB(err, status) {
							if (!err) {
								f_delete_index++;
								checkStatus();
							} else {
								callback(err, null);
							}
						});
					});
				}
			});
		}
	});
}





function createPskHash(data) {
	const pskHash = new PskHash();
	pskHash.update(data);
	return pskHash.digest();
}

function PskHash() {
	const sha512 = crypto.createHash('sha512');
	const sha256 = crypto.createHash('sha256');

	function update(data) {
		sha512.update(data);
	}

	function digest() {
		sha256.update(sha512.digest());
		return sha256.digest();
	}

	return {
		update,
		digest
	}
}


function generateSalt(inputData, saltLen) {
	const hash = crypto.createHash('sha512');
	hash.update(inputData);
	const digest = Buffer.from(hash.digest('hex'), 'binary');

	return digest.slice(0, saltLen);
}

function encrypt(data, password) {
	const keySalt = crypto.randomBytes(32);
	const key = crypto.pbkdf2Sync(password, keySalt, iterations_number, 32, 'sha512');

	const aadSalt = crypto.randomBytes(32);
	const aad = crypto.pbkdf2Sync(password, aadSalt, iterations_number, 32, 'sha512');

	const salt = Buffer.concat([keySalt, aadSalt]);
	const iv = crypto.pbkdf2Sync(password, salt, iterations_number, 12, 'sha512');

	const cipher = crypto.createCipheriv(algorithm, key, iv);
	cipher.setAAD(aad);
	let encryptedText = cipher.update(data, 'binary');
	const final = Buffer.from(cipher.final('binary'), 'binary');
	const tag = cipher.getAuthTag();

	encryptedText = Buffer.concat([encryptedText, final]);

	return Buffer.concat([salt, encryptedText, tag]);
}

function decrypt(encryptedData, password) {
	const salt = encryptedData.slice(0, 64);
	const keySalt = salt.slice(0, 32);
	const aadSalt = salt.slice(-32);

	const iv = crypto.pbkdf2Sync(password, salt, iterations_number, 12, 'sha512');
	const key = crypto.pbkdf2Sync(password, keySalt, iterations_number, 32, 'sha512');
	const aad = crypto.pbkdf2Sync(password, aadSalt, iterations_number, 32, 'sha512');

	const ciphertext = encryptedData.slice(64, encryptedData.length - 16);
	const tag = encryptedData.slice(-16);

	const decipher = crypto.createDecipheriv(algorithm, key, iv);
	decipher.setAuthTag(tag);
	decipher.setAAD(aad);

	let plaintext = Buffer.from(decipher.update(ciphertext, 'binary'), 'binary');
	const final = Buffer.from(decipher.final('binary'), 'binary');
	plaintext = Buffer.concat([plaintext, final]);
	return plaintext;
}

function encryptObjectInMemory(inputObj, password, depth, callback) {
	const PskArchiver = require("../psk-archiver");
	const archiver = new PskArchiver();

	archiver.zipInMemory(inputObj, depth, function (err, zippedObj) {
		if (err) {
			return callback(err);
		}
		const cipherText = encrypt(zippedObj, password);
		callback(null, cipherText);
	})
}

function decryptObjectInMemory(encryptedObject, password, callback) {
	const archiver = new PskArchiver();

	const zippedObject = decrypt(encryptedObject, password);
	archiver.unzipInMemory(zippedObject, function (err, obj) {
		if (err) {
			return callback(err);
		}
		callback(null, obj);
	})
}


module.exports = {
	createPskHash,
	encrypt,
	encryptObjectInMemory,
	decrypt,
	decryptObjectInMemory,
	deleteRecursively,
	encode,
	generateSalt,
	iterations_number,
	algorithm,
	PskHash
};


}).call(this,require("buffer").Buffer)

},{"../psk-archiver":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\psk-archiver.js","buffer":"buffer","crypto":"crypto","fs":false,"path":"path"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\isStream.js":[function(require,module,exports){
const stream = require('stream');


function isStream (obj) {
	return obj instanceof stream.Stream || obj instanceof stream.Duplex;
}


function isReadable (obj) {
	return isStream(obj) && typeof obj._read === 'function' && typeof obj._readableState === 'object'
}


function isWritable (obj) {
	return isStream(obj) && typeof obj._write === 'function' && typeof obj._writableState === 'object'
}


function isDuplex (obj) {
	return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream;
module.exports.isReadable = isReadable;
module.exports.isWritable = isWritable;
module.exports.isDuplex   = isDuplex;
},{"stream":"stream"}],"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\signsensusDS\\ssutil.js":[function(require,module,exports){
/*
 SignSens helper functions
 */
const crypto = require('crypto');

exports.wipeOutsidePayload = function wipeOutsidePayload(hashStringHexa, pos, size){
    var result;
    var sz = hashStringHexa.length;

    var end = (pos + size) % sz;

    if(pos < end){
        result = '0'.repeat(pos) +  hashStringHexa.substring(pos, end) + '0'.repeat(sz - end);
    }
    else {
        result = hashStringHexa.substring(0, end) + '0'.repeat(pos - end) + hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.extractPayload = function extractPayload(hashStringHexa, pos, size){
    var result;

    var sz = hashStringHexa.length;
    var end = (pos + size) % sz;

    if( pos < end){
        result = hashStringHexa.substring(pos, pos + size);
    } else{

        if(0 != end){
            result = hashStringHexa.substring(0, end)
        }  else {
            result = "";
        }
        result += hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.fillPayload = function fillPayload(payload, pos, size){
    var sz = 64;
    var result = "";

    var end = (pos + size) % sz;

    if( pos < end){
        result = '0'.repeat(pos) + payload + '0'.repeat(sz - end);
    } else{
        result = payload.substring(0,end);
        result += '0'.repeat(pos - end);
        result += payload.substring(end);
    }
    return result;
}



exports.generatePosHashXTimes = function generatePosHashXTimes(buffer, pos, size, count){ //generate positional hash
    var result  = buffer.toString("hex");

    /*if(pos != -1 )
        result[pos] = 0; */

    for(var i = 0; i < count; i++){
        var hash = crypto.createHash('sha256');
        result = exports.wipeOutsidePayload(result, pos, size);
        hash.update(result);
        result = hash.digest('hex');
    }
    return exports.wipeOutsidePayload(result, pos, size);
}

exports.hashStringArray = function (counter, arr, payloadSize){

    const hash = crypto.createHash('sha256');
    var result = counter.toString(16);

    for(var i = 0 ; i < 64; i++){
        result += exports.extractPayload(arr[i],i, payloadSize);
    }

    hash.update(result);
    var result = hash.digest('hex');
    return result;
}






function dumpMember(obj){
    var type = Array.isArray(obj) ? "array" : typeof obj;
    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    switch(type){
        case "number":
        case "string":return obj.toString(); break;
        case "object": return exports.dumpObjectForHashing(obj); break;
        case "boolean": return  obj? "true": "false"; break;
        case "array":
            var result = "";
            for(var i=0; i < obj.length; i++){
                result += exports.dumpObjectForHashing(obj[i]);
            }
            return result;
            break;
        default:
            throw new Error("Type " +  type + " cannot be cryptographically digested");
    }

}


exports.dumpObjectForHashing = function(obj){
    var result = "";

    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    var basicTypes = {
        "array"     : true,
        "number"    : true,
        "boolean"   : true,
        "string"    : true,
        "object"    : false
    }

    var type = Array.isArray(obj) ? "array" : typeof obj;
    if( basicTypes[type]){
        return dumpMember(obj);
    }

    var keys = Object.keys(obj);
    keys.sort();


    for(var i=0; i < keys.length; i++){
        result += dumpMember(keys[i]);
        result += dumpMember(obj[keys[i]]);
    }

    return result;
}


exports.hashValues  = function (values){
    const hash = crypto.createHash('sha256');
    var result = exports.dumpObjectForHashing(values);
    hash.update(result);
    return hash.digest('hex');
};

exports.getJSONFromSignature = function getJSONFromSignature(signature, size){
    var result = {
        proof:[]
    };
    var a = signature.split(":");
    result.agent        = a[0];
    result.counter      =  parseInt(a[1], "hex");
    result.nextPublic   =  a[2];

    var proof = a[3]


    if(proof.length/size != 64) {
        throw new Error("Invalid signature " + proof);
    }

    for(var i = 0; i < 64; i++){
        result.proof.push(exports.fillPayload(proof.substring(i * size,(i+1) * size ), i, size))
    }

    return result;
}

exports.createSignature = function (agent,counter, nextPublic, arr, size){
    var result = "";

    for(var i = 0; i < arr.length; i++){
        result += exports.extractPayload(arr[i], i , size);
    }

    return agent + ":" + counter + ":" + nextPublic + ":" + result;
}
},{"crypto":"crypto"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\GenericLoggerClient.js":[function(require,module,exports){
const LogFactory = require('./LogFactory');

/**
 *
 * @param {TransportInterface} messagePublisher
 * @constructor
 */
function GenericLoggerClient(messagePublisher) {
    /**
     * This is to be used to send normal logs. They will be published in a subchannel of the "logs" channel.
     * It is easier to trace only user and platform logs if they are separated in this channel
     *
     * @param {{code: Number, name: string}} logLevel
     * @param {Object} meta
     * @param {Array<any>} messages
     *
     * @return {{level, meta, time, msTime, messages}}
     */
    function log(logLevel, meta, messages) {
        const log = LogFactory.createLog(logLevel, meta, messages);

        const logChannel = `logs.${logLevel.name}`;
        messagePublisher.send(logChannel, log);

        return log;
    }


    /**
     * This is to be used for sending custom events when messages don't happen in the normal flow of the platform
     * or they shouldn't interfere with the tracing of logs
     * For example, sending statistics about a node or a sandbox is happening periodically and not as a result of
     * users' running code, therefore this should not be merged with logs
     *
     * @param {string} channel
     * @param {Object} meta
     * @param {Array<any>} messages
     * @return {{meta, messages, time}}
     */
    function event(channel, meta, messages) {
        const event = LogFactory.createEvent(meta, messages);

        const logChannel = `events.${channel}`;
        messagePublisher.send(logChannel, event);

        return event;
    }

    function publish(channel, message) {
        messagePublisher.send(channel, message);

        return message;
    }

    this.event  = event;
    this.log    = log;
    this.publish = publish;
}

module.exports = GenericLoggerClient;

},{"./LogFactory":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LogFactory.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LogFactory.js":[function(require,module,exports){
function getTime() {
    if(process.env.context === 'sandbox') {

        return Date.now()
    } else {
        const {performance} = require('perf_hooks');

        return performance.now() + performance.timeOrigin;
    }
}


function createLog(logLevel, meta, messages) {
    return {
        level: logLevel,
        messages: messages,
        meta: meta,
        time: getTime()
    }
}

function createEvent(meta, messages) {
    return {
        messages,
        meta,
        time: getTime()
    };
}

module.exports = {
    createLog,
    createEvent
};

},{"perf_hooks":false}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LoggerClient.js":[function(require,module,exports){
const GenericLoggerClient = require('./GenericLoggerClient');
const LogLevel = require('../utils/LogLevel');
const LoggerInterface = require('./LoggerInterface');

/**
 *
 * @param {TransportInterface} messagePublisher
 * @implements LoggerInterface
 * @constructor
 */
function LoggerClient(messagePublisher) {
    LoggerInterface.call(this);

    const genericLoggerClient = new GenericLoggerClient(messagePublisher);


    /************* PUBLIC METHODS *************/

    function debug(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.debug);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function error(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.error);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function info(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.info);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function log(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.log);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function warn(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.warn);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function event(channel, meta = {}, ...params) {
        return genericLoggerClient.event(channel, meta, ...params);
    }
    
    function redirect(channel, logObject) {
        return genericLoggerClient.publish(channel, logObject)
    }


    /************* PRIVATE METHODS *************/

    function _getLogLevel(levelCode) {
        return {
            code: levelCode,
            name: LogLevel[levelCode]
        };
    }


    /************* EXPORTS *************/

    this.debug    = debug;
    this.error    = error;
    this.event    = event;
    this.info     = info;
    this.log      = log;
    this.redirect = redirect;
    this.warn     = warn;
}

module.exports = LoggerClient;

},{"../utils/LogLevel":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\LogLevel.js","./GenericLoggerClient":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\GenericLoggerClient.js","./LoggerInterface":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LoggerInterface.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LoggerInterface.js":[function(require,module,exports){
/**
 * @interface
 */
function LoggerInterface() {
    function genericMethod(channel, logObject) {
        throw new Error('Not implemented');
    }

    this.debug    = genericMethod;
    this.error    = genericMethod;
    this.event    = genericMethod;
    this.info     = genericMethod;
    this.log      = genericMethod;
    this.redirect = genericMethod;
    this.warn     = genericMethod;
}

module.exports = LoggerInterface;

},{}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\index.js":[function(require,module,exports){
const GenericLoggerClient = require('./GenericLoggerClient');
const LogFactory          = require('./LogFactory');
const LoggerClient        = require('./LoggerClient');
const LoggerInterface     = require('./LoggerInterface');


module.exports = {
    GenericLoggerClient,
    LogFactory,
    LoggerClient,
    LoggerInterface
};

},{"./GenericLoggerClient":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\GenericLoggerClient.js","./LogFactory":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LogFactory.js","./LoggerClient":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LoggerClient.js","./LoggerInterface":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\LoggerInterface.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\MessagePublisher.js":[function(require,module,exports){
const TransportInterface = require('./TransportInterface');
const utils = require('../utils');
const zeroMQ = require('zeromq');


/**
 * Creates a ZeroMQ Publisher Socket and connects to the specified address for a ZeroMQ Subscriber
 * @param {string!} address - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @implements TransportInterface
 * @constructor
 */
function MessagePublisher(address) {
    TransportInterface.call(this);

    const zmqSocket = zeroMQ.createSocket('pub');

    // uncomment next line if messages are lost
    // zmqSocket.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);
    const socket = new utils.BufferedSocket(zmqSocket, utils.SocketType.connectable);


    /************* PUBLIC METHODS *************/

    /**
     *
     * @param {string} channel
     * @param {Object} logObject
     */
    this.send = function (channel, logObject) {
        try {
            const serializedLog = JSON.stringify(logObject);

            socket.send([channel, serializedLog]);
        } catch (e) {
            process.stderr.write('Error while sending or serializing message');
        }
    };


    /************* MONITOR SOCKET *************/

    zmqSocket.connect(address);
}

module.exports = MessagePublisher;

},{"../utils":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\index.js","./TransportInterface":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\TransportInterface.js","zeromq":false}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\MessagePublisherForSandbox.js":[function(require,module,exports){
(function (global){
const TransportInterface = require('./TransportInterface');

/**
 * This assumes it is executed inside a sandbox and that exists an object "logger" on "global" with a method "send".
 * Sandboxes can't connect directly to ZeroMQ therefore this just relays the message outside the sandbox.
 *
 * @implements TransportInterface
 * @constructor
 */
function MessagePublisherForSandbox() {

    TransportInterface.call(this);

    /************* PUBLIC METHODS *************/

    /**
     *
     * @param {string} channel
     * @param {Object} logObject
     */
    this.send = function (channel, logObject) {
        try {
            global.logger.send([channel, logObject]);
        } catch (e) {
            console.error('Error while sending or serializing message');
        }
    };

}

module.exports = MessagePublisherForSandbox;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TransportInterface":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\TransportInterface.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\TransportInterface.js":[function(require,module,exports){
/**
 *
 * @interface
 */
function TransportInterface() {
    this.send = function (channel, logObject) {
        throw new Error('Not implemented');
    }
}

module.exports = TransportInterface;

},{}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\index.js":[function(require,module,exports){
const TransportInterface = require('./TransportInterface');

module.exports = {
    TransportInterface
};

if(process.env.context === 'sandbox') {
    module.exports.MessagePublisher = require('./MessagePublisherForSandbox');
} else {
    module.exports.MessagePublisher = require('./MessagePublisher');
}

},{"./MessagePublisher":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\MessagePublisher.js","./MessagePublisherForSandbox":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\MessagePublisherForSandbox.js","./TransportInterface":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\TransportInterface.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessageSubscriber\\MessageSubscriber.js":[function(require,module,exports){
const zeroMQ = require('zeromq');

/**
 * Creates a ZeroMQ Subscriber that listens for provided topics on the specified address for a publisher
 * @param {string!} address - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @param {Array<string>|function?} subscriptions - a list of subscription topics, if missing it will subscribe to everything
 * @param {function!} onMessageCallback
 * @constructor
 */
function MessageSubscriber(address, subscriptions, onMessageCallback) {
    const zmqSocket = zeroMQ.createSocket('sub');

    // uncomment next line if messages are lost
    // zmqSocket.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);

    if(arguments.length === 2 && typeof subscriptions === 'function') {
        onMessageCallback = subscriptions;
        subscriptions = [''];
    }

    subscriptions.forEach(subscription => zmqSocket.subscribe(subscription));

    zmqSocket.connect(address);

    zmqSocket.on('message', onMessageCallback);

    const events = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];

    events.forEach(event => {
        process.on(event, () => {
            zmqSocket.close();
        });
    });
}

module.exports = MessageSubscriber;

},{"zeromq":false}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessageSubscriber\\index.js":[function(require,module,exports){
const MessageSubscriber = require('./MessageSubscriber');

module.exports = {MessageSubscriber};

},{"./MessageSubscriber":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessageSubscriber\\MessageSubscriber.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PSKLoggerClient\\GenericPSKLogger.js":[function(require,module,exports){
(function (global){
const LoggerClientModule = require('../LoggerClient');

const LoggerClient = LoggerClientModule.LoggerClient;
const LoggerInterface = LoggerClientModule.LoggerInterface;


/**
 *
 * @param messagePublisher
 * @implements LoggerInterface
 * @constructor
 */
function GenericPSKLogger(messagePublisher) {
    LoggerInterface.call(this);

    const logger = new LoggerClient(messagePublisher);

    function debug(...params) {
        const meta = prepareMeta();
        return logger.debug(meta, ...params);
    }

    function error(...params) {
        const meta = prepareMeta();
        return logger.error(meta, ...params);
    }

    function info(...params) {
        const meta = prepareMeta();
        return logger.info(meta, ...params);
    }

    function log(...params) {
        const meta = prepareMeta();
        return logger.log(meta, ...params);
    }

    function warn(...params) {
        const meta = prepareMeta();
        return logger.warn(meta, ...params);
    }

    function event(event, ...params) {
        const meta = prepareMeta();
        return logger.event(event, meta, params);
    }
    
    function redirect(logType, logObject) {
        const logMeta = logObject.meta;
        const meta = prepareMeta();
        
        Object.assign(meta, logMeta);

        logObject.meta = meta;

        return logger.redirect(logType, logObject);
    }

    function prepareMeta() {
        if (global.$$.getEnvironmentData) {
            return global.$$.getEnvironmentData();
        }
        
        return {};
    }


    this.debug    = debug;
    this.error    = error;
    this.event    = event;
    this.info     = info;
    this.log      = log;
    this.redirect = redirect;
    this.warn     = warn;

}

module.exports = GenericPSKLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../LoggerClient":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\LoggerClient\\index.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PSKLoggerClient\\index.js":[function(require,module,exports){
const Configurator     = require('../utils/Configurator');
const GenericPSKLogger = require('./GenericPSKLogger');
const MessagePublisher = require('../MessagePublisher').MessagePublisher;

function getLogger() {
    let messagePublisher;

    if (process.env.context === 'sandbox') {

        messagePublisher = new MessagePublisher();
    } else {
        const config = Configurator.getConfig();
        messagePublisher = new MessagePublisher(config.addressForPublishers);
    }

    return new GenericPSKLogger(messagePublisher);
}

module.exports = {
    getLogger
};

},{"../MessagePublisher":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\index.js","../utils/Configurator":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\Configurator.js","./GenericPSKLogger":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PSKLoggerClient\\GenericPSKLogger.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PubSubProxy\\PubSubProxy.js":[function(require,module,exports){
const zeroMQ = require('zeromq');
const utils = require('../utils');

/**
 * Proxy between publishers and subscribers to avoid star topology communication
 * Subscribers should connect first otherwise no subscription request will be sent to publishers and therefore they
 * won't even send the messages to the proxy. This is because the filtering is done on the publisher for tcp or ipc,
 * view http://zguide.zeromq.org/page:all#Getting-the-Message-Out for more info
 * @param {string!} addressForPublishers - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @param {string!} addressForSubscribers - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @constructor
 */
function PubSubProxy({addressForPublishers, addressForSubscribers}) {
    const frontend = zeroMQ.createSocket('xsub');
    const backend = zeroMQ.createSocket('xpub');
    const bufferedBackend = new utils.BufferedSocket(backend, utils.SocketType.bindable);

    // By default xpub only signals new subscriptions
    // Settings it to verbose = 1 , will signal on every new subscribe
    // uncomment next lines if messages are lost
    // backend.setsockopt(zeroMQ.ZMQ_XPUB_VERBOSE, 1);
    // backend.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);
    // backend.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);
    // frontend.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);
    // frontend.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);

    // When we receive data on frontend, it means someone is publishing
    frontend.on('message', (...args) => {
        // We just relay it to the backend, so subscribers can receive it
        bufferedBackend.send(args);
    });

    // When backend receives a message, it's subscribe requests
    backend.on('message', (data) => {
        // We send it to frontend, so it knows to what channels to listen to
        frontend.send(data);
    });

    /************* MONITOR SOCKET *************/

    frontend.bindSync(addressForPublishers);
    backend.bindSync(addressForSubscribers);

    const events = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];

    events.forEach(event => {
        process.on(event, () => {
            frontend.close();
            backend.close();
        });
    });
}

module.exports = PubSubProxy;

},{"../utils":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\index.js","zeromq":false}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PubSubProxy\\index.js":[function(require,module,exports){
const PubSubProxy = require('./PubSubProxy');

module.exports = {PubSubProxy};

},{"./PubSubProxy":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PubSubProxy\\PubSubProxy.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\BufferedSocket.js":[function(require,module,exports){
const SocketType = require('./SocketType');

/**
 * Wrapper for ZeroMQ socket that tries to prevent 'slow joiner', meaning it buffers the first messages until the
 * connection is established, otherwise the first messages would be lost
 * @param {Socket} socket - instance of ZeroMQ Socket
 * @param {SocketType<number>} type - used to determine if should listen for 'connect' or 'accept' event
 * @param {Number?} maxSize = 1000 - Max size for the internal buffer, if 0 the buffer is infinite but can cause memory leak
 * @constructor
 */
function BufferedSocket(socket, type, maxSize = 10000) {
    if(maxSize < 0) {
        maxSize = 1000;
    }

    let messageQueue = [];
    let isConnected = false;
    let currentBufferSize = 0;

    socket.monitor();
    const event = _getEventForType(type);

    socket.on(event, () => {
        isConnected = true;
        _flushQueue();
    });

    /************* PUBLIC METHODS *************/

    function send(message) {
        if (!isConnected) {
            if (maxSize !== 0 && currentBufferSize < maxSize) {
                currentBufferSize += 1;
                messageQueue.push(message);
            }
        } else {
            socket.send(message);
        }
    }

    /************* PRIVATE METHODS *************/

    function _flushQueue() {
        for (const message of messageQueue) {
            socket.send(message);
        }

        messageQueue = [];
        currentBufferSize = 0;
    }

    function _getEventForType(type) {
        if (type === SocketType.connectable) {
            return 'connect';
        } else if (type === SocketType.bindable) {
            return 'accept';
        }
    }

    /************* EXPORTS *************/

    this.send = send;
}


module.exports = BufferedSocket;

},{"./SocketType":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\SocketType.js"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\Configurator.js":[function(require,module,exports){
const config = {
    addressForPublishers: 'tcp://127.0.0.1:7000',
    addressForSubscribers: 'tcp://127.0.0.1:7001',
    addressForCollector: 'tcp://127.0.0.1:5558'
};

module.exports = {
    getConfig () {
        return Object.freeze(config);
    }
};

},{}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\EnvironmentDataProvider.js":[function(require,module,exports){


function getEnvironmentData () {
    const path = require('path');
    const os = require('os');
    const platform = os.platform();

    const processPath = process.argv[1];
    const lastSep = processPath.lastIndexOf(path.sep);
    const processStartFile = processPath.substring(lastSep + 1);
    return {
        origin: 'node',
        context: processStartFile,
        processStartFile: processStartFile,
        platform: platform
    };
}

function getEnvironmentDataForDomain() {
    const os = require('os');
    const platform = os.platform();

    return {
        origin: 'domain',
        domain: process.env.PRIVATESKY_DOMAIN_NAME,
        platform: platform
    }
}

function getEnvironmentDataForAgent() {
    const os = require('os');
    const platform = os.platform();

    return {
        origin: 'agent',
        domain: process.env.PRIVATESKY_DOMAIN_NAME,
        agent: process.env.PRIVATESKY_AGENT_NAME,
        platform: platform
    }
}

function getEnvironmentDataForSandbox() {
    return {
        origin: 'sandbox'
    }
}

module.exports = {
    getEnvironmentData,
    getEnvironmentDataForAgent,
    getEnvironmentDataForDomain,
    getEnvironmentDataForSandbox
};

},{"os":"os","path":"path"}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\LogLevel.js":[function(require,module,exports){
const LogLevel = {};

LogLevel[LogLevel["error"] = 0] = "error";
LogLevel[LogLevel["warn"]  = 1] = "warn";
LogLevel[LogLevel["info"]  = 2] = "info";
LogLevel[LogLevel["debug"] = 3] = "debug";
LogLevel[LogLevel["log"]   = 4] = "log";

module.exports = Object.freeze(LogLevel);

},{}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\SocketType.js":[function(require,module,exports){
const SocketType = {};
SocketType[SocketType["connectable"] = 0] = "connectable"; // if .connect is called on socket
SocketType[SocketType["bindable"] = 1] = "bindable"; // if .bind is called on socket

module.exports = Object.freeze(SocketType);

},{}],"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\index.js":[function(require,module,exports){
const Configurator            = require('./Configurator');
const EnvironmentDataProvider = require('./EnvironmentDataProvider');
const LogLevel                = require('./LogLevel');
const BufferedSocket          = require('./BufferedSocket');
const SocketType              = require('./SocketType');

module.exports = {
    Configurator,
    EnvironmentDataProvider,
    LogLevel,
    BufferedSocket,
    SocketType
};

},{"./BufferedSocket":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\BufferedSocket.js","./Configurator":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\Configurator.js","./EnvironmentDataProvider":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\EnvironmentDataProvider.js","./LogLevel":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\LogLevel.js","./SocketType":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\SocketType.js"}],"C:\\Users\\Public\\privatesky\\modules\\soundpubsub\\lib\\soundPubSub.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Snic.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/


/**
 *   Usually an event could cause execution of other callback events . We say that is a level 1 event if is causeed by a level 0 event and so on
 *
 *      SoundPubSub provides intuitive results regarding to asynchronous calls of callbacks and computed values/expressions:
 *   we prevent immediate execution of event callbacks to ensure the intuitive final result is guaranteed as level 0 execution
 *   we guarantee that any callback function is "re-entrant"
 *   we are also trying to reduce the number of callback execution by looking in queues at new messages published by
 *   trying to compact those messages (removing duplicate messages, modifying messages, or adding in the history of another event ,etc)
 *
 *      Example of what can be wrong without non-sound asynchronous calls:
 *
 *  Step 0: Initial state:
 *   a = 0;
 *   b = 0;
 *
 *  Step 1: Initial operations:
 *   a = 1;
 *   b = -1;
 *
 *  // an observer reacts to changes in a and b and compute CORRECT like this:
 *   if( a + b == 0) {
 *       CORRECT = false;
 *       notify(...); // act or send a notification somewhere..
 *   } else {
 *      CORRECT = false;
 *   }
 *
 *    Notice that: CORRECT will be true in the end , but meantime, after a notification was sent and CORRECT was wrongly, temporarily false!
 *    soundPubSub guarantee that this does not happen because the syncronous call will before any observer (bot asignation on a and b)
 *
 *   More:
 *   you can use blockCallBacks and releaseCallBacks in a function that change a lot a collection or bindable objects and all
 *   the notifications will be sent compacted and properly
 */

// TODO: optimisation!? use a more efficient queue instead of arrays with push and shift!?
// TODO: see how big those queues can be in real applications
// for a few hundreds items, queues made from array should be enough
//*   Potential TODOs:
//    *     prevent any form of problem by calling callbacks in the expected order !?
//*     preventing infinite loops execution cause by events!?
//*
//*
// TODO: detect infinite loops (or very deep propagation) It is possible!?

const Queue = require('swarmutils').Queue;

function SoundPubSub(){

	/**
	 * publish
	 *      Publish a message {Object} to a list of subscribers on a specific topic
	 *
	 * @params {String|Number} target,  {Object} message
	 * @return number of channel subscribers that will be notified
	 */
	this.publish = function(target, message){
		if(!invalidChannelName(target) && !invalidMessageType(message) && (typeof channelSubscribers[target] != 'undefined')){
			compactAndStore(target, message);
			setTimeout(dispatchNext, 0);
			return channelSubscribers[target].length;
		} else{
			return null;
		}
	};

	/**
	 * subscribe
	 *      Subscribe / add a {Function} callBack on a {String|Number}target channel subscribers list in order to receive
	 *      messages published if the conditions defined by {Function}waitForMore and {Function}filter are passed.
	 *
	 * @params {String|Number}target, {Function}callBack, {Function}waitForMore, {Function}filter
	 *
	 *          target      - channel name to subscribe
	 *          callback    - function to be called when a message was published on the channel
	 *          waitForMore - a intermediary function that will be called after a successfuly message delivery in order
	 *                          to decide if a new messages is expected...
	 *          filter      - a function that receives the message before invocation of callback function in order to allow
	 *                          relevant message before entering in normal callback flow
	 * @return
	 */
	this.subscribe = function(target, callBack, waitForMore, filter){
		if(!invalidChannelName(target) && !invalidFunction(callBack)){
			var subscriber = {"callBack":callBack, "waitForMore":waitForMore, "filter":filter};
			var arr = channelSubscribers[target];
			if(typeof arr == 'undefined'){
				arr = [];
				channelSubscribers[target] = arr;
			}
			arr.push(subscriber);
		}
	};

	/**
	 * unsubscribe
	 *      Unsubscribe/remove {Function} callBack from the list of subscribers of the {String|Number} target channel
	 *
	 * @params {String|Number} target, {Function} callBack, {Function} filter
	 *
	 *          target      - channel name to unsubscribe
	 *          callback    - reference of the original function that was used as subscribe
	 *          filter      - reference of the original filter function
	 * @return
	 */
	this.unsubscribe = function(target, callBack, filter){
		if(!invalidFunction(callBack)){
			var gotit = false;
			if(channelSubscribers[target]){
				for(var i = 0; i < channelSubscribers[target].length;i++){
					var subscriber =  channelSubscribers[target][i];
					if(subscriber.callBack === callBack && ( typeof filter === 'undefined' || subscriber.filter === filter )){
						gotit = true;
						subscriber.forDelete = true;
						subscriber.callBack = undefined;
						subscriber.filter = undefined;
					}
				}
			}
			if(!gotit){
				wprint("Unable to unsubscribe a callback that was not subscribed!");
			}
		}
	};

	/**
	 * blockCallBacks
	 *
	 * @params
	 * @return
	 */
	this.blockCallBacks = function(){
		level++;
	};

	/**
	 * releaseCallBacks
	 *
	 * @params
	 * @return
	 */
	this.releaseCallBacks = function(){
		level--;
		//hack/optimisation to not fill the stack in extreme cases (many events caused by loops in collections,etc)
		while(level === 0 && dispatchNext(true)){
			//nothing
		}

		while(level === 0 && callAfterAllEvents()){
            //nothing
		}
	};

	/**
	 * afterAllEvents
	 *
	 * @params {Function} callback
	 *
	 *          callback - function that needs to be invoked once all events are delivered
	 * @return
	 */
	this.afterAllEvents = function(callBack){
		if(!invalidFunction(callBack)){
			afterEventsCalls.push(callBack);
		}
		this.blockCallBacks();
		this.releaseCallBacks();
	};

	/**
	 * hasChannel
	 *
	 * @params {String|Number} channel
	 *
	 *          channel - name of the channel that need to be tested if present
	 * @return
	 */
	this.hasChannel = function(channel){
		return !invalidChannelName(channel) && (typeof channelSubscribers[channel] != 'undefined') ? true : false;
	};

	/**
	 * addChannel
	 *
	 * @params {String} channel
	 *
	 *          channel - name of a channel that needs to be created and added to soundpubsub repository
	 * @return
	 */
	this.addChannel = function(channel){
		if(!invalidChannelName(channel) && !this.hasChannel(channel)){
			channelSubscribers[channel] = [];
		}
	};

	/* ---------------------------------------- protected stuff ---------------------------------------- */
	var self = this;
	// map channelName (object local id) -> array with subscribers
	var channelSubscribers = {};

	// map channelName (object local id) -> queue with waiting messages
	var channelsStorage = {};

	// object
	var typeCompactor = {};

	// channel names
	var executionQueue = new Queue();
	var level = 0;



	/**
	 * registerCompactor
	 *
	 *       An compactor takes a newEvent and and oldEvent and return the one that survives (oldEvent if
	 *  it can compact the new one or the newEvent if can't be compacted)
	 *
	 * @params {String} type, {Function} callBack
	 *
	 *          type        - channel name to unsubscribe
	 *          callBack    - handler function for that specific event type
	 * @return
	 */
	this.registerCompactor = function(type, callBack) {
		if(!invalidFunction(callBack)){
			typeCompactor[type] = callBack;
		}
	};

	/**
	 * dispatchNext
	 *
	 * @param fromReleaseCallBacks: hack to prevent too many recursive calls on releaseCallBacks
	 * @return {Boolean}
	 */
	function dispatchNext(fromReleaseCallBacks){
		if(level > 0) {
			return false;
		}
		const channelName = executionQueue.front();
		if(typeof channelName != 'undefined'){
			self.blockCallBacks();
			try{
				let message;
				if(!channelsStorage[channelName].isEmpty()) {
					message = channelsStorage[channelName].front();
				}
				if(typeof message == 'undefined'){
					if(!channelsStorage[channelName].isEmpty()){
						wprint("Can't use as message in a pub/sub channel this object: " + message);
					}
					executionQueue.pop();
				} else {
					if(typeof message.__transmisionIndex == 'undefined'){
						message.__transmisionIndex = 0;
						for(var i = channelSubscribers[channelName].length-1; i >= 0 ; i--){
							var subscriber =  channelSubscribers[channelName][i];
							if(subscriber.forDelete === true){
								channelSubscribers[channelName].splice(i,1);
							}
						}
					} else{
						message.__transmisionIndex++;
					}
					//TODO: for immutable objects it will not work also, fix for shape models
					if(typeof message.__transmisionIndex == 'undefined'){
						wprint("Can't use as message in a pub/sub channel this object: " + message);
					}
					subscriber = channelSubscribers[channelName][message.__transmisionIndex];
					if(typeof subscriber == 'undefined'){
						delete message.__transmisionIndex;
						channelsStorage[channelName].pop();
					} else{
						if(subscriber.filter === null || typeof subscriber.filter === "undefined" || (!invalidFunction(subscriber.filter) && subscriber.filter(message))){
							if(!subscriber.forDelete){
								subscriber.callBack(message);
								if(subscriber.waitForMore && !invalidFunction(subscriber.waitForMore) && !subscriber.waitForMore(message)){
									subscriber.forDelete = true;
								}
							}
						}
					}
				}
			} catch(err){
				wprint("Event callback failed: "+ subscriber.callBack +"error: " + err.stack);
			}
			//
			if(fromReleaseCallBacks){
				level--;
			} else{
				self.releaseCallBacks();
			}
			return true;
		} else{
			return false;
		}
	}

	function compactAndStore(target, message){
		var gotCompacted = false;
		var arr = channelsStorage[target];
		if(typeof arr == 'undefined'){
			arr = new Queue();
			channelsStorage[target] = arr;
		}

		if(message && typeof message.type != 'undefined'){
			var typeCompactorCallBack = typeCompactor[message.type];

			if(typeof typeCompactorCallBack != 'undefined'){
				for(let channel of arr) {
					if(typeCompactorCallBack(message, channel) === channel) {
						if(typeof channel.__transmisionIndex == 'undefined') {
							gotCompacted = true;
							break;
						}
					}
				}
			}
		}

		if(!gotCompacted && message){
			arr.push(message);
			executionQueue.push(target);
		}
	}

	var afterEventsCalls = new Queue();
	function callAfterAllEvents (){
		if(!afterEventsCalls.isEmpty()){
			var callBack = afterEventsCalls.pop();
			//do not catch exceptions here..
			callBack();
		}
		return !afterEventsCalls.isEmpty();
	}

	function invalidChannelName(name){
		var result = false;
		if(!name || (typeof name != "string" && typeof name != "number")){
			result = true;
			wprint("Invalid channel name: " + name);
		}

		return result;
	}

	function invalidMessageType(message){
		var result = false;
		if(!message || typeof message != "object"){
			result = true;
			wprint("Invalid messages types: " + message);
		}
		return result;
	}

	function invalidFunction(callback){
		var result = false;
		if(!callback || typeof callback != "function"){
			result = true;
			wprint("Expected to be function but is: " + callback);
		}
		return result;
	}
}

exports.soundPubSub = new SoundPubSub();
},{"swarmutils":"swarmutils"}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\Combos.js":[function(require,module,exports){
function product(args) {
    if(!args.length){
        return [ [] ];
    }
    var prod = product(args.slice(1)), r = [];
    args[0].forEach(function(x) {
        prod.forEach(function(p) {
            r.push([ x ].concat(p));
        });
    });
    return r;
}

function objectProduct(obj) {
    var keys = Object.keys(obj),
        values = keys.map(function(x) { return obj[x]; });

    return product(values).map(function(p) {
        var e = {};
        keys.forEach(function(k, n) { e[k] = p[n]; });
        return e;
    });
}

module.exports = objectProduct;
},{}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\OwM.js":[function(require,module,exports){
var meta = "meta";

function OwM(serialized){

    if(serialized){
        return OwM.prototype.convert(serialized);
    }

    Object.defineProperty(this, meta, {
        writable: false,
        enumerable: true,
        value: {}
    });

    Object.defineProperty(this, "setMeta", {
        writable: false,
        enumerable: false,
        configurable:false,
        value: function(prop, value){
            if(typeof prop == "object" && typeof value == "undefined"){
                for(var p in prop){
                    this[meta][p] = prop[p];
                }
                return prop;
            }
            this[meta][prop] = value;
            return value;
        }
    });

    Object.defineProperty(this, "getMeta", {
        writable: false,
        value: function(prop){
            return this[meta][prop];
        }
    });
}

function testOwMSerialization(obj){
    let res = false;

    if(obj){
        res = typeof obj[meta] != "undefined" && !(obj instanceof OwM);
    }

    return res;
}

OwM.prototype.convert = function(serialized){
    const owm = new OwM();

    for(var metaProp in serialized.meta){
        if(!testOwMSerialization(serialized[metaProp])) {
            owm.setMeta(metaProp, serialized.meta[metaProp]);
        }else{
            owm.setMeta(metaProp, OwM.prototype.convert(serialized.meta[metaProp]));
        }
    }

    for(var simpleProp in serialized){
        if(simpleProp === meta) {
            continue;
        }

        if(!testOwMSerialization(serialized[simpleProp])){
            owm[simpleProp] = serialized[simpleProp];
        }else{
            owm[simpleProp] = OwM.prototype.convert(serialized[simpleProp]);
        }
    }

    return owm;
};

OwM.prototype.getMetaFrom = function(obj, name){
    var res;
    if(!name){
        res = obj[meta];
    }else{
        res = obj[meta][name];
    }
    return res;
};

OwM.prototype.setMetaFor = function(obj, name, value){
    obj[meta][name] = value;
    return obj[meta][name];
};

module.exports = OwM;
},{}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\Queue.js":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;
},{}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\beesHealer.js":[function(require,module,exports){
const OwM = require("./OwM");

/*
    Prepare the state of a swarm to be serialised
*/

exports.asJSON = function(valueObj, phaseName, args, callback){

        let valueObject = valueObj.valueOf();
        let res = new OwM();
        res.publicVars          = valueObject.publicVars;
        res.privateVars         = valueObject.privateVars;

        res.setMeta("swarmTypeName", OwM.prototype.getMetaFrom(valueObject, "swarmTypeName"));
        res.setMeta("swarmId",       OwM.prototype.getMetaFrom(valueObject, "swarmId"));
        res.setMeta("target",        OwM.prototype.getMetaFrom(valueObject, "target"));
        res.setMeta("homeSecurityContext",        OwM.prototype.getMetaFrom(valueObject, "homeSecurityContext"));
        res.setMeta("requestId",        OwM.prototype.getMetaFrom(valueObject, "requestId"));

        if(!phaseName){
            res.setMeta("command", "stored");
        } else {
            res.setMeta("phaseName", phaseName);
            res.setMeta("phaseId", $$.uidGenerator.safe_uuid());
            res.setMeta("args", args);
            res.setMeta("command", OwM.prototype.getMetaFrom(valueObject, "command") || "executeSwarmPhase");
        }

        res.setMeta("waitStack", valueObject.meta.waitStack); //TODO: think if is not better to be deep cloned and not referenced!!!

        if(callback){
            return callback(null, res);
        }
        //console.log("asJSON:", res, valueObject);
        return res;
};

exports.jsonToNative = function(serialisedValues, result){

    for(let v in serialisedValues.publicVars){
        result.publicVars[v] = serialisedValues.publicVars[v];

    };
    for(let l in serialisedValues.privateVars){
        result.privateVars[l] = serialisedValues.privateVars[l];
    };

    for(let i in OwM.prototype.getMetaFrom(serialisedValues)){
        OwM.prototype.setMetaFor(result, i, OwM.prototype.getMetaFrom(serialisedValues, i));
    };

};
},{"./OwM":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\OwM.js"}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\pskconsole.js":[function(require,module,exports){
var commands = {};
var commands_help = {};

//global function addCommand
addCommand = function addCommand(verb, adverbe, funct, helpLine){
    var cmdId;
    if(!helpLine){
        helpLine = " ";
    } else {
        helpLine = " " + helpLine;
    }
    if(adverbe){
        cmdId = verb + " " +  adverbe;
        helpLine = verb + " " +  adverbe + helpLine;
    } else {
        cmdId = verb;
        helpLine = verb + helpLine;
    }
    commands[cmdId] = funct;
        commands_help[cmdId] = helpLine;
};

function doHelp(){
    console.log("List of commands:");
    for(var l in commands_help){
        console.log("\t", commands_help[l]);
    }
}

addCommand("-h", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("/?", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("help", null, doHelp, "\t\t\t\t\t\t |just print the help");


function runCommand(){
  var argv = Object.assign([], process.argv);
  var cmdId = null;
  var cmd = null;
  argv.shift();
  argv.shift();

  if(argv.length >=1){
      cmdId = argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }


  if(!cmd && argv.length >=1){
      cmdId = cmdId + " " + argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }

  if(!cmd){
    if(cmdId){
        console.log("Unknown command: ", cmdId);
    }
    cmd = doHelp;
  }

  cmd.apply(null,argv);

}

module.exports = {
    runCommand
};


},{}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\safe-uuid.js":[function(require,module,exports){

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
};

function stampWithTime(buf, salt, msalt){
    if(!salt){
        salt = 1;
    }
    if(!msalt){
        msalt = 1;
    }
    var date = new Date;
    var ct = Math.floor(date.getTime() / salt);
    var counter = 0;
    while(ct > 0 ){
        //console.log("Counter", counter, ct);
        buf[counter*msalt] = Math.floor(ct % 256);
        ct = Math.floor(ct / 256);
        counter++;
    }
}

/*
    The uid contains around 256 bits of randomness and are unique at the level of seconds. This UUID should by cryptographically safe (can not be guessed)

    We generate a safe UID that is guaranteed unique (by usage of a PRNG to geneate 256 bits) and time stamping with the number of seconds at the moment when is generated
    This method should be safe to use at the level of very large distributed systems.
    The UUID is stamped with time (seconds): does it open a way to guess the UUID? It depends how safe is "crypto" PRNG, but it should be no problem...

 */

var generateUid = null;


exports.init = function(externalGenerator){
    generateUid = externalGenerator.generateUid;
    return module.exports;
};

exports.safe_uuid = function() {
    var buf = generateUid(32);
    stampWithTime(buf, 1000, 3);
    return encode(buf);
};



/*
    Try to generate a small UID that is unique against chance in the same millisecond second and in a specific context (eg in the same choreography execution)
    The id contains around 6*8 = 48  bits of randomness and are unique at the level of milliseconds
    This method is safe on a single computer but should be used with care otherwise
    This UUID is not cryptographically safe (can be guessed)
 */
exports.short_uuid = function(callback) {
    require('crypto').randomBytes(12, function (err, buf) {
        if (err) {
            callback(err);
            return;
        }
        stampWithTime(buf,1,2);
        callback(null, encode(buf));
    });
};
},{"crypto":"crypto"}],"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\uidGenerator.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const Queue = require("./Queue");
var PSKBuffer = typeof $$ !== "undefined" && $$.PSKBuffer ? $$.PSKBuffer : Buffer;

function UidGenerator(minBuffers, buffersSize) {
	var buffers = new Queue();
	var lowLimit = .2;

	function fillBuffers(size){
		//notifyObserver();
		const sz = size || minBuffers;
		if(buffers.length < Math.floor(minBuffers*lowLimit)){
			for(var i=0+buffers.length; i < sz; i++){
				generateOneBuffer(null);
			}
		}
	}

	fillBuffers();

	function generateOneBuffer(b){
		if(!b){
			b = PSKBuffer.alloc(0);
		}
		const sz = buffersSize - b.length;
		/*crypto.randomBytes(sz, function (err, res) {
			buffers.push(Buffer.concat([res, b]));
			notifyObserver();
		});*/
		buffers.push(PSKBuffer.concat([ crypto.randomBytes(sz), b ]));
		notifyObserver();
	}

	function extractN(n){
		var sz = Math.floor(n / buffersSize);
		var ret = [];

		for(var i=0; i<sz; i++){
			ret.push(buffers.pop());
			setTimeout(generateOneBuffer, 1);
		}



		var remainder = n % buffersSize;
		if(remainder > 0){
			var front = buffers.pop();
			ret.push(front.slice(0,remainder));
			//generateOneBuffer(front.slice(remainder));
			setTimeout(function(){
				generateOneBuffer(front.slice(remainder));
			},1);
		}

		//setTimeout(fillBuffers, 1);

		return Buffer.concat(ret);
	}

	var fillInProgress = false;

	this.generateUid = function(n){
		var totalSize = buffers.length * buffersSize;
		if(n <= totalSize){
			return extractN(n);
		} else {
			if(!fillInProgress){
				fillInProgress = true;
				setTimeout(function(){
					fillBuffers(Math.floor(minBuffers*2.5));
					fillInProgress = false;
				}, 1);
			}
			return crypto.randomBytes(n);
		}
	};

	var observer;
	this.registerObserver = function(obs){
		if(observer){
			console.error(new Error("One observer allowed!"));
		}else{
			if(typeof obs == "function"){
				observer = obs;
				//notifyObserver();
			}
		}
	};

	function notifyObserver(){
		if(observer){
			var valueToReport = buffers.length*buffersSize;
			setTimeout(function(){
				observer(null, {"size": valueToReport});
			}, 10);
		}
	}
}

module.exports.createUidGenerator = function (minBuffers, bufferSize) {
	return new UidGenerator(minBuffers, bufferSize);
};

}).call(this,require("buffer").Buffer)

},{"./Queue":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\Queue.js","buffer":"buffer","crypto":"crypto"}],"C:\\Users\\Public\\privatesky\\psknode\\core\\sandboxes\\util\\SandBoxManager.js":[function(require,module,exports){
var mq = $$.require("foldermq");

const path = require('path');
const child_process = require("child_process");
const fs = require('fs');

const RESTART_TIMEOUT = 500;
const RESTART_TIMEOUT_LIMIT = 50000;

var sandboxes = {};
var exitHandler = require("../../utils/exitHandler")(sandboxes);

var bootSandBox = $$.flow.describe("PrivateSky.swarm.engine.bootInLauncher", {
    boot:function(sandBox, spaceName, folder, codeFolder, callback){
        // console.log("Booting in ", folder, " context ", spaceName);

        this.callback   = callback;
        this.folder     = folder;
        this.spaceName  = spaceName;
        this.sandBox    = sandBox;
        this.codeFolder    = codeFolder;
        this.timeoutMultiplier = 1;

        var task = this.serial(this.ensureFoldersExists);

        task.folderShouldExist(path.join(this.folder, "mq"),    task.progress);
        task.folderShouldExist(path.join(this.folder, "bundles"),  task.progress);
        task.folderShouldExist(path.join(this.folder, "tmp"),   task.progress);
    },
    folderShouldExist:  function(path, progress){
        fs.mkdir(path, {recursive: true}, progress);
    },
    copyFolder: function(sourcePath, targetPath, callback){
        let fsExt = require("utils").fsExt;
        try{
            fsExt.copy(sourcePath, targetPath, {overwrite: true}, callback);
        }catch(err){
            console.log("Got something...", err);
        }
    },
    ensureFoldersExists: function(err, res){
        if(err){
            console.log(err);
        } else {
            var task = this.parallel(this.runCode);
            this.sandBox.inbound = mq.createQue(path.join(this.folder, "mq/inbound"), this.progress);
            this.sandBox.outbound = mq.createQue(path.join(this.folder, "mq/outbound"), this.progress);

            console.log("Preparing to copy", path.join(this.codeFolder, "bundles"), path.resolve(path.join(this.folder, "bundles")));
            this.copyFolder(path.join(this.codeFolder, "bundles"), path.resolve(path.join(this.folder, "bundles")), task.progress);
        }

    },
    runCode: function(err, res){
        if(!err){
            var mainFile = path.join(process.env.PRIVATESKY_ROOT_FOLDER, "core", "sandboxes", "agentSandbox.js");
            var args = [this.spaceName, process.env.PRIVATESKY_ROOT_FOLDER, path.resolve(process.env.PRIVATESKY_DOMAIN_BUILD)];
            var opts = {stdio: [0, 1, 2, "ipc"]};

            var startChild = (mainFile, args, opts) => {
				console.log("Running: ", mainFile, args, opts);

				// passing options.env might break the agentSandbox, it relies on some inherited env variables from domain
				var child = child_process.fork(mainFile, args);
				sandboxes[this.spaceName] = child;

				this.sandBox.inbound.setIPCChannel(child);
				this.sandBox.outbound.setIPCChannel(child);

				child.on("exit", (code, signal)=>{
				    if(code === 0){
				        console.log(`Sandbox <${this.spaceName}> shutting down.`);
				        return;
                    }
				    let timeout = (this.timeoutMultiplier*RESTART_TIMEOUT) % RESTART_TIMEOUT_LIMIT;
				    console.log(`Sandbox <${this.spaceName}> exits with code ${code}. Restarting in ${timeout} ms.`);
					setTimeout(()=>{
						startChild(mainFile, args, opts);
                        this.timeoutMultiplier *= 1.5;
                    }, timeout);
				});

				return child;
            };

            this.callback(null, startChild(mainFile, args, opts));
        } else {
            console.log("Error executing sandbox!:", err);
            this.callback(err, null);
        }
    }

});

function SandBoxHandler(spaceName, folder, codeFolder, resultCallBack){

    var self = this;
    var mqHandler;


    bootSandBox().boot(this, spaceName,folder, codeFolder, function(err, childProcess){
        if(!err){
            self.childProcess = childProcess;


            /*self.outbound.registerConsumer(function(err, swarm){
                $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, swarm);
            });*/

            self.outbound.registerAsIPCConsumer(function(err, swarm){
                $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, swarm);
            });

            mqHandler = self.inbound.getHandler();
            if(pendingMessages.length){
                pendingMessages.map(function(item){
                    self.send(item);
                });
                pendingMessages = null;
            }
        }
    });

    var pendingMessages = [];

    this.send = function (swarm, callback) {
        if(mqHandler){
            mqHandler.sendSwarmForExecution(swarm, callback);
        } else {
            pendingMessages.push(swarm); //TODO: well, a deep clone will not be a better idea?
        }
    }

}


function SandBoxManager(sandboxesFolder, codeFolder, callback){
    var self = this;

    var sandBoxes = {

    };
    function belongsToReplicatedSpace(){
        return true;
    }

    //console.log("Subscribing to:", $$.CONSTANTS.SWARM_FOR_EXECUTION);
    $$.PSK_PubSub.subscribe($$.CONSTANTS.SWARM_FOR_EXECUTION, function(swarm){
        console.log("Executing in sandbox towards: ", swarm.meta.target);

        if(swarm.meta.target == "system" || swarm.meta.command == "asyncReturn"){
            $$.swarmsInstancesManager.revive_swarm(swarm);
            //$$.swarms.restart(swarm.meta.swarmTypeName, swarm);
        } else
        if(swarm.meta.target == "pds"){
            //
        } else
        if(belongsToReplicatedSpace(swarm.meta.target)){
            self.pushToSpaceASwarm(swarm.meta.target, swarm);
        } else {
            //TODO: send towards network
        }

    });


    function startSandBox(spaceName){
        var sandBox = new SandBoxHandler(spaceName, path.join(sandboxesFolder, spaceName), codeFolder);
        sandBoxes[spaceName] = sandBox;
        return sandBox;
    }


    this.pushToSpaceASwarm = function(spaceName, swarm, callback){

        console.log("pushToSpaceASwarm " , spaceName);
        var sandbox = sandBoxes[spaceName];
        if(!sandbox){
            sandbox = sandBoxes[spaceName] = startSandBox(spaceName);
        }
        sandbox.send(swarm, callback);
    }

    callback(null, this);
}


exports.create = function(folder, codeFolder, callback){
    new SandBoxManager(folder, codeFolder, callback);
};



},{"../../utils/exitHandler":"C:\\Users\\Public\\privatesky\\psknode\\core\\utils\\exitHandler.js","child_process":false,"fs":false,"path":"path","utils":"utils"}],"C:\\Users\\Public\\privatesky\\psknode\\core\\utils\\exitHandler.js":[function(require,module,exports){
const events = ["exit", "SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];
const os = require("os");

module.exports = function manageShutdownProcess(childrenList){

    let shutting = false;
    function handler(){
        //console.log("Handling exit event on", process.pid, "arguments:", arguments);
        var childrenNames = Object.keys(childrenList);
        for(let j=0; j<childrenNames.length; j++){
            var child = childrenList[childrenNames[j]];
            //console.log(`[${process.pid}]`, "Sending kill signal to PID:", child.pid);
            try{
                process.kill(child.pid);
            }catch(err){
                //...
            }
        }

        if(!shutting){
            try{
                process.stdout.cursorTo(0);
                process.stdout.write(`[PID: ${process.pid}] [Timestamp: ${new Date().getTime()}] [Process argv: ${process.argv}]- Shutting down...\n`);
            }catch(err)
            {
                //...
            }
            shutting = true;
        }

        setTimeout(()=>{
            process.exit(0);
        }, 0);
    }

    //TODO: find a better solution to replace process.stdin.resume()
    if(os.patform === "win32" && process.env.SHELL === "/bin/bash"){
        console.log("Could not execute resume() on stdin. Please use command prompt on windows to run PSK!!!\n\n\n");
    }else{
        process.stdin.resume();
    }

    for(let i=0; i<events.length; i++){
        var eventType = events[i];
        process.on(eventType, handler);
    }
    //console.log("Exit handler setup!", `[${process.pid}]`);
};
},{"os":"os"}],"callflow":[function(require,module,exports){

//var path = require("path");
function defaultErrorHandlingImplementation(err, res){
	//console.log(err.stack);
	if(err) throw err;
	return res;
}

require("./lib/overwriteRequire");
/*
const PSKBuffer = require('pskbuffer');
$$.PSKBuffer = PSKBuffer; */


$$.__intern = {
        mkArgs:function(args,pos){
            var argsArray = [];
            for(var i = pos; i < args.length; i++){
                argsArray.push(args[i]);
            }
            return argsArray;
        }
    };



var swarmUtils = require("./lib/choreographies/swarm");
var assetUtils = require("./lib/utilityFunctions/asset");

var transactionUtils = require("./lib/utilityFunctions/transaction");
$$.defaultErrorHandlingImplementation = defaultErrorHandlingImplementation;

var callflowModule = require("./lib/swarmDescription");
$$.callflows        = callflowModule.createSwarmEngine("callflow");
$$.callflow         = $$.callflows;
$$.flow             = $$.callflows;
$$.flows            = $$.callflows;

$$.swarms           = callflowModule.createSwarmEngine("swarm", swarmUtils);
$$.swarm            = $$.swarms;
$$.contracts        = callflowModule.createSwarmEngine("contract", swarmUtils);
$$.contract         = $$.contracts;
$$.assets           = callflowModule.createSwarmEngine("asset", assetUtils);
$$.asset            = $$.assets;
$$.transactions     = callflowModule.createSwarmEngine("transaction", transactionUtils);
$$.transaction      = $$.transactions;


$$.PSK_PubSub = require("soundpubsub").soundPubSub;

$$.securityContext = "system";
$$.libraryPrefix = "global";
$$.libraries = {
    global:{

    }
};

$$.interceptor = require("./lib/InterceptorRegistry").createInterceptorRegistry();

$$.loadLibrary = require("./lib/loadLibrary").loadLibrary;

requireLibrary = function(name){
    //var absolutePath = path.resolve(  $$.__global.__loadLibraryRoot + name);
    return $$.loadLibrary(name,name);
};

require("./constants");

/*//TODO: SHOULD be moved in $$.__globals
$$.ensureFolderExists = function (folder, callback) {
    const flow = $$.flow.start("utils.mkDirRec");
    flow.make(folder, callback);
};

$$.ensureLinkExists = function (existingPath, newPath, callback) {
    const flow = $$.flow.start("utils.mkDirRec");
    flow.makeLink(existingPath, newPath, callback);
};*/

$$.pathNormalize = function (pathToNormalize) {
    const path = require("path");
    pathToNormalize = path.normalize(pathToNormalize);

    return pathToNormalize.replace(/[\/\\]/g, path.sep);
};

// add interceptors

const crypto = require('crypto');

$$.interceptor.register('*', '*', 'before', function () {
    const swarmTypeName = this.getMetadata('swarmTypeName');
    const phaseName = this.getMetadata('phaseName');
    const swarmId = this.getMetadata('swarmId');
    const executionId = crypto.randomBytes(16).toString('hex');

    this.setMetadata('executionId', executionId);

    $$.event('swarm.call.before', {swarmTypeName, phaseName, executionId});
});

$$.interceptor.register('*', '*', 'after', function () {
    const swarmTypeName = this.getMetadata('swarmTypeName');
    const phaseName = this.getMetadata('phaseName');
    const executionId = this.getMetadata('executionId');

    this.setMetadata('executionId', undefined);

    $$.event('swarm.call.time', {swarmTypeName, phaseName, executionId});
});

module.exports = {
    				createSwarmEngine: require("./lib/swarmDescription").createSwarmEngine,
                    createJoinPoint: require("./lib/parallelJoinPoint").createJoinPoint,
                    createSerialJoinPoint: require("./lib/serialJoinPoint").createSerialJoinPoint,
                    swarmInstanceManager: require("./lib/choreographies/swarmInstancesManager"),
                    enableInternalSwarmRouting: function(){
                        function dummyVM(name){
                            function solveSwarm(swarm){
                                $$.swarmsInstancesManager.revive_swarm(swarm);
                            }

                            $$.PSK_PubSub.subscribe(name, solveSwarm);
                            console.log("Creating a fake execution context...");
                        }
                        dummyVM($$.CONSTANTS.SWARM_FOR_EXECUTION);
                    }
				};

},{"./constants":"C:\\Users\\Public\\privatesky\\modules\\callflow\\constants.js","./lib/InterceptorRegistry":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\InterceptorRegistry.js","./lib/choreographies/swarm":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\swarm.js","./lib/choreographies/swarmInstancesManager":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\choreographies\\swarmInstancesManager.js","./lib/loadLibrary":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\loadLibrary.js","./lib/overwriteRequire":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\overwriteRequire.js","./lib/parallelJoinPoint":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\parallelJoinPoint.js","./lib/serialJoinPoint":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\serialJoinPoint.js","./lib/swarmDescription":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\swarmDescription.js","./lib/utilityFunctions/asset":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\asset.js","./lib/utilityFunctions/transaction":"C:\\Users\\Public\\privatesky\\modules\\callflow\\lib\\utilityFunctions\\transaction.js","crypto":"crypto","path":"path","soundpubsub":"soundpubsub"}],"dicontainer":[function(require,module,exports){
if(typeof singleton_container_module_workaround_for_wired_node_js_caching == 'undefined') {
    singleton_container_module_workaround_for_wired_node_js_caching   = module;
} else {
    module.exports = singleton_container_module_workaround_for_wired_node_js_caching .exports;
    return module;
}

/**
 * Created by salboaie on 4/27/15.
 */
function Container(errorHandler){
    var things = {};        //the actual values for our services, things
    var immediate = {};     //how dependencies were declared
    var callbacks = {};     //callback that should be called for each dependency declaration
    var depsCounter = {};   //count dependencies
    var reversedTree = {};  //reversed dependencies, opposite of immediate object

     this.dump = function(){
         console.log("Conatiner dump\n Things:", things, "\nDeps counter: ", depsCounter, "\nStright:", immediate, "\nReversed:", reversedTree);
     };

    function incCounter(name){
        if(!depsCounter[name]){
            depsCounter[name] = 1;
        } else {
            depsCounter[name]++;
        }
    }

    function insertDependencyinRT(nodeName, dependencies){
        dependencies.forEach(function(itemName){
            var l = reversedTree[itemName];
            if(!l){
                l = reversedTree[itemName] = {};
            }
            l[nodeName] = nodeName;
        });
    }


    function discoverUpNodes(nodeName){
        var res = {};

        function DFS(nn){
            var l = reversedTree[nn];
            for(var i in l){
                if(!res[i]){
                    res[i] = true;
                    DFS(i);
                }
            }
        }

        DFS(nodeName);
        return Object.keys(res);
    }

    function resetCounter(name){
        var dependencyArray = immediate[name];
        var counter = 0;
        if(dependencyArray){
            dependencyArray.forEach(function(dep){
                if(things[dep] == null){
                    incCounter(name);
                    counter++;
                }
            });
        }
        depsCounter[name] = counter;
        //console.log("Counter for ", name, ' is ', counter);
        return counter;
    }

    /* returns those that are ready to be resolved*/
    function resetUpCounters(name){
        var ret = [];
        //console.log('Reseting up counters for ', name, "Reverse:", reversedTree[name]);
        var ups = reversedTree[name];
        for(var v in ups){
            if(resetCounter(v) === 0){
                ret.push(v);
            }
        }
        return ret;
    }

    /*
         The first argument is a name for a service, variable,a  thing that should be initialised, recreated, etc
         The second argument is an array with dependencies
         the last argument is a function(err,...) that is called when dependencies are ready or recalled when are not ready (stop was called)
         If err is not undefined it means that one or any undefined variables are not ready and the callback will be called again later
         All the other arguments are the corresponding arguments of the callback will be the actual values of the corresponding dependency
         The callback functions should return the current value (or null)
     */
    this.declareDependency = function(name, dependencyArray, callback){
        if(callbacks[name]){
            errorHandler.ignorePossibleError("Duplicate dependency:" + name);
        } else {
            callbacks[name] = callback;
            immediate[name]   = dependencyArray;
            insertDependencyinRT(name, dependencyArray);
            things[name] = null;
        }

        var unsatisfiedCounter = resetCounter(name);
        if(unsatisfiedCounter === 0 ){
            callForThing(name, false);
        } else {
            callForThing(name, true);
        }
    };


    /*
        create a service
     */
    this.service = function(name, dependencyArray, constructor){
        this.declareDependency(name, dependencyArray, constructor);
    };


    var subsystemCounter = 0;
    /*
     create a anonymous subsystem
     */
    this.subsystem = function(dependencyArray, constructor){
        subsystemCounter++;
        this.declareDependency("dicontainer_subsystem_placeholder" + subsystemCounter, dependencyArray, constructor);
    };

    /* not documented.. limbo state*/
    this.factory = function(name, dependencyArray, constructor){
        this.declareDependency(name, dependencyArray, function(){
            return new constructor();
        });
    };

    function callForThing(name, outOfService){
        var args = immediate[name].map(function(item){
            return things[item];
        });
        args.unshift(outOfService);
        try{
            var value = callbacks[name].apply({},args);
        } catch(err){
            errorHandler.throwError(err);
        }


        if(outOfService || value===null){   //enable returning a temporary dependency resolution!
            if(things[name]){
                things[name] = null;
                resetUpCounters(name);
            }
        } else {
            //console.log("Success resolving ", name, ":", value, "Other ready:", otherReady);
            if(!value){
                value =  {"placeholder": name};
            }
            things[name] = value;
            var otherReady = resetUpCounters(name);
            otherReady.forEach(function(item){
                callForThing(item, false);
            });
        }
    }

    /*
        Declare that a name is ready, resolved and should try to resolve all other waiting for it
     */
    this.resolve    = function(name, value){
        things[name] = value;
        var otherReady = resetUpCounters(name);

        otherReady.forEach(function(item){
            callForThing(item, false);
        });
    };



    this.instanceFactory = function(name, dependencyArray, constructor){
        errorHandler.notImplemented("instanceFactory is planned but not implemented");
    };

    /*
        Declare that a service or feature is not working properly. All services depending on this will get notified
     */
    this.outOfService    = function(name){
        things[name] = null;
        var upNodes = discoverUpNodes(name);
        upNodes.forEach(function(node){
            things[name] = null;
            callForThing(node, true);
        });
    };
}


exports.newContainer    = function(checksLibrary){
    return new Container(checksLibrary);
};

//exports.container = new Container($$.errorHandler);
},{}],"domainBase":[function(require,module,exports){
exports.domainPubSub = require("./domainPubSub");
},{"./domainPubSub":"C:\\Users\\Public\\privatesky\\libraries\\domainBase\\domainPubSub.js"}],"double-check":[function(require,module,exports){

/**
 * Generic function used to registers methods such as asserts, logging, etc. on the current context.
 * @param name {String)} - name of the method (use case) to be registered.
 * @param func {Function} - handler to be invoked.
 * @param paramsDescription {Object} - parameters descriptions
 * @param after {Function} - callback function to be called after the function has been executed.
 */
function addUseCase(name, func, paramsDescription, after){
    var newFunc = func;
    if(typeof after === "function") {
        newFunc = function(){
            const args = Array.from(arguments);
            func.apply(this, args);
            after();
        };
    }

    // some properties should not be overridden
    const protectedProperties = [ 'addCheck', 'addCase', 'register' ];
    if(protectedProperties.indexOf(name) === -1){
        this[name] = newFunc;
    } else {
        throw new Error('Cant overwrite ' + name);
    }

    if(paramsDescription){
        this.params[name] = paramsDescription;
    }
}

/**
 * Creates an alias to an existing function.
 * @param name1 {String} - New function name.
 * @param name2 {String} - Existing function name.
 */
function alias(name1, name2){
    this[name1] = this[name2];
}

/**
 * Singleton for adding various functions for use cases regarding logging.
 * @constructor
 */
function LogsCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for asserts.
 * @constructor
 */
function AssertCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for checks.
 * @constructor
 */
function CheckCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for generating exceptions.
 * @constructor
 */
function ExceptionsCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for running tests.
 * @constructor
 */
function TestRunnerCore(){
}

LogsCore.prototype.addCase           = addUseCase;
AssertCore.prototype.addCheck        = addUseCase;
CheckCore.prototype.addCheck         = addUseCase;
ExceptionsCore.prototype.register    = addUseCase;

LogsCore.prototype.alias             = alias;
AssertCore.prototype.alias           = alias;
CheckCore.prototype.alias            = alias;
ExceptionsCore.prototype.alias       = alias;

// Create modules
var assertObj       = new AssertCore();
var checkObj        = new CheckCore();
var exceptionsObj   = new ExceptionsCore();
var loggerObj       = new LogsCore();
var testRunnerObj   = new TestRunnerCore();

// Export modules
exports.assert      = assertObj;
exports.check       = checkObj;
exports.exceptions  = exceptionsObj;
exports.logger      = loggerObj;
exports.testRunner  = testRunnerObj;

// Initialise modules
require("./standardAsserts.js").init(exports, loggerObj);
require("./standardLogs.js").init(exports);
require("./standardExceptions.js").init(exports);
require("./standardChecks.js").init(exports);
require("./testRunner.js").init(exports);

// Global Uncaught Exception handler.
if(process.on)
{
    process.on('uncaughtException', function (err) {
		const tag = "uncaughtException";
		console.log(tag, err);
		console.log(tag, err.stack);
	});
}


var fs = require('fs');
function deleteFolderRecursive(path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function(file, index){
            var curPath = path + "/" + file;
            if (fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath);
            } else { // delete file
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(path);
    }
}

module.exports.deleteFolderRecursive = deleteFolderRecursive;

    module.exports.createTestFolder = function(prefix, cllback){
    fs.mkdtemp(prefix, function(err, res){
        let cleanFolder = function(){
            deleteFolderRecursive(res);
        }
        exports.assert.addCleaningFunction(cleanFolder);
        cllback(err,res);
    });
}
},{"./standardAsserts.js":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardAsserts.js","./standardChecks.js":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardChecks.js","./standardExceptions.js":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardExceptions.js","./standardLogs.js":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\standardLogs.js","./testRunner.js":"C:\\Users\\Public\\privatesky\\modules\\double-check\\lib\\testRunner.js","fs":false}],"foldermq":[function(require,module,exports){
module.exports = {
					createQue: require("./lib/folderMQ").getFolderQueue
					//folderMQ: require("./lib/folderMQ")
};
},{"./lib/folderMQ":"C:\\Users\\Public\\privatesky\\modules\\foldermq\\lib\\folderMQ.js"}],"launcher":[function(require,module,exports){
//console.log(require.resolve("./components.js"));
module.exports = $$.library(function(){
	require("./components.js");
	/*require("./mkDirRec.js");*/
})
},{"./components.js":"C:\\Users\\Public\\privatesky\\libraries\\launcher\\components.js"}],"pskbuffer":[function(require,module,exports){
const PSKBuffer = require('./lib/PSKBuffer');

module.exports = PSKBuffer;

},{"./lib/PSKBuffer":"C:\\Users\\Public\\privatesky\\modules\\pskbuffer\\lib\\PSKBuffer.js"}],"pskcrypto":[function(require,module,exports){
const PskCrypto = require("./lib/PskCrypto");
const ssutil = require("./signsensusDS/ssutil");

module.exports = PskCrypto;

module.exports.hashValues = ssutil.hashValues;

if(typeof(___DISABLE_OBSOLETE_ZIP_ARCHIVER_WAIT_FOR_BARS) === 'undefined'){
    module.exports.PskArchiver = require("./lib/psk-archiver");
}

module.exports.DuplexStream = require("./lib/utils/DuplexStream");

module.exports.isStream = require("./lib/utils/isStream");
},{"./lib/PskCrypto":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\PskCrypto.js","./lib/psk-archiver":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\psk-archiver.js","./lib/utils/DuplexStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\DuplexStream.js","./lib/utils/isStream":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\lib\\utils\\isStream.js","./signsensusDS/ssutil":"C:\\Users\\Public\\privatesky\\modules\\pskcrypto\\signsensusDS\\ssutil.js"}],"psklogger":[function(require,module,exports){
(function (global){
const PSKLogger = require('./src/PSKLoggerClient/index');
const EnvironmentDataProvider = require('./src/utils').EnvironmentDataProvider;


if(!global.hasOwnProperty('$$')) {
    global.$$ = {};
}


/**
 * @deprecated
 * PSKLogger should be used as is without overwriting console.
 * The functionality should be added to PSKLogger to log to console the message and useful metadata
 */
function overwriteConsole() {
    if(process.env.context === 'sandbox') {
        console.log("Execution detected in sandbox, console won't be overwritten");
        return;
    }

    const logger = PSKLogger.getLogger();

    const originalConsole = {};
    Object.keys(console).forEach(key => originalConsole[key] = console[key]);

    Object.keys(logger).forEach(key => {
        if(key != "log") {
            console[key] = function () {

                const log = logger[key].apply(logger, arguments);

                const context = getContextForMeta(log.meta);

                if (originalConsole.hasOwnProperty(key)) {
                    originalConsole[key].apply(originalConsole, [`[${context}]`, ...log.messages]);
                }
            }
        } else {
            console.log = function(...args){
                if(args[0] == undefined) throw new Error("Printing an undefined throws this error");
                //logger.log(...args); ignore console logs... ;)
                const log = logger[key].apply(logger, arguments);
                /*const context = getContextForMeta(log.meta) + " log:\n\r";
                args.unshift(context) */
                originalConsole.log(...args);
            }
        }
    });


    /**
     * @return {string|*}
     */
    function getContextForMeta(meta) {
        const contexts = {
            node: (meta) => `node:${meta.context}`,
            domain: (meta) =>`domain:${meta.domain}`,
            agent: (meta) => `domain:${meta.domain}:agent:${meta.agent}`,
            sandbox: () => `sandbox`
        };

        if (contexts.hasOwnProperty(meta.origin)) {
            return contexts[meta.origin](meta);
        } else {
            return '';
        }
    }
}

if (process.env.context !== 'sandbox') {

    const MessagePublisher = require('./src/MessagePublisher');
    const MessageSubscriber = require('./src/MessageSubscriber');
    const PubSubProxy = require('./src/PubSubProxy');

    function enableEnvironmentDataDefault() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentData;
    }

    function enableEnvironmentDataForAgent() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForAgent;
    }

    function enableEnvironmentDataForDomain() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForDomain;
    }


    /**
     * Overwrite this to provide relevant information for other environments (ex: for domains, browser etc.)
     */
    if(process.env.hasOwnProperty('PRIVATESKY_AGENT_NAME')) {
        enableEnvironmentDataForAgent();
    } else if(process.env.hasOwnProperty('PRIVATESKY_DOMAIN_NAME')) {
        enableEnvironmentDataForDomain()
    } else if(!global.$$.hasOwnProperty('getEnvironmentData')) {
        enableEnvironmentDataDefault();
    }

    module.exports.MessagePublisherModule  = MessagePublisher;
    module.exports.MessageSubscriberModule = MessageSubscriber;
    module.exports.PubSubProxyModule       = PubSubProxy;
} else {
    global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForSandbox;
}


module.exports.overwriteConsole = overwriteConsole;
module.exports.PSKLogger = PSKLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/MessagePublisher":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessagePublisher\\index.js","./src/MessageSubscriber":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\MessageSubscriber\\index.js","./src/PSKLoggerClient/index":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PSKLoggerClient\\index.js","./src/PubSubProxy":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\PubSubProxy\\index.js","./src/utils":"C:\\Users\\Public\\privatesky\\modules\\psklogger\\src\\utils\\index.js"}],"soundpubsub":[function(require,module,exports){
module.exports = {
					soundPubSub: require("./lib/soundPubSub").soundPubSub
};
},{"./lib/soundPubSub":"C:\\Users\\Public\\privatesky\\modules\\soundpubsub\\lib\\soundPubSub.js"}],"swarmutils":[function(require,module,exports){
(function (global){
module.exports.OwM = require("./lib/OwM");
module.exports.beesHealer = require("./lib/beesHealer");

const uidGenerator = require("./lib/uidGenerator").createUidGenerator(200, 32);

module.exports.safe_uuid = require("./lib/safe-uuid").init(uidGenerator);

module.exports.Queue = require("./lib/Queue");
module.exports.combos = require("./lib/Combos");

module.exports.uidGenerator = uidGenerator;
module.exports.generateUid = uidGenerator.generateUid;

module.exports.createPskConsole = function () {
  return require('./lib/pskconsole');
};


if(typeof global.$$ == "undefined"){
  global.$$ = {};
}

if(typeof global.$$.uidGenerator == "undefined"){
    $$.uidGenerator = module.exports.safe_uuid;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/Combos":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\Combos.js","./lib/OwM":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\OwM.js","./lib/Queue":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\Queue.js","./lib/beesHealer":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\beesHealer.js","./lib/pskconsole":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\pskconsole.js","./lib/safe-uuid":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\safe-uuid.js","./lib/uidGenerator":"C:\\Users\\Public\\privatesky\\modules\\swarmutils\\lib\\uidGenerator.js"}],"utils":[function(require,module,exports){
exports.fsExt = require("./FSExtension").fsExt;
},{"./FSExtension":"C:\\Users\\Public\\privatesky\\libraries\\utils\\FSExtension.js"}]},{},["C:\\Users\\Public\\privatesky\\builds\\tmp\\pskruntime.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9kaXN0LmVzNS9tc2dwYWNrLm1pbi5qcyIsImJ1aWxkcy90bXAvcHNrcnVudGltZS5qcyIsImJ1aWxkcy90bXAvcHNrcnVudGltZV9pbnRlcm1lZGlhci5qcyIsImxpYnJhcmllcy9kb21haW5CYXNlL2RvbWFpblB1YlN1Yi5qcyIsImxpYnJhcmllcy9sYXVuY2hlci9jb21wb25lbnRzLmpzIiwibGlicmFyaWVzL3V0aWxzL0ZTRXh0ZW5zaW9uLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9jb25zdGFudHMuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi9JbnRlcmNlcHRvclJlZ2lzdHJ5LmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvY2hvcmVvZ3JhcGhpZXMvU3dhcm1EZWJ1Zy5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL2Nob3Jlb2dyYXBoaWVzL3N3YXJtLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvY2hvcmVvZ3JhcGhpZXMvc3dhcm1JbnN0YW5jZXNNYW5hZ2VyLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvbG9hZExpYnJhcnkuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi9vdmVyd3JpdGVSZXF1aXJlLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvcGFyYWxsZWxKb2luUG9pbnQuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi9zZXJpYWxKb2luUG9pbnQuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi9zd2FybURlc2NyaXB0aW9uLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvdXRpbGl0eUZ1bmN0aW9ucy9hc3NldC5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL3V0aWxpdHlGdW5jdGlvbnMvYmFzZS5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL3V0aWxpdHlGdW5jdGlvbnMvY2FsbGZsb3cuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi91dGlsaXR5RnVuY3Rpb25zL3RyYW5zYWN0aW9uLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9zdGFuZGFyZEdsb2JhbFN5bWJvbHMuanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvc3RhbmRhcmRBc3NlcnRzLmpzIiwibW9kdWxlcy9kb3VibGUtY2hlY2svbGliL3N0YW5kYXJkQ2hlY2tzLmpzIiwibW9kdWxlcy9kb3VibGUtY2hlY2svbGliL3N0YW5kYXJkRXhjZXB0aW9ucy5qcyIsIm1vZHVsZXMvZG91YmxlLWNoZWNrL2xpYi9zdGFuZGFyZExvZ3MuanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvdGVzdFJ1bm5lci5qcyIsIm1vZHVsZXMvZG91YmxlLWNoZWNrL2xpYi91dGlscy9nbG9iLXRvLXJlZ2V4cC5qcyIsIm1vZHVsZXMvZm9sZGVybXEvbGliL2ZvbGRlck1RLmpzIiwibW9kdWxlcy9wc2tidWZmZXIvbGliL1BTS0J1ZmZlci5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9FQ0RTQS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9Qc2tDcnlwdG8uanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9hcGkuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9hc24xLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYmFzZS9idWZmZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9iYXNlL2luZGV4LmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2JpZ251bS9ibi5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2RlY29kZXJzL3BlbS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2tleUVuY29kZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvcHNrLWFyY2hpdmVyLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL3V0aWxzL0R1cGxleFN0cmVhbS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi91dGlscy9QYXNzVGhyb3VnaFN0cmVhbS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi91dGlscy9jb3VudEZpbGVzLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL3V0aWxzL2NyeXB0b1V0aWxzLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL3V0aWxzL2lzU3RyZWFtLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vc2lnbnNlbnN1c0RTL3NzdXRpbC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9Mb2dnZXJDbGllbnQvR2VuZXJpY0xvZ2dlckNsaWVudC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9Mb2dnZXJDbGllbnQvTG9nRmFjdG9yeS5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9Mb2dnZXJDbGllbnQvTG9nZ2VyQ2xpZW50LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL0xvZ2dlckNsaWVudC9Mb2dnZXJJbnRlcmZhY2UuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTG9nZ2VyQ2xpZW50L2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL01lc3NhZ2VQdWJsaXNoZXIvTWVzc2FnZVB1Ymxpc2hlci5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9NZXNzYWdlUHVibGlzaGVyL01lc3NhZ2VQdWJsaXNoZXJGb3JTYW5kYm94LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL01lc3NhZ2VQdWJsaXNoZXIvVHJhbnNwb3J0SW50ZXJmYWNlLmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL01lc3NhZ2VQdWJsaXNoZXIvaW5kZXguanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTWVzc2FnZVN1YnNjcmliZXIvTWVzc2FnZVN1YnNjcmliZXIuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTWVzc2FnZVN1YnNjcmliZXIvaW5kZXguanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvUFNLTG9nZ2VyQ2xpZW50L0dlbmVyaWNQU0tMb2dnZXIuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvUFNLTG9nZ2VyQ2xpZW50L2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL1B1YlN1YlByb3h5L1B1YlN1YlByb3h5LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL1B1YlN1YlByb3h5L2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL3V0aWxzL0J1ZmZlcmVkU29ja2V0LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL3V0aWxzL0NvbmZpZ3VyYXRvci5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9FbnZpcm9ubWVudERhdGFQcm92aWRlci5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9Mb2dMZXZlbC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9Tb2NrZXRUeXBlLmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL3V0aWxzL2luZGV4LmpzIiwibW9kdWxlcy9zb3VuZHB1YnN1Yi9saWIvc291bmRQdWJTdWIuanMiLCJtb2R1bGVzL3N3YXJtdXRpbHMvbGliL0NvbWJvcy5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvT3dNLmpzIiwibW9kdWxlcy9zd2FybXV0aWxzL2xpYi9RdWV1ZS5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvYmVlc0hlYWxlci5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvcHNrY29uc29sZS5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvc2FmZS11dWlkLmpzIiwibW9kdWxlcy9zd2FybXV0aWxzL2xpYi91aWRHZW5lcmF0b3IuanMiLCJwc2tub2RlL2NvcmUvc2FuZGJveGVzL3V0aWwvU2FuZEJveE1hbmFnZXIuanMiLCJwc2tub2RlL2NvcmUvdXRpbHMvZXhpdEhhbmRsZXIuanMiLCJtb2R1bGVzL2NhbGxmbG93L2luZGV4LmpzIiwibW9kdWxlcy9kaWNvbnRhaW5lci9saWIvY29udGFpbmVyLmpzIiwibGlicmFyaWVzL2RvbWFpbkJhc2UvaW5kZXguanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvY2hlY2tzQ29yZS5qcyIsIm1vZHVsZXMvZm9sZGVybXEvaW5kZXguanMiLCJsaWJyYXJpZXMvbGF1bmNoZXIvaW5kZXguanMiLCJtb2R1bGVzL3Bza2J1ZmZlci9pbmRleC5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvaW5kZXguanMiLCJtb2R1bGVzL3NvdW5kcHVic3ViL2luZGV4LmpzIiwibW9kdWxlcy9zd2FybXV0aWxzL2luZGV4LmpzIiwibGlicmFyaWVzL3V0aWxzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5d0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3R0E7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekJBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5NZXNzYWdlUGFjaz10KCk6ZS5NZXNzYWdlUGFjaz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz0wKX0oW2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnIodCk7dmFyIG49ZnVuY3Rpb24oZSx0KXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighcilyZXR1cm4gZTt2YXIgbixpLG89ci5jYWxsKGUpLHM9W107dHJ5e2Zvcig7KHZvaWQgMD09PXR8fHQtLSA+MCkmJiEobj1vLm5leHQoKSkuZG9uZTspcy5wdXNoKG4udmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e24mJiFuLmRvbmUmJihyPW8ucmV0dXJuKSYmci5jYWxsKG8pfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gc30saT1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllPWUuY29uY2F0KG4oYXJndW1lbnRzW3RdKSk7cmV0dXJuIGV9LG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHRFbmNvZGVyJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI7ZnVuY3Rpb24gcyhlKXtmb3IodmFyIHQ9ZS5sZW5ndGgscj0wLG49MDtuPHQ7KXt2YXIgaT1lLmNoYXJDb2RlQXQobisrKTtpZigwIT0oNDI5NDk2NzE2OCZpKSlpZigwPT0oNDI5NDk2NTI0OCZpKSlyKz0yO2Vsc2V7aWYoaT49NTUyOTYmJmk8PTU2MzE5JiZuPHQpe3ZhciBvPWUuY2hhckNvZGVBdChuKTs1NjMyMD09KDY0NTEyJm8pJiYoKytuLGk9KCgxMDIzJmkpPDwxMCkrKDEwMjMmbykrNjU1MzYpfXIrPTA9PSg0Mjk0OTAxNzYwJmkpPzM6NH1lbHNlIHIrK31yZXR1cm4gcn12YXIgYT1vP25ldyBUZXh0RW5jb2Rlcjp2b2lkIDA7dmFyIGg9YSYmYS5lbmNvZGVJbnRvP2Z1bmN0aW9uKGUsdCxyKXthLmVuY29kZUludG8oZSx0LnN1YmFycmF5KHIpKX06ZnVuY3Rpb24oZSx0LHIpe3Quc2V0KGEuZW5jb2RlKGUpLHIpfSx1PTY1NTM2O2Z1bmN0aW9uIGMoZSx0LHIpe2Zvcih2YXIgbj10LG89bityLHM9W10sYT1cIlwiO248bzspe3ZhciBoPWVbbisrXTtpZigwPT0oMTI4JmgpKXMucHVzaChoKTtlbHNlIGlmKDE5Mj09KDIyNCZoKSl7dmFyIGM9NjMmZVtuKytdO3MucHVzaCgoMzEmaCk8PDZ8Yyl9ZWxzZSBpZigyMjQ9PSgyNDAmaCkpe2M9NjMmZVtuKytdO3ZhciBmPTYzJmVbbisrXTtzLnB1c2goKDMxJmgpPDwxMnxjPDw2fGYpfWVsc2UgaWYoMjQwPT0oMjQ4JmgpKXt2YXIgbD0oNyZoKTw8MTh8KGM9NjMmZVtuKytdKTw8MTJ8KGY9NjMmZVtuKytdKTw8Nnw2MyZlW24rK107bD42NTUzNSYmKGwtPTY1NTM2LHMucHVzaChsPj4+MTAmMTAyM3w1NTI5NiksbD01NjMyMHwxMDIzJmwpLHMucHVzaChsKX1lbHNlIHMucHVzaChoKTtzLmxlbmd0aC00Pj11JiYoYSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaShzKSkscy5sZW5ndGg9MCl9cmV0dXJuIHMubGVuZ3RoPjAmJihhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKHMpKSksYX12YXIgZj1vP25ldyBUZXh0RGVjb2RlcjpudWxsO3ZhciBsPWZ1bmN0aW9uKGUsdCl7dGhpcy50eXBlPWUsdGhpcy5kYXRhPXR9O2Z1bmN0aW9uIHAoZSx0LHIpe3ZhciBuPU1hdGguZmxvb3Ioci80Mjk0OTY3Mjk2KSxpPXI7ZS5zZXRVaW50MzIodCxuKSxlLnNldFVpbnQzMih0KzQsaSl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiA0Mjk0OTY3Mjk2KmUuZ2V0SW50MzIodCkrZS5nZXRVaW50MzIodCs0KX12YXIgeT00Mjk0OTY3Mjk1LHc9MTcxNzk4NjkxODM7ZnVuY3Rpb24gdihlKXt2YXIgdD1lLnNlYyxyPWUubnNlYztpZih0Pj0wJiZyPj0wJiZ0PD13KXtpZigwPT09ciYmdDw9eSl7dmFyIG49bmV3IFVpbnQ4QXJyYXkoNCk7cmV0dXJuKHM9bmV3IERhdGFWaWV3KG4uYnVmZmVyKSkuc2V0VWludDMyKDAsdCksbn12YXIgaT10LzQyOTQ5NjcyOTYsbz00Mjk0OTY3Mjk1JnQ7bj1uZXcgVWludDhBcnJheSg4KTtyZXR1cm4ocz1uZXcgRGF0YVZpZXcobi5idWZmZXIpKS5zZXRVaW50MzIoMCxyPDwyfDMmaSkscy5zZXRVaW50MzIoNCxvKSxufXZhciBzO249bmV3IFVpbnQ4QXJyYXkoMTIpO3JldHVybihzPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcikpLnNldFVpbnQzMigwLHIpLHAocyw0LHQpLG59ZnVuY3Rpb24gZyhlKXt2YXIgdD1lLmdldFRpbWUoKSxyPU1hdGguZmxvb3IodC8xZTMpLG49MWU2Kih0LTFlMypyKSxpPU1hdGguZmxvb3Iobi8xZTkpO3JldHVybntzZWM6citpLG5zZWM6bi0xZTkqaX19ZnVuY3Rpb24gYihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERhdGU/dihnKGUpKTpudWxsfWZ1bmN0aW9uIG0oZSl7dmFyIHQ9bmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpO3N3aXRjaChlLmJ5dGVMZW5ndGgpe2Nhc2UgNDpyZXR1cm57c2VjOnQuZ2V0VWludDMyKDApLG5zZWM6MH07Y2FzZSA4OnZhciByPXQuZ2V0VWludDMyKDApO3JldHVybntzZWM6NDI5NDk2NzI5NiooMyZyKSt0LmdldFVpbnQzMig0KSxuc2VjOnI+Pj4yfTtjYXNlIDEyOnJldHVybntzZWM6ZCh0LDQpLG5zZWM6dC5nZXRVaW50MzIoMCl9O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgc2l6ZSBmb3IgdGltZXN0YW1wOiBcIitlLmxlbmd0aCl9fWZ1bmN0aW9uIFUoZSl7dmFyIHQ9bShlKTtyZXR1cm4gbmV3IERhdGUoMWUzKnQuc2VjK3QubnNlYy8xZTYpfXZhciB4PXt0eXBlOi0xLGVuY29kZTpiLGRlY29kZTpVfSxTPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMuYnVpbHRJbkVuY29kZXJzPVtdLHRoaXMuYnVpbHRJbkRlY29kZXJzPVtdLHRoaXMuZW5jb2RlcnM9W10sdGhpcy5kZWNvZGVycz1bXSx0aGlzLnJlZ2lzdGVyKHgpfXJldHVybiBlLnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihlKXt2YXIgdD1lLnR5cGUscj1lLmVuY29kZSxuPWUuZGVjb2RlO2lmKHQ+PTApdGhpcy5lbmNvZGVyc1t0XT1yLHRoaXMuZGVjb2RlcnNbdF09bjtlbHNle3ZhciBpPTErdDt0aGlzLmJ1aWx0SW5FbmNvZGVyc1tpXT1yLHRoaXMuYnVpbHRJbkRlY29kZXJzW2ldPW59fSxlLnByb3RvdHlwZS50cnlUb0VuY29kZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PHRoaXMuYnVpbHRJbkVuY29kZXJzLmxlbmd0aDt0Kyspe2lmKG51bGwhPShyPXRoaXMuYnVpbHRJbkVuY29kZXJzW3RdKSlpZihudWxsIT0obj1yKGUpKSlyZXR1cm4gbmV3IGwoLTEtdCxuKX1mb3IodD0wO3Q8dGhpcy5lbmNvZGVycy5sZW5ndGg7dCsrKXt2YXIgcixuO2lmKG51bGwhPShyPXRoaXMuZW5jb2RlcnNbdF0pKWlmKG51bGwhPShuPXIoZSkpKXJldHVybiBuZXcgbCh0LG4pfXJldHVybiBlIGluc3RhbmNlb2YgbD9lOm51bGx9LGUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3ZhciByPXQ8MD90aGlzLmJ1aWx0SW5EZWNvZGVyc1stMS10XTp0aGlzLmRlY29kZXJzW3RdO3JldHVybiByP3IoZSx0KTpuZXcgbCh0LGUpfSxlLmRlZmF1bHRDb2RlYz1uZXcgZSxlfSgpO2Z1bmN0aW9uIEUoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6QXJyYXlCdWZmZXIuaXNWaWV3KGUpP25ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpOmUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9uZXcgVWludDhBcnJheShlKTpVaW50OEFycmF5LmZyb20oZSl9dmFyIEI9bnVsbCxBPSEhQjtmdW5jdGlvbiBMKGUsdCxyKXt2YXIgbj1lLmxlbmd0aCxpPTIqbixvPUIubWFsbG9jKGkpOyFmdW5jdGlvbihlLHQscixuKXtmb3IodmFyIGk9bmV3IERhdGFWaWV3KEIubWVtb3J5LmJ1ZmZlcixlLHQpLG89MDtvPG47bysrKWkuc2V0VWludDE2KDIqbyxyLmNoYXJDb2RlQXQobykpfShvLGksZSxuKTt2YXIgcz1CLm1hbGxvYyg1KzQqbik7dHJ5e3ZhciBhPUIudXRmOEVuY29kZVVpbnQxNkFycmF5KHMsbyxuKTtyZXR1cm4gdC5zZXQobmV3IFVpbnQ4QXJyYXkoQi5tZW1vcnkuYnVmZmVyLHMsYSksciksYX1maW5hbGx5e0IuZnJlZShvKSxCLmZyZWUocyl9fXZhciBJPTY1NTM2O2Z1bmN0aW9uIFQoZSx0LHIpe3ZhciBuLGksbyxzPUIubWFsbG9jKHIpLGE9Qi5tYWxsb2MoMipyKTt0cnl7bj1zLGk9ZS5zdWJhcnJheSh0LHQrciksbz1yLG5ldyBVaW50OEFycmF5KEIubWVtb3J5LmJ1ZmZlcixuLG8pLnNldChpKTt2YXIgaD1CLnV0ZjhEZWNvZGVUb1VpbnQxNkFycmF5KGEscyxyKTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoZS5sZW5ndGg8PUkpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpO2Zvcih2YXIgdD1cIlwiLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49ZS5zdWJhcnJheShyKkksKHIrMSkqSSk7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbil9cmV0dXJuIHR9KG5ldyBVaW50MTZBcnJheShCLm1lbW9yeS5idWZmZXIsYSxoKSl9ZmluYWxseXtCLmZyZWUocyksQi5mcmVlKGEpfX12YXIgaz1mdW5jdGlvbihlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXSxyPTA7cmV0dXJuIHQ/dC5jYWxsKGUpOntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGUmJnI+PWUubGVuZ3RoJiYoZT12b2lkIDApLHt2YWx1ZTplJiZlW3IrK10sZG9uZTohZX19fX0sTT0xMDAsej0yMDQ4LEM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxyLG4saSl7dm9pZCAwPT09ZSYmKGU9Uy5kZWZhdWx0Q29kZWMpLHZvaWQgMD09PXQmJih0PU0pLHZvaWQgMD09PXImJihyPXopLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1pJiYoaT0hMSksdGhpcy5leHRlbnNpb25Db2RlYz1lLHRoaXMubWF4RGVwdGg9dCx0aGlzLmluaXRpYWxCdWZmZXJTaXplPXIsdGhpcy5zb3J0S2V5cz1uLHRoaXMuZm9yY2VGbG9hdDMyPWksdGhpcy5wb3M9MCx0aGlzLnZpZXc9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih0aGlzLmluaXRpYWxCdWZmZXJTaXplKSksdGhpcy5ieXRlcz1uZXcgVWludDhBcnJheSh0aGlzLnZpZXcuYnVmZmVyKX1yZXR1cm4gZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodD50aGlzLm1heERlcHRoKXRocm93IG5ldyBFcnJvcihcIlRvbyBkZWVwIG9iamVjdHMgaW4gZGVwdGggXCIrdCk7bnVsbD09ZT90aGlzLmVuY29kZU5pbCgpOlwiYm9vbGVhblwiPT10eXBlb2YgZT90aGlzLmVuY29kZUJvb2xlYW4oZSk6XCJudW1iZXJcIj09dHlwZW9mIGU/dGhpcy5lbmNvZGVOdW1iZXIoZSk6XCJzdHJpbmdcIj09dHlwZW9mIGU/dGhpcy5lbmNvZGVTdHJpbmcoZSk6dGhpcy5lbmNvZGVPYmplY3QoZSx0KX0sZS5wcm90b3R5cGUuZ2V0VWludDhBcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KDAsdGhpcy5wb3MpfSxlLnByb3RvdHlwZS5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBvcytlO3RoaXMudmlldy5ieXRlTGVuZ3RoPHQmJnRoaXMucmVzaXplQnVmZmVyKDIqdCl9LGUucHJvdG90eXBlLnJlc2l6ZUJ1ZmZlcj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXlCdWZmZXIoZSkscj1uZXcgVWludDhBcnJheSh0KSxuPW5ldyBEYXRhVmlldyh0KTtyLnNldCh0aGlzLmJ5dGVzKSx0aGlzLnZpZXc9bix0aGlzLmJ5dGVzPXJ9LGUucHJvdG90eXBlLmVuY29kZU5pbD1mdW5jdGlvbigpe3RoaXMud3JpdGVVOCgxOTIpfSxlLnByb3RvdHlwZS5lbmNvZGVCb29sZWFuPWZ1bmN0aW9uKGUpeyExPT09ZT90aGlzLndyaXRlVTgoMTk0KTp0aGlzLndyaXRlVTgoMTk1KX0sZS5wcm90b3R5cGUuZW5jb2RlTnVtYmVyPWZ1bmN0aW9uKGUpe051bWJlci5pc1NhZmVJbnRlZ2VyKGUpP2U+PTA/ZTwxMjg/dGhpcy53cml0ZVU4KGUpOmU8MjU2Pyh0aGlzLndyaXRlVTgoMjA0KSx0aGlzLndyaXRlVTgoZSkpOmU8NjU1MzY/KHRoaXMud3JpdGVVOCgyMDUpLHRoaXMud3JpdGVVMTYoZSkpOmU8NDI5NDk2NzI5Nj8odGhpcy53cml0ZVU4KDIwNiksdGhpcy53cml0ZVUzMihlKSk6KHRoaXMud3JpdGVVOCgyMDcpLHRoaXMud3JpdGVVNjQoZSkpOmU+PS0zMj90aGlzLndyaXRlVTgoMjI0fGUrMzIpOmU+PS0xMjg/KHRoaXMud3JpdGVVOCgyMDgpLHRoaXMud3JpdGVJOChlKSk6ZT49LTMyNzY4Pyh0aGlzLndyaXRlVTgoMjA5KSx0aGlzLndyaXRlSTE2KGUpKTplPj0tMjE0NzQ4MzY0OD8odGhpcy53cml0ZVU4KDIxMCksdGhpcy53cml0ZUkzMihlKSk6KHRoaXMud3JpdGVVOCgyMTEpLHRoaXMud3JpdGVJNjQoZSkpOnRoaXMuZm9yY2VGbG9hdDMyPyh0aGlzLndyaXRlVTgoMjAyKSx0aGlzLndyaXRlRjMyKGUpKToodGhpcy53cml0ZVU4KDIwMyksdGhpcy53cml0ZUY2NChlKSl9LGUucHJvdG90eXBlLndyaXRlU3RyaW5nSGVhZGVyPWZ1bmN0aW9uKGUpe2lmKGU8MzIpdGhpcy53cml0ZVU4KDE2MCtlKTtlbHNlIGlmKGU8MjU2KXRoaXMud3JpdGVVOCgyMTcpLHRoaXMud3JpdGVVOChlKTtlbHNlIGlmKGU8NjU1MzYpdGhpcy53cml0ZVU4KDIxOCksdGhpcy53cml0ZVUxNihlKTtlbHNle2lmKCEoZTw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbG9uZyBzdHJpbmc6IFwiK2UrXCIgYnl0ZXMgaW4gVVRGLThcIik7dGhpcy53cml0ZVU4KDIxOSksdGhpcy53cml0ZVUzMihlKX19LGUucHJvdG90eXBlLmVuY29kZVN0cmluZz1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZihvJiZ0PjIwMCl7dmFyIHI9cyhlKTt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDUrciksdGhpcy53cml0ZVN0cmluZ0hlYWRlcihyKSxoKGUsdGhpcy5ieXRlcyx0aGlzLnBvcyksdGhpcy5wb3MrPXJ9ZWxzZXtpZihBJiZ0PjEwMjQpe3ZhciBuPTUrNCp0O3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUobik7dmFyIGk9TChlLHRoaXMuYnl0ZXMsdGhpcy5wb3MpO3JldHVybiB2b2lkKHRoaXMucG9zKz1pKX1yPXMoZSk7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg1K3IpLHRoaXMud3JpdGVTdHJpbmdIZWFkZXIociksZnVuY3Rpb24oZSx0LHIpe2Zvcih2YXIgbj1lLmxlbmd0aCxpPXIsbz0wO288bjspe3ZhciBzPWUuY2hhckNvZGVBdChvKyspO2lmKDAhPSg0Mjk0OTY3MTY4JnMpKXtpZigwPT0oNDI5NDk2NTI0OCZzKSl0W2krK109cz4+NiYzMXwxOTI7ZWxzZXtpZihzPj01NTI5NiYmczw9NTYzMTkmJm88bil7dmFyIGE9ZS5jaGFyQ29kZUF0KG8pOzU2MzIwPT0oNjQ1MTImYSkmJigrK28scz0oKDEwMjMmcyk8PDEwKSsoMTAyMyZhKSs2NTUzNil9MD09KDQyOTQ5MDE3NjAmcyk/KHRbaSsrXT1zPj4xMiYxNXwyMjQsdFtpKytdPXM+PjYmNjN8MTI4KToodFtpKytdPXM+PjE4Jjd8MjQwLHRbaSsrXT1zPj4xMiY2M3wxMjgsdFtpKytdPXM+PjYmNjN8MTI4KX10W2krK109NjMmc3wxMjh9ZWxzZSB0W2krK109c319KGUsdGhpcy5ieXRlcyx0aGlzLnBvcyksdGhpcy5wb3MrPXJ9fSxlLnByb3RvdHlwZS5lbmNvZGVPYmplY3Q9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmV4dGVuc2lvbkNvZGVjLnRyeVRvRW5jb2RlKGUpO2lmKG51bGwhPXIpdGhpcy5lbmNvZGVFeHRlbnNpb24ocik7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXRoaXMuZW5jb2RlQXJyYXkoZSx0KTtlbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl0aGlzLmVuY29kZUJpbmFyeShlKTtlbHNle2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBvYmplY3Q6IFwiK09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoZSkpO3RoaXMuZW5jb2RlTWFwKGUsdCl9fSxlLnByb3RvdHlwZS5lbmNvZGVCaW5hcnk9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ieXRlTGVuZ3RoO2lmKHQ8MjU2KXRoaXMud3JpdGVVOCgxOTYpLHRoaXMud3JpdGVVOCh0KTtlbHNlIGlmKHQ8NjU1MzYpdGhpcy53cml0ZVU4KDE5NyksdGhpcy53cml0ZVUxNih0KTtlbHNle2lmKCEodDw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGFyZ2UgYmluYXJ5OiBcIit0KTt0aGlzLndyaXRlVTgoMTk4KSx0aGlzLndyaXRlVTMyKHQpfXZhciByPUUoZSk7dGhpcy53cml0ZVU4YShyKX0sZS5wcm90b3R5cGUuZW5jb2RlQXJyYXk9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9ZS5sZW5ndGg7aWYoaTwxNil0aGlzLndyaXRlVTgoMTQ0K2kpO2Vsc2UgaWYoaTw2NTUzNil0aGlzLndyaXRlVTgoMjIwKSx0aGlzLndyaXRlVTE2KGkpO2Vsc2V7aWYoIShpPDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBhcnJheTogXCIraSk7dGhpcy53cml0ZVU4KDIyMSksdGhpcy53cml0ZVUzMihpKX10cnl7Zm9yKHZhciBvPWsoZSkscz1vLm5leHQoKTshcy5kb25lO3M9by5uZXh0KCkpe3ZhciBhPXMudmFsdWU7dGhpcy5lbmNvZGUoYSx0KzEpfX1jYXRjaChlKXtyPXtlcnJvcjplfX1maW5hbGx5e3RyeXtzJiYhcy5kb25lJiYobj1vLnJldHVybikmJm4uY2FsbChvKX1maW5hbGx5e2lmKHIpdGhyb3cgci5lcnJvcn19fSxlLnByb3RvdHlwZS5lbmNvZGVNYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTt0aGlzLnNvcnRLZXlzJiZyLnNvcnQoKTt2YXIgbj1yLmxlbmd0aDtpZihuPDE2KXRoaXMud3JpdGVVOCgxMjgrbik7ZWxzZSBpZihuPDY1NTM2KXRoaXMud3JpdGVVOCgyMjIpLHRoaXMud3JpdGVVMTYobik7ZWxzZXtpZighKG48NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIG1hcCBvYmplY3Q6IFwiK24pO3RoaXMud3JpdGVVOCgyMjMpLHRoaXMud3JpdGVVMzIobil9Zm9yKHZhciBpPTA7aTxuO2krKyl7dmFyIG89cltpXTt0aGlzLmVuY29kZVN0cmluZyhvKSx0aGlzLmVuY29kZShlW29dLHQrMSl9fSxlLnByb3RvdHlwZS5lbmNvZGVFeHRlbnNpb249ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kYXRhLmxlbmd0aDtpZigxPT09dCl0aGlzLndyaXRlVTgoMjEyKTtlbHNlIGlmKDI9PT10KXRoaXMud3JpdGVVOCgyMTMpO2Vsc2UgaWYoND09PXQpdGhpcy53cml0ZVU4KDIxNCk7ZWxzZSBpZig4PT09dCl0aGlzLndyaXRlVTgoMjE1KTtlbHNlIGlmKDE2PT09dCl0aGlzLndyaXRlVTgoMjE2KTtlbHNlIGlmKHQ8MjU2KXRoaXMud3JpdGVVOCgxOTkpLHRoaXMud3JpdGVVOCh0KTtlbHNlIGlmKHQ8NjU1MzYpdGhpcy53cml0ZVU4KDIwMCksdGhpcy53cml0ZVUxNih0KTtlbHNle2lmKCEodDw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGFyZ2UgZXh0ZW5zaW9uIG9iamVjdDogXCIrdCk7dGhpcy53cml0ZVU4KDIwMSksdGhpcy53cml0ZVUzMih0KX10aGlzLndyaXRlSTgoZS50eXBlKSx0aGlzLndyaXRlVThhKGUuZGF0YSl9LGUucHJvdG90eXBlLndyaXRlVTg9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgxKSx0aGlzLnZpZXcuc2V0VWludDgodGhpcy5wb3MsZSksdGhpcy5wb3MrK30sZS5wcm90b3R5cGUud3JpdGVVOGE9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSh0KSx0aGlzLmJ5dGVzLnNldChlLHRoaXMucG9zKSx0aGlzLnBvcys9dH0sZS5wcm90b3R5cGUud3JpdGVJOD1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDEpLHRoaXMudmlldy5zZXRJbnQ4KHRoaXMucG9zLGUpLHRoaXMucG9zKyt9LGUucHJvdG90eXBlLndyaXRlVTE2PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMiksdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLnBvcyxlKSx0aGlzLnBvcys9Mn0sZS5wcm90b3R5cGUud3JpdGVJMTY9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgyKSx0aGlzLnZpZXcuc2V0SW50MTYodGhpcy5wb3MsZSksdGhpcy5wb3MrPTJ9LGUucHJvdG90eXBlLndyaXRlVTMyPWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCksdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLnBvcyxlKSx0aGlzLnBvcys9NH0sZS5wcm90b3R5cGUud3JpdGVJMzI9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KSx0aGlzLnZpZXcuc2V0SW50MzIodGhpcy5wb3MsZSksdGhpcy5wb3MrPTR9LGUucHJvdG90eXBlLndyaXRlRjMyPWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCksdGhpcy52aWV3LnNldEZsb2F0MzIodGhpcy5wb3MsZSksdGhpcy5wb3MrPTR9LGUucHJvdG90eXBlLndyaXRlRjY0PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCksdGhpcy52aWV3LnNldEZsb2F0NjQodGhpcy5wb3MsZSksdGhpcy5wb3MrPTh9LGUucHJvdG90eXBlLndyaXRlVTY0PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCksZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIvNDI5NDk2NzI5NixpPXI7ZS5zZXRVaW50MzIodCxuKSxlLnNldFVpbnQzMih0KzQsaSl9KHRoaXMudmlldyx0aGlzLnBvcyxlKSx0aGlzLnBvcys9OH0sZS5wcm90b3R5cGUud3JpdGVJNjQ9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KSxwKHRoaXMudmlldyx0aGlzLnBvcyxlKSx0aGlzLnBvcys9OH0sZX0oKSxEPXt9O2Z1bmN0aW9uIFAoZSx0KXt2b2lkIDA9PT10JiYodD1EKTt2YXIgcj1uZXcgQyh0LmV4dGVuc2lvbkNvZGVjLHQubWF4RGVwdGgsdC5pbml0aWFsQnVmZmVyU2l6ZSx0LnNvcnRLZXlzLHQuZm9yY2VGbG9hdDMyKTtyZXR1cm4gci5lbmNvZGUoZSwxKSxyLmdldFVpbnQ4QXJyYXkoKX1mdW5jdGlvbiBqKGUpe3JldHVybihlPDA/XCItXCI6XCJcIikrXCIweFwiK01hdGguYWJzKGUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLFwiMFwiKX12YXIgRj0xNixXPTE2LE89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dm9pZCAwPT09ZSYmKGU9Riksdm9pZCAwPT09dCYmKHQ9VyksdGhpcy5tYXhLZXlMZW5ndGg9ZSx0aGlzLm1heExlbmd0aFBlcktleT10LHRoaXMuY2FjaGVzPVtdO2Zvcih2YXIgcj0wO3I8dGhpcy5tYXhLZXlMZW5ndGg7cisrKXRoaXMuY2FjaGVzLnB1c2goW10pfXJldHVybiBlLnByb3RvdHlwZS5jYW5CZUNhY2hlZD1mdW5jdGlvbihlKXtyZXR1cm4gZT4wJiZlPD10aGlzLm1heEtleUxlbmd0aH0sZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmNhY2hlc1tyLTFdLGk9bi5sZW5ndGg7ZTpmb3IodmFyIG89MDtvPGk7bysrKXtmb3IodmFyIHM9bltvXSxhPXMuYnl0ZXMsaD0wO2g8cjtoKyspaWYoYVtoXSE9PWVbdCtoXSljb250aW51ZSBlO3JldHVybiBzLnZhbHVlfXJldHVybiBudWxsfSxlLnByb3RvdHlwZS5zdG9yZT1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuY2FjaGVzW2UubGVuZ3RoLTFdLG49e2J5dGVzOmUsdmFsdWU6dH07ci5sZW5ndGg+PXRoaXMubWF4TGVuZ3RoUGVyS2V5P3JbTWF0aC5yYW5kb20oKSpyLmxlbmd0aHwwXT1uOnIucHVzaChuKX0sZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmdldChlLHQscik7aWYobilyZXR1cm4gbjt2YXIgaT1jKGUsdCxyKSxvPVVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSx0LHQrcik7cmV0dXJuIHRoaXMuc3RvcmUobyxpKSxpfSxlfSgpLF89ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBzKGUpe3RyeXtoKG4ubmV4dChlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gYShlKXt0cnl7aChuLnRocm93KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiBoKGUpe2UuZG9uZT9pKGUudmFsdWUpOm5ldyByKGZ1bmN0aW9uKHQpe3QoZS52YWx1ZSl9KS50aGVuKHMsYSl9aCgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9LEs9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX0sVj1mdW5jdGlvbihlKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgdCxyPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO3JldHVybiByP3IuY2FsbChlKTooZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfX3ZhbHVlcz9fX3ZhbHVlcyhlKTplW1N5bWJvbC5pdGVyYXRvcl0oKSx0PXt9LG4oXCJuZXh0XCIpLG4oXCJ0aHJvd1wiKSxuKFwicmV0dXJuXCIpLHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQpO2Z1bmN0aW9uIG4ocil7dFtyXT1lW3JdJiZmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixpKXsoZnVuY3Rpb24oZSx0LHIsbil7UHJvbWlzZS5yZXNvbHZlKG4pLnRoZW4oZnVuY3Rpb24odCl7ZSh7dmFsdWU6dCxkb25lOnJ9KX0sdCl9KShuLGksKHQ9ZVtyXSh0KSkuZG9uZSx0LnZhbHVlKX0pfX19LE49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBOPyh0aGlzLnY9ZSx0aGlzKTpuZXcgTihlKX0sUj1mdW5jdGlvbihlLHQscil7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIG4saT1yLmFwcGx5KGUsdHx8W10pLG89W107cmV0dXJuIG49e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksbltTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGUpe2lbZV0mJihuW2VdPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG4pe28ucHVzaChbZSx0LHIsbl0pPjF8fGEoZSx0KX0pfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIE4/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihoLHUpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gaChlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIHUoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fSxIPS0xLEc9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksWD1uZXcgVWludDhBcnJheShHLmJ1ZmZlcikscT1mdW5jdGlvbigpe3RyeXtHLmdldEludDgoMCl9Y2F0Y2goZSl7cmV0dXJuIGUuY29uc3RydWN0b3J9dGhyb3cgbmV3IEVycm9yKFwibmV2ZXIgcmVhY2hlZFwiKX0oKSxKPW5ldyBxKFwiSW5zdWZmaWNpZW50IGRhdGFcIiksUT00Mjk0OTY3Mjk1LFk9bmV3IE8sWj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixpLG8pe3ZvaWQgMD09PWUmJihlPVMuZGVmYXVsdENvZGVjKSx2b2lkIDA9PT10JiYodD1RKSx2b2lkIDA9PT1yJiYocj1RKSx2b2lkIDA9PT1uJiYobj1RKSx2b2lkIDA9PT1pJiYoaT1RKSx2b2lkIDA9PT1vJiYobz1RKSx0aGlzLmV4dGVuc2lvbkNvZGVjPWUsdGhpcy5tYXhTdHJMZW5ndGg9dCx0aGlzLm1heEJpbkxlbmd0aD1yLHRoaXMubWF4QXJyYXlMZW5ndGg9bix0aGlzLm1heE1hcExlbmd0aD1pLHRoaXMubWF4RXh0TGVuZ3RoPW8sdGhpcy50b3RhbFBvcz0wLHRoaXMucG9zPTAsdGhpcy52aWV3PUcsdGhpcy5ieXRlcz1YLHRoaXMuaGVhZEJ5dGU9SCx0aGlzLnN0YWNrPVtdLHRoaXMuY2FjaGVkS2V5RGVjb2Rlcj1ZfXJldHVybiBlLnByb3RvdHlwZS5zZXRCdWZmZXI9ZnVuY3Rpb24oZSl7dGhpcy5ieXRlcz1FKGUpLHRoaXMudmlldz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpcmV0dXJuIG5ldyBEYXRhVmlldyhlKTt2YXIgdD1FKGUpO3JldHVybiBuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCl9KHRoaXMuYnl0ZXMpLHRoaXMucG9zPTB9LGUucHJvdG90eXBlLmFwcGVuZEJ1ZmZlcj1mdW5jdGlvbihlKXtpZih0aGlzLmhlYWRCeXRlIT09SHx8dGhpcy5oYXNSZW1haW5pbmcoKSl7dmFyIHQ9dGhpcy5ieXRlcy5zdWJhcnJheSh0aGlzLnBvcykscj1FKGUpLG49bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgrci5sZW5ndGgpO24uc2V0KHQpLG4uc2V0KHIsdC5sZW5ndGgpLHRoaXMuc2V0QnVmZmVyKG4pfWVsc2UgdGhpcy5zZXRCdWZmZXIoZSl9LGUucHJvdG90eXBlLmhhc1JlbWFpbmluZz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MSksdGhpcy52aWV3LmJ5dGVMZW5ndGgtdGhpcy5wb3M+PWV9LGUucHJvdG90eXBlLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMudmlldyxyPXRoaXMucG9zO3JldHVybiBuZXcgUmFuZ2VFcnJvcihcIkV4dHJhIFwiKyh0LmJ5dGVMZW5ndGgtcikrXCIgYnl0ZShzKSBmb3VuZCBhdCBidWZmZXJbXCIrZStcIl1cIil9LGUucHJvdG90eXBlLmRlY29kZVNpbmdsZVN5bmM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRlY29kZVN5bmMoKTtpZih0aGlzLmhhc1JlbWFpbmluZygpKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy5wb3MpO3JldHVybiBlfSxlLnByb3RvdHlwZS5kZWNvZGVTaW5nbGVBc3luYz1mdW5jdGlvbihlKXt2YXIgdCxyLG4saTtyZXR1cm4gXyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbyxzLGEsaCx1LGMsZixsO3JldHVybiBLKHRoaXMsZnVuY3Rpb24ocCl7c3dpdGNoKHAubGFiZWwpe2Nhc2UgMDpvPSExLHAubGFiZWw9MTtjYXNlIDE6cC50cnlzLnB1c2goWzEsNiw3LDEyXSksdD1WKGUpLHAubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsdC5uZXh0KCldO2Nhc2UgMzppZigocj1wLnNlbnQoKSkuZG9uZSlyZXR1cm5bMyw1XTtpZihhPXIudmFsdWUsbyl0aHJvdyB0aGlzLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yKHRoaXMudG90YWxQb3MpO3RoaXMuYXBwZW5kQnVmZmVyKGEpO3RyeXtzPXRoaXMuZGVjb2RlU3luYygpLG89ITB9Y2F0Y2goZSl7aWYoIShlIGluc3RhbmNlb2YgcSkpdGhyb3cgZX10aGlzLnRvdGFsUG9zKz10aGlzLnBvcyxwLmxhYmVsPTQ7Y2FzZSA0OnJldHVyblszLDJdO2Nhc2UgNTpyZXR1cm5bMywxMl07Y2FzZSA2OnJldHVybiBoPXAuc2VudCgpLG49e2Vycm9yOmh9LFszLDEyXTtjYXNlIDc6cmV0dXJuIHAudHJ5cy5wdXNoKFs3LCwxMCwxMV0pLHImJiFyLmRvbmUmJihpPXQucmV0dXJuKT9bNCxpLmNhbGwodCldOlszLDldO2Nhc2UgODpwLnNlbnQoKSxwLmxhYmVsPTk7Y2FzZSA5OnJldHVyblszLDExXTtjYXNlIDEwOmlmKG4pdGhyb3cgbi5lcnJvcjtyZXR1cm5bN107Y2FzZSAxMTpyZXR1cm5bN107Y2FzZSAxMjppZihvKXtpZih0aGlzLmhhc1JlbWFpbmluZygpKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy50b3RhbFBvcyk7cmV0dXJuWzIsc119dGhyb3cgYz0odT10aGlzKS5oZWFkQnl0ZSxmPXUucG9zLGw9dS50b3RhbFBvcyxuZXcgUmFuZ2VFcnJvcihcIkluc3VmZmljaWVudCBkYXRhIGluIHBhcmNpbmcgXCIraihjKStcIiBhdCBcIitsK1wiIChcIitmK1wiIGluIHRoZSBjdXJyZW50IGJ1ZmZlcilcIil9fSl9KX0sZS5wcm90b3R5cGUuZGVjb2RlQXJyYXlTdHJlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGVjb2RlTXVsdGlBc3luYyhlLCEwKX0sZS5wcm90b3R5cGUuZGVjb2RlU3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRlY29kZU11bHRpQXN5bmMoZSwhMSl9LGUucHJvdG90eXBlLmRlY29kZU11bHRpQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUih0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbigpe3ZhciByLG4saSxvLHMsYSxoLHUsYztyZXR1cm4gSyh0aGlzLGZ1bmN0aW9uKGYpe3N3aXRjaChmLmxhYmVsKXtjYXNlIDA6cj10LG49LTEsZi5sYWJlbD0xO2Nhc2UgMTpmLnRyeXMucHVzaChbMSwxMywxNCwxOV0pLGk9VihlKSxmLmxhYmVsPTI7Y2FzZSAyOnJldHVybls0LE4oaS5uZXh0KCkpXTtjYXNlIDM6aWYoKG89Zi5zZW50KCkpLmRvbmUpcmV0dXJuWzMsMTJdO2lmKHM9by52YWx1ZSx0JiYwPT09bil0aHJvdyB0aGlzLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yKHRoaXMudG90YWxQb3MpO3RoaXMuYXBwZW5kQnVmZmVyKHMpLHImJihuPXRoaXMucmVhZEFycmF5U2l6ZSgpLHI9ITEsdGhpcy5jb21wbGV0ZSgpKSxmLmxhYmVsPTQ7Y2FzZSA0OmYudHJ5cy5wdXNoKFs0LDksLDEwXSksZi5sYWJlbD01O2Nhc2UgNTpyZXR1cm5bNCxOKHRoaXMuZGVjb2RlU3luYygpKV07Y2FzZSA2OnJldHVybls0LGYuc2VudCgpXTtjYXNlIDc6cmV0dXJuIGYuc2VudCgpLDA9PS0tbj9bMyw4XTpbMyw1XTtjYXNlIDg6cmV0dXJuWzMsMTBdO2Nhc2UgOTppZighKChhPWYuc2VudCgpKWluc3RhbmNlb2YgcSkpdGhyb3cgYTtyZXR1cm5bMywxMF07Y2FzZSAxMDp0aGlzLnRvdGFsUG9zKz10aGlzLnBvcyxmLmxhYmVsPTExO2Nhc2UgMTE6cmV0dXJuWzMsMl07Y2FzZSAxMjpyZXR1cm5bMywxOV07Y2FzZSAxMzpyZXR1cm4gaD1mLnNlbnQoKSx1PXtlcnJvcjpofSxbMywxOV07Y2FzZSAxNDpyZXR1cm4gZi50cnlzLnB1c2goWzE0LCwxNywxOF0pLG8mJiFvLmRvbmUmJihjPWkucmV0dXJuKT9bNCxOKGMuY2FsbChpKSldOlszLDE2XTtjYXNlIDE1OmYuc2VudCgpLGYubGFiZWw9MTY7Y2FzZSAxNjpyZXR1cm5bMywxOF07Y2FzZSAxNzppZih1KXRocm93IHUuZXJyb3I7cmV0dXJuWzddO2Nhc2UgMTg6cmV0dXJuWzddO2Nhc2UgMTk6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLmRlY29kZVN5bmM9ZnVuY3Rpb24oKXtlOmZvcig7Oyl7dmFyIGU9dGhpcy5yZWFkSGVhZEJ5dGUoKSx0PXZvaWQgMDtpZihlPj0yMjQpdD1lLTI1NjtlbHNlIGlmKGU8MTkyKWlmKGU8MTI4KXQ9ZTtlbHNlIGlmKGU8MTQ0KXtpZigwIT09KG49ZS0xMjgpKXt0aGlzLnB1c2hNYXBTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PXt9fWVsc2UgaWYoZTwxNjApe2lmKDAhPT0obj1lLTE0NCkpe3RoaXMucHVzaEFycmF5U3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD1bXX1lbHNle3ZhciByPWUtMTYwO3Q9dGhpcy5kZWNvZGVVdGY4U3RyaW5nKHIsMCl9ZWxzZSBpZigxOTI9PT1lKXQ9bnVsbDtlbHNlIGlmKDE5ND09PWUpdD0hMTtlbHNlIGlmKDE5NT09PWUpdD0hMDtlbHNlIGlmKDIwMj09PWUpdD10aGlzLnJlYWRGMzIoKTtlbHNlIGlmKDIwMz09PWUpdD10aGlzLnJlYWRGNjQoKTtlbHNlIGlmKDIwND09PWUpdD10aGlzLnJlYWRVOCgpO2Vsc2UgaWYoMjA1PT09ZSl0PXRoaXMucmVhZFUxNigpO2Vsc2UgaWYoMjA2PT09ZSl0PXRoaXMucmVhZFUzMigpO2Vsc2UgaWYoMjA3PT09ZSl0PXRoaXMucmVhZFU2NCgpO2Vsc2UgaWYoMjA4PT09ZSl0PXRoaXMucmVhZEk4KCk7ZWxzZSBpZigyMDk9PT1lKXQ9dGhpcy5yZWFkSTE2KCk7ZWxzZSBpZigyMTA9PT1lKXQ9dGhpcy5yZWFkSTMyKCk7ZWxzZSBpZigyMTE9PT1lKXQ9dGhpcy5yZWFkSTY0KCk7ZWxzZSBpZigyMTc9PT1lKXtyPXRoaXMubG9va1U4KCk7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociwxKX1lbHNlIGlmKDIxOD09PWUpe3I9dGhpcy5sb29rVTE2KCk7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociwyKX1lbHNlIGlmKDIxOT09PWUpe3I9dGhpcy5sb29rVTMyKCk7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociw0KX1lbHNlIGlmKDIyMD09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMTYoKSkpe3RoaXMucHVzaEFycmF5U3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD1bXX1lbHNlIGlmKDIyMT09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMzIoKSkpe3RoaXMucHVzaEFycmF5U3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD1bXX1lbHNlIGlmKDIyMj09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMTYoKSkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZigyMjM9PT1lKXtpZigwIT09KG49dGhpcy5yZWFkVTMyKCkpKXt0aGlzLnB1c2hNYXBTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PXt9fWVsc2UgaWYoMTk2PT09ZSl7dmFyIG49dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlQmluYXJ5KG4sMSl9ZWxzZSBpZigxOTc9PT1lKXtuPXRoaXMubG9va1UxNigpO3Q9dGhpcy5kZWNvZGVCaW5hcnkobiwyKX1lbHNlIGlmKDE5OD09PWUpe249dGhpcy5sb29rVTMyKCk7dD10aGlzLmRlY29kZUJpbmFyeShuLDQpfWVsc2UgaWYoMjEyPT09ZSl0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKDEsMCk7ZWxzZSBpZigyMTM9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oMiwwKTtlbHNlIGlmKDIxND09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbig0LDApO2Vsc2UgaWYoMjE1PT09ZSl0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKDgsMCk7ZWxzZSBpZigyMTY9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oMTYsMCk7ZWxzZSBpZigxOTk9PT1lKXtuPXRoaXMubG9va1U4KCk7dD10aGlzLmRlY29kZUV4dGVuc2lvbihuLDEpfWVsc2UgaWYoMjAwPT09ZSl7bj10aGlzLmxvb2tVMTYoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sMil9ZWxzZXtpZigyMDEhPT1lKXRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCB0eXBlIGJ5dGU6IFwiK2ooZSkpO249dGhpcy5sb29rVTMyKCk7dD10aGlzLmRlY29kZUV4dGVuc2lvbihuLDQpfXRoaXMuY29tcGxldGUoKTtmb3IodmFyIGk9dGhpcy5zdGFjaztpLmxlbmd0aD4wOyl7dmFyIG89aVtpLmxlbmd0aC0xXTtpZigwPT09by50eXBlKXtpZihvLmFycmF5W28ucG9zaXRpb25dPXQsby5wb3NpdGlvbisrLG8ucG9zaXRpb24hPT1vLnNpemUpY29udGludWUgZTtpLnBvcCgpLHQ9by5hcnJheX1lbHNle2lmKDE9PT1vLnR5cGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIlRoZSB0eXBlIG9mIGtleSBtdXN0IGJlIHN0cmluZyBidXQgXCIrdHlwZW9mIHQpO28ua2V5PXQsby50eXBlPTI7Y29udGludWUgZX1pZigyPT09by50eXBlKXtpZihvLm1hcFtvLmtleV09dCxvLnJlYWRDb3VudCsrLG8ucmVhZENvdW50IT09by5zaXplKXtvLmtleT1udWxsLG8udHlwZT0xO2NvbnRpbnVlIGV9aS5wb3AoKSx0PW8ubWFwfX19cmV0dXJuIHR9fSxlLnByb3RvdHlwZS5yZWFkSGVhZEJ5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkQnl0ZT09PUgmJih0aGlzLmhlYWRCeXRlPXRoaXMucmVhZFU4KCkpLHRoaXMuaGVhZEJ5dGV9LGUucHJvdG90eXBlLmNvbXBsZXRlPWZ1bmN0aW9uKCl7dGhpcy5oZWFkQnl0ZT1IfSxlLnByb3RvdHlwZS5yZWFkQXJyYXlTaXplPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5yZWFkSGVhZEJ5dGUoKTtzd2l0Y2goZSl7Y2FzZSAyMjA6cmV0dXJuIHRoaXMucmVhZFUxNigpO2Nhc2UgMjIxOnJldHVybiB0aGlzLnJlYWRVMzIoKTtkZWZhdWx0OmlmKGU8MTYwKXJldHVybiBlLTE0NDt0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgYXJyYXkgdHlwZSBieXRlOiBcIitqKGUpKX19LGUucHJvdG90eXBlLnB1c2hNYXBTdGF0ZT1mdW5jdGlvbihlKXtpZihlPnRoaXMubWF4TWFwTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IG1hcCBsZW5ndGggKFwiK2UrXCIpID4gbWF4TWFwTGVuZ3RoTGVuZ3RoIChcIit0aGlzLm1heE1hcExlbmd0aCtcIilcIik7dGhpcy5zdGFjay5wdXNoKHt0eXBlOjEsc2l6ZTplLGtleTpudWxsLHJlYWRDb3VudDowLG1hcDp7fX0pfSxlLnByb3RvdHlwZS5wdXNoQXJyYXlTdGF0ZT1mdW5jdGlvbihlKXtpZihlPnRoaXMubWF4QXJyYXlMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogYXJyYXkgbGVuZ3RoIChcIitlK1wiKSA+IG1heEFycmF5TGVuZ3RoIChcIit0aGlzLm1heEFycmF5TGVuZ3RoK1wiKVwiKTt0aGlzLnN0YWNrLnB1c2goe3R5cGU6MCxzaXplOmUsYXJyYXk6bmV3IEFycmF5KGUpLHBvc2l0aW9uOjB9KX0sZS5wcm90b3R5cGUuZGVjb2RlVXRmOFN0cmluZz1mdW5jdGlvbihlLHQpe2lmKGU+dGhpcy5tYXhTdHJMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogVVRGLTggYnl0ZSBsZW5ndGggKFwiK2UrXCIpID4gbWF4U3RyTGVuZ3RoIChcIit0aGlzLm1heFN0ckxlbmd0aCtcIilcIik7aWYodGhpcy5ieXRlcy5ieXRlTGVuZ3RoPHRoaXMucG9zK3QrZSl0aHJvdyBKO3ZhciByLG49dGhpcy5wb3MrdDtyZXR1cm4gcj10aGlzLnN0YXRlSXNNYXBLZXkoKSYmdGhpcy5jYWNoZWRLZXlEZWNvZGVyLmNhbkJlQ2FjaGVkKGUpP3RoaXMuY2FjaGVkS2V5RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcyxuLGUpOm8mJmU+MjAwP2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lLnN1YmFycmF5KHQsdCtyKTtyZXR1cm4gZi5kZWNvZGUobil9KHRoaXMuYnl0ZXMsbixlKTpBJiZlPjEwMjQ/VCh0aGlzLmJ5dGVzLG4sZSk6Yyh0aGlzLmJ5dGVzLG4sZSksdGhpcy5wb3MrPXQrZSxyfSxlLnByb3RvdHlwZS5zdGF0ZUlzTWFwS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoPjAmJjE9PT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLnR5cGV9LGUucHJvdG90eXBlLmRlY29kZUJpbmFyeT1mdW5jdGlvbihlLHQpe2lmKGU+dGhpcy5tYXhCaW5MZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogYmluIGxlbmd0aCAoXCIrZStcIikgPiBtYXhCaW5MZW5ndGggKFwiK3RoaXMubWF4QmluTGVuZ3RoK1wiKVwiKTtpZighdGhpcy5oYXNSZW1haW5pbmcoZSt0KSl0aHJvdyBKO3ZhciByPXRoaXMucG9zK3Qsbj10aGlzLmJ5dGVzLnN1YmFycmF5KHIscitlKTtyZXR1cm4gdGhpcy5wb3MrPXQrZSxufSxlLnByb3RvdHlwZS5kZWNvZGVFeHRlbnNpb249ZnVuY3Rpb24oZSx0KXtpZihlPnRoaXMubWF4RXh0TGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IGV4dCBsZW5ndGggKFwiK2UrXCIpID4gbWF4RXh0TGVuZ3RoIChcIit0aGlzLm1heEV4dExlbmd0aCtcIilcIik7dmFyIHI9dGhpcy52aWV3LmdldEludDgodGhpcy5wb3MrdCksbj10aGlzLmRlY29kZUJpbmFyeShlLHQrMSk7cmV0dXJuIHRoaXMuZXh0ZW5zaW9uQ29kZWMuZGVjb2RlKG4scil9LGUucHJvdG90eXBlLmxvb2tVOD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MpfSxlLnByb3RvdHlwZS5sb29rVTE2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpfSxlLnByb3RvdHlwZS5sb29rVTMyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3MpfSxlLnByb3RvdHlwZS5yZWFkVTg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcysrLGV9LGUucHJvdG90eXBlLnJlYWRJOD1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRJbnQ4KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrKyxlfSxlLnByb3RvdHlwZS5yZWFkVTE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldFVpbnQxNih0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz0yLGV9LGUucHJvdG90eXBlLnJlYWRJMTY9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9MixlfSxlLnByb3RvdHlwZS5yZWFkVTMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldFVpbnQzMih0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz00LGV9LGUucHJvdG90eXBlLnJlYWRJMzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkVTY0PWZ1bmN0aW9uKCl7dmFyIGUsdCxyPShlPXRoaXMudmlldyx0PXRoaXMucG9zLDQyOTQ5NjcyOTYqZS5nZXRVaW50MzIodCkrZS5nZXRVaW50MzIodCs0KSk7cmV0dXJuIHRoaXMucG9zKz04LHJ9LGUucHJvdG90eXBlLnJlYWRJNjQ9ZnVuY3Rpb24oKXt2YXIgZT1kKHRoaXMudmlldyx0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LGV9LGUucHJvdG90eXBlLnJlYWRGMzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz00LGV9LGUucHJvdG90eXBlLnJlYWRGNjQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LGV9LGV9KCksJD17fTtmdW5jdGlvbiBlZShlLHQpe3ZvaWQgMD09PXQmJih0PSQpO3ZhciByPW5ldyBaKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCk7cmV0dXJuIHIuc2V0QnVmZmVyKGUpLHIuZGVjb2RlU2luZ2xlU3luYygpfXZhciB0ZT1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxvLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIG89e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihvW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLG87ZnVuY3Rpb24gYShvKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtzOyl0cnl7aWYocj0xLG4mJihpPTImb1swXT9uLnJldHVybjpvWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sb1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYobz1bMiZvWzBdLGkudmFsdWVdKSxvWzBdKXtjYXNlIDA6Y2FzZSAxOmk9bzticmVhaztjYXNlIDQ6cmV0dXJuIHMubGFiZWwrKyx7dmFsdWU6b1sxXSxkb25lOiExfTtjYXNlIDU6cy5sYWJlbCsrLG49b1sxXSxvPVswXTtjb250aW51ZTtjYXNlIDc6bz1zLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGk9KGk9cy50cnlzKS5sZW5ndGg+MCYmaVtpLmxlbmd0aC0xXSkmJig2PT09b1swXXx8Mj09PW9bMF0pKXtzPTA7Y29udGludWV9aWYoMz09PW9bMF0mJighaXx8b1sxXT5pWzBdJiZvWzFdPGlbM10pKXtzLmxhYmVsPW9bMV07YnJlYWt9aWYoNj09PW9bMF0mJnMubGFiZWw8aVsxXSl7cy5sYWJlbD1pWzFdLGk9bzticmVha31pZihpJiZzLmxhYmVsPGlbMl0pe3MubGFiZWw9aVsyXSxzLm9wcy5wdXNoKG8pO2JyZWFrfWlbMl0mJnMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZX1vPXQuY2FsbChlLHMpfWNhdGNoKGUpe289WzYsZV0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZvWzBdKXRocm93IG9bMV07cmV0dXJue3ZhbHVlOm9bMF0/b1sxXTp2b2lkIDAsZG9uZTohMH19KFtvLGFdKX19fSxyZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHJlPyh0aGlzLnY9ZSx0aGlzKTpuZXcgcmUoZSl9LG5lPWZ1bmN0aW9uKGUsdCxyKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgbixpPXIuYXBwbHkoZSx0fHxbXSksbz1bXTtyZXR1cm4gbj17fSxzKFwibmV4dFwiKSxzKFwidGhyb3dcIikscyhcInJldHVyblwiKSxuW1N5bWJvbC5hc3luY0l0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxuO2Z1bmN0aW9uIHMoZSl7aVtlXSYmKG5bZV09ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsbil7by5wdXNoKFtlLHQscixuXSk+MXx8YShlLHQpfSl9KX1mdW5jdGlvbiBhKGUsdCl7dHJ5eyhyPWlbZV0odCkpLnZhbHVlIGluc3RhbmNlb2YgcmU/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihoLHUpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gaChlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIHUoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fTtmdW5jdGlvbiBpZShlKXtyZXR1cm4gbnVsbCE9ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0/ZTpmdW5jdGlvbihlKXtyZXR1cm4gbmUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oKXt2YXIgdCxyLG4saTtyZXR1cm4gdGUodGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnQ9ZS5nZXRSZWFkZXIoKSxvLmxhYmVsPTE7Y2FzZSAxOm8udHJ5cy5wdXNoKFsxLCw5LDEwXSksby5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bNCxyZSh0LnJlYWQoKSldO2Nhc2UgMzpyZXR1cm4gcj1vLnNlbnQoKSxuPXIuZG9uZSxpPXIudmFsdWUsbj9bNCxyZSh2b2lkIDApXTpbMyw1XTtjYXNlIDQ6cmV0dXJuWzIsby5zZW50KCldO2Nhc2UgNTpyZXR1cm5bNCxyZShpKV07Y2FzZSA2OnJldHVybls0LG8uc2VudCgpXTtjYXNlIDc6cmV0dXJuIG8uc2VudCgpLFszLDJdO2Nhc2UgODpyZXR1cm5bMywxMF07Y2FzZSA5OnJldHVybiB0LnJlbGVhc2VMb2NrKCksWzddO2Nhc2UgMTA6cmV0dXJuWzJdfX0pfSl9KGUpfXZhciBvZT1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gbmV3KHJ8fChyPVByb21pc2UpKShmdW5jdGlvbihpLG8pe2Z1bmN0aW9uIHMoZSl7dHJ5e2gobi5uZXh0KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiBhKGUpe3RyeXtoKG4udGhyb3coZSkpfWNhdGNoKGUpe28oZSl9fWZ1bmN0aW9uIGgoZSl7ZS5kb25lP2koZS52YWx1ZSk6bmV3IHIoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pLnRoZW4ocyxhKX1oKChuPW4uYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX0sc2U9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX07ZnVuY3Rpb24gYWUoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9JCksb2UodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIHNlKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIHI9aWUoZSksWzIsbmV3IFoodC5leHRlbnNpb25Db2RlYyx0Lm1heFN0ckxlbmd0aCx0Lm1heEJpbkxlbmd0aCx0Lm1heEFycmF5TGVuZ3RoLHQubWF4TWFwTGVuZ3RoLHQubWF4RXh0TGVuZ3RoKS5kZWNvZGVTaW5nbGVBc3luYyhyKV19KX0pfWZ1bmN0aW9uIGhlKGUsdCl7dm9pZCAwPT09dCYmKHQ9JCk7dmFyIHI9aWUoZSk7cmV0dXJuIG5ldyBaKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlQXJyYXlTdHJlYW0ocil9ZnVuY3Rpb24gdWUoZSx0KXt2b2lkIDA9PT10JiYodD0kKTt2YXIgcj1pZShlKTtyZXR1cm4gbmV3IFoodC5leHRlbnNpb25Db2RlYyx0Lm1heFN0ckxlbmd0aCx0Lm1heEJpbkxlbmd0aCx0Lm1heEFycmF5TGVuZ3RoLHQubWF4TWFwTGVuZ3RoLHQubWF4RXh0TGVuZ3RoKS5kZWNvZGVTdHJlYW0ocil9ci5kKHQsXCJlbmNvZGVcIixmdW5jdGlvbigpe3JldHVybiBQfSksci5kKHQsXCJkZWNvZGVcIixmdW5jdGlvbigpe3JldHVybiBlZX0pLHIuZCh0LFwiZGVjb2RlQXN5bmNcIixmdW5jdGlvbigpe3JldHVybiBhZX0pLHIuZCh0LFwiZGVjb2RlQXJyYXlTdHJlYW1cIixmdW5jdGlvbigpe3JldHVybiBoZX0pLHIuZCh0LFwiZGVjb2RlU3RyZWFtXCIsZnVuY3Rpb24oKXtyZXR1cm4gdWV9KSxyLmQodCxcIkRlY29kZXJcIixmdW5jdGlvbigpe3JldHVybiBafSksci5kKHQsXCJFbmNvZGVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHIuZCh0LFwiRXh0ZW5zaW9uQ29kZWNcIixmdW5jdGlvbigpe3JldHVybiBTfSksci5kKHQsXCJFeHREYXRhXCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHIuZCh0LFwiRVhUX1RJTUVTVEFNUFwiLGZ1bmN0aW9uKCl7cmV0dXJuLTF9KSxyLmQodCxcImVuY29kZURhdGVUb1RpbWVTcGVjXCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHIuZCh0LFwiZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSxyLmQodCxcImRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWNcIixmdW5jdGlvbigpe3JldHVybiBtfSksci5kKHQsXCJlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBifSksci5kKHQsXCJkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBVfSksci5kKHQsXCJfX1dBU01fQVZBSUxBQkxFXCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pfV0pfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2dwYWNrLm1pbi5qcy5tYXAiLCJyZXF1aXJlKFwiLi4vLi4vbW9kdWxlcy9jYWxsZmxvdy9saWIvb3ZlcndyaXRlUmVxdWlyZVwiKVxyXG5cclxucmVxdWlyZShcIi4vcHNrcnVudGltZV9pbnRlcm1lZGlhclwiKTtcclxuXHJcbnJlcXVpcmUoXCJjYWxsZmxvd1wiKTtcclxuXHJcbmNvbnNvbGUubG9nKFwiTG9hZGluZyBydW50aW1lOiBjYWxsZmxvdyBtb2R1bGUgcmVhZHlcIik7IiwiZ2xvYmFsLnBza3J1bnRpbWVMb2FkTW9kdWxlcyA9IGZ1bmN0aW9uKCl7IFxuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wiY2FsbGZsb3dcIl0gPSByZXF1aXJlKFwiY2FsbGZsb3dcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJsYXVuY2hlclwiXSA9IHJlcXVpcmUoXCJsYXVuY2hlclwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcImRvdWJsZS1jaGVja1wiXSA9IHJlcXVpcmUoXCJkb3VibGUtY2hlY2tcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJwc2tjcnlwdG9cIl0gPSByZXF1aXJlKFwicHNrY3J5cHRvXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wiZGljb250YWluZXJcIl0gPSByZXF1aXJlKFwiZGljb250YWluZXJcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJzd2FybXV0aWxzXCJdID0gcmVxdWlyZShcInN3YXJtdXRpbHNcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJzb3VuZHB1YnN1YlwiXSA9IHJlcXVpcmUoXCJzb3VuZHB1YnN1YlwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcInBza2J1ZmZlclwiXSA9IHJlcXVpcmUoXCJwc2tidWZmZXJcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJmb2xkZXJtcVwiXSA9IHJlcXVpcmUoXCJmb2xkZXJtcVwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcImRvbWFpbkJhc2VcIl0gPSByZXF1aXJlKFwiZG9tYWluQmFzZVwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcInV0aWxzXCJdID0gcmVxdWlyZShcInV0aWxzXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wiQG1zZ3BhY2svbXNncGFja1wiXSA9IHJlcXVpcmUoXCJAbXNncGFjay9tc2dwYWNrXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wicHNrbG9nZ2VyXCJdID0gcmVxdWlyZShcInBza2xvZ2dlclwiKTtcbn1cbmlmIChmYWxzZSkge1xuXHRwc2tydW50aW1lTG9hZE1vZHVsZXMoKTtcbn07IFxuZ2xvYmFsLnBza3J1bnRpbWVSZXF1aXJlID0gcmVxdWlyZTtcbmlmICh0eXBlb2YgJCQgIT09IFwidW5kZWZpbmVkXCIpIHsgICAgICAgICAgICBcbiAgICAkJC5yZXF1aXJlQnVuZGxlKFwicHNrcnVudGltZVwiKTtcbn07IiwidmFyIHB1YlN1YiA9ICQkLnJlcXVpcmUoXCJzb3VuZHB1YnN1YlwiKS5zb3VuZFB1YlN1YjtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oZm9sZGVyLCBjb2RlRm9sZGVyICl7XHJcblxyXG4gICAgJCQuUFNLX1B1YlN1YiA9IHB1YlN1YjtcclxuICAgIHZhciBzYW5kQm94ZXNSb290ID0gcGF0aC5qb2luKGZvbGRlciwgXCJzYW5kYm94ZXNcIik7XHJcblxyXG4gICAgdHJ5e1xyXG4gICAgICAgIGZzLm1rZGlyU3luYyhzYW5kQm94ZXNSb290LCB7cmVjdXJzaXZlOiB0cnVlfSk7XHJcbiAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBjcmVhdGUgc2FuZGJveGVzIGRpciBzdHJ1Y3R1cmUhXCIsIGVycik7XHJcbiAgICAgICAgLy9UT0RPOiBtYXliZSBpdCBpcyBvayB0byBjYWxsIHByb2Nlc3MuZXhpdCA/Pz9cclxuICAgIH1cclxuXHJcbiAgICAkJC5TYW5kQm94TWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi9wc2tub2RlL2NvcmUvc2FuZGJveGVzL3V0aWwvU2FuZEJveE1hbmFnZXJcIikuY3JlYXRlKHNhbmRCb3hlc1Jvb3QsIGNvZGVGb2xkZXIsIGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuICAgICAgICBjb25zb2xlLmxvZygkJC5ESV9jb21wb25lbnRzLnNhbmRCb3hSZWFkeSwgZXJyLCByZXMpO1xyXG4gICAgICAgICQkLmNvbnRhaW5lci5yZXNvbHZlKCQkLkRJX2NvbXBvbmVudHMuc2FuZEJveFJlYWR5LCB0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwdWJTdWI7XHJcbn07XHJcbiIsIiQkLkRJX2NvbXBvbmVudHMgPSB7XHJcbiAgIHN3YXJtSXNSZWFkeTpcIlN3YXJtSXNSZWFkeVwiLFxyXG4gICBjb25maWdMb2FkZWQ6XCJjb25maWdMb2FkZWRcIixcclxuICAgc2FuZEJveFJlYWR5OlwiU2FuZEJveFJlYWR5XCIsXHJcbiAgIGxvY2FsTm9kZUFQSXM6XCJsb2NhbE5vZGVBUElzXCJcclxufVxyXG4iLCJjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxuY29uc3QgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcblxyXG4vLyBpZiB0aGlzIGlzIHNldCB0byB0cnVlLCB0aGUgbG9ncyB3aWxsIGJlIGF2YWlsYWJsZS4gRGVmYXVsdCAoZmFsc2UpXHJcbmNvbnN0IERFQlVHID0gIHByb2Nlc3MuZW52LkRFUExPWUVSX0RFQlVHIHx8IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gRlNFeHRlbnRpb24oKXtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgcGF0aCB1c2VkIHRvIHJlc29sdmUgYWxsIHJlbGF0aXZlIHBhdGhzIGluIHRoZSBhY3Rpb25zIGJlbGxvdy5cclxuICAgICAqIERlZmF1bHQgaXMgc2V0IHRvIHR3byBsZXZlbHMgdXAgZnJvbSB0aGUgY3VycmVudCBkaXJlY3RvcnkuIFRoaXMgY2FuIGJlIGNoYW5nZWQgdXNpbmcgX19zZXRCYXNlUGF0aC5cclxuICAgICAqIEB0eXBlIHsqfHN0cmluZ31cclxuICAgICAqL1xyXG4gICAgdmFyIGJhc2VQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi8uLi9cIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGJhc2UgcGF0aCB0byBhIGRpZmZlcmVudCBhYnNvbHV0ZSBkaXJlY3RvcnkgcGF0aC5cclxuICAgICAqIEBwYXJhbSB3ZCB7U3RyaW5nfSBhYnNvbHV0ZSBkaXJlY3RvcnkgcGF0aC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX3NldEJhc2VQYXRoID0gZnVuY3Rpb24od2QpIHtcclxuICAgICAgICBiYXNlUGF0aCA9IHBhdGgucmVzb2x2ZSh3ZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlIHBhdGggaW50byBhbiBhYnNvbHV0ZSBwYXRoLiBJZiBmaWxlUGF0aCBpcyByZWxhdGl2ZSwgdGhlIHBhdGggaXMgcmVzb2x2ZWQgdXNpbmcgdGhlIGJhc2VQYXRoIGFzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHtTdHJpbmd9IHJlbGF0aXZlIG9yIGFic29sdXRlIGZpbGUgcGF0aC5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGFic29sdXRlIHBhdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX3Jlc29sdmVQYXRoID0gZnVuY3Rpb24oZmlsZVBhdGgpIHtcclxuICAgICAgICBpZihwYXRoLmlzQWJzb2x1dGUoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXRoLnJlc29sdmUoYmFzZVBhdGgsIGZpbGVQYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGRvZXMgbm90IGV4aXN0LCBpdCBpcyBjcmVhdGVkLiBMaWtlIG1rZGlyIC1wXHJcbiAgICAgKiBAcGFyYW0gZGlyIHtTdHJpbmd9IGRpciBwYXRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19jcmVhdGVEaXIgPSBmdW5jdGlvbihkaXIpIHtcclxuICAgICAgICBkaXIgPSBfX3Jlc29sdmVQYXRoKGRpcik7XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyKSkge1xyXG4gICAgICAgICAgICBsb2coZGlyICsgXCIgYWxyZWFkeSBleGlzdCEgQ29udGludWluZyAuLi5cIilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlzV2luID0gKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpO1xyXG4gICAgICAgIHZhciBjbWQgPSBpc1dpbiA/IFwibWtkaXIgXCIgOiBcIm1rZGlyIC1wIFwiO1xyXG5cclxuICAgICAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNtZCArIFwiXFxcIlwiK2RpcitcIlxcXCJcIiwge3N0ZGlvOlswLDEsMl19KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYSBmaWxlIG9yIGRpcmVjdG9yeS4gVGhlIGRpcmVjdG9yeSBjYW4gaGF2ZSByZWN1cnNpdmUgY29udGVudHMuIExpa2UgY29weSAtci5cclxuICAgICAqIE5PVEU6IElmIHNyYyBpcyBhIGRpcmVjdG9yeSBpdCB3aWxsIGNvcHkgZXZlcnl0aGluZyBpbnNpZGUgb2YgdGhlIGRpcmVjdG9yeSwgbm90IHRoZSBlbnRpcmUgZGlyZWN0b3J5IGl0c2VsZi5cclxuICAgICAqIE5PVEU6IElmIHNyYyBpcyBhIGZpbGUsIHRhcmdldCBjYW5ub3QgYmUgYSBkaXJlY3RvcnkuXHJcbiAgICAgKiBOT1RFOiBJZiB0aGUgZGVzdGluYXRpb24gcGF0aCBzdHJ1Y3R1cmUgZG9lcyBub3QgZXhpc3RzLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFNvdXJjZSBmaWxlfGRpcmVjdG9yeSBwYXRoLlxyXG4gICAgICogQHBhcmFtIGRlc3Qge1N0cmluZ30gRGVzdGluYXRpb24gZmlsZXxkaXJlY3RvcnkgcGF0aC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGNvcHkgYWN0aW9uLiBBdmFpbGFibGUgb3B0aW9uczpcclxuICAgICAqICAtIG92ZXJ3cml0ZSA8Qm9vbGVhbj46IG92ZXJ3cml0ZSBleGlzdGluZyBmaWxlIG9yIGRpcmVjdG9yeSwgZGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICogIE5vdGUgdGhhdCB0aGUgY29weSBvcGVyYXRpb24gd2lsbCBzaWxlbnRseSBmYWlsIGlmIHRoaXMgaXMgc2V0IHRvIGZhbHNlIGFuZCB0aGUgZGVzdGluYXRpb24gZXhpc3RzLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX2NvcHkgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcclxuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpe307XHJcbiAgICAgICAgbGV0IHJldGhyb3cgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3JjKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0aHJvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBgU291cmNlIGRpcmVjdG9yeSBvciBmaWxlIFwiJHtzcmN9XCIgZG9lcyBub3QgZXhpc3RzIWA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBzcmNTdGF0ID0gZnMubHN0YXRTeW5jKHNyYyk7XHJcbiAgICAgICAgICAgIGlmKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgX19jb3B5RGlyKHNyYywgZGVzdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihzcmNTdGF0LmlzRmlsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXN0aW5hdGlvbiBtdXN0IGJlIGEgZmlsZSB0b29cclxuICAgICAgICAgICAgICAgIF9fY29weUZpbGUoc3JjLCBkZXN0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZihyZXRocm93KXtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2coZXJyLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYSBkaXJlY3RvcnkuIFRoZSBkaXJlY3RvcnkgY2FuIGhhdmUgcmVjdXJzaXZlIGNvbnRlbnRzLiBMaWtlIGNvcHkgLXIuXHJcbiAgICAgKiBOT1RFOiBJdHQgd2lsbCBjb3B5IGV2ZXJ5dGhpbmcgaW5zaWRlIG9mIHRoZSBkaXJlY3RvcnksIG5vdCB0aGUgZW50aXJlIGRpcmVjdG9yeSBpdHNlbGYuXHJcbiAgICAgKiBOT1RFOiBJZiB0aGUgZGVzdGluYXRpb24gcGF0aCBzdHJ1Y3R1cmUgZG9lcyBub3QgZXhpc3RzLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFNvdXJjZSBkaXJlY3RvcnkgcGF0aC5cclxuICAgICAqIEBwYXJhbSBkZXN0IHtTdHJpbmd9IERlc3RpbmF0aW9uIGRpcmVjdG9yeSBwYXRoLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgY29weSBhY3Rpb24uIEF2YWlsYWJsZSBvcHRpb25zOlxyXG4gICAgICogIC0gb3ZlcndyaXRlIDxCb29sZWFuPjogb3ZlcndyaXRlIGV4aXN0aW5nIGRpcmVjdG9yeSwgZGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICogIE5vdGUgdGhhdCB0aGUgY29weSBvcGVyYXRpb24gd2lsbCBzaWxlbnRseSBmYWlsIGlmIHRoaXMgaXMgc2V0IHRvIGZhbHNlIGFuZCB0aGUgZGVzdGluYXRpb24gZXhpc3RzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIF9fY29weURpciA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgb3B0aW9ucykge1xyXG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcclxuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcclxuXHJcbiAgICAgICAgX19jcmVhdGVEaXIoZGVzdCk7XHJcblxyXG4gICAgICAgIHZhciBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHNyYyk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gZnMubHN0YXRTeW5jKHBhdGguam9pbihzcmMsIGZpbGVzW2ldKSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdTcmMgPSBwYXRoLmpvaW4oc3JjLCBmaWxlc1tpXSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdEZXN0ID0gcGF0aC5qb2luKGRlc3QsIGZpbGVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnQuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgX19jb3B5RGlyKG5ld1NyYywgbmV3RGVzdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50LmlzU3ltYm9saWNMaW5rKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW1saW5rID0gZnMucmVhZGxpbmtTeW5jKG5ld1NyYyk7XHJcbiAgICAgICAgICAgICAgICBmcy5zeW1saW5rU3luYyhzeW1saW5rLCBuZXdEZXN0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9fY29weUZpbGUobmV3U3JjLCBuZXdEZXN0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IGEgZmlsZS5cclxuICAgICAqIE5PVEU6IElmIHNyYyBpcyBhIGZpbGUsIHRhcmdldCBjYW5ub3QgYmUgYSBkaXJlY3RvcnkuXHJcbiAgICAgKiBOT1RFOiBJZiB0aGUgZGVzdGluYXRpb24gcGF0aCBzdHJ1Y3R1cmUgZG9lcyBub3QgZXhpc3RzLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFNvdXJjZSBmaWxlIHBhdGguXHJcbiAgICAgKiBAcGFyYW0gZGVzdCB7U3RyaW5nfSBEZXN0aW5hdGlvbiBmaWxlIHBhdGguXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBjb3B5IGFjdGlvbi4gQXZhaWxhYmxlIG9wdGlvbnM6XHJcbiAgICAgKiAgLSBvdmVyd3JpdGUgPEJvb2xlYW4+OiBvdmVyd3JpdGUgZXhpc3RpbmcgZmlsZSBvciBkaXJlY3RvcnksIGRlZmF1bHQgaXMgdHJ1ZS5cclxuICAgICAqICBOb3RlIHRoYXQgdGhlIGNvcHkgb3BlcmF0aW9uIHdpbGwgc2lsZW50bHkgZmFpbCBpZiB0aGlzIGlzIHNldCB0byBmYWxzZSBhbmQgdGhlIGRlc3RpbmF0aW9uIGV4aXN0cy5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19jb3B5RmlsZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgb3B0aW9ucykge1xyXG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcclxuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcclxuXHJcbiAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJ3cml0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGVzdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNpbGVudGx5IGZhaWwgaWYgb3ZlcndyaXRlIGlzIHNldCB0byBmYWxzZSBhbmQgdGhlIGRlc3RpbmF0aW9uIGV4aXN0cy5cclxuICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IGBTaWxlbnQgZmFpbCAtIGNhbm5vdCBjb3B5LiBEZXN0aW5hdGlvbiBmaWxlICR7ZGVzdH0gYWxyZWFkeSBleGlzdHMgYW5kIG92ZXJ3cml0ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlISBDb250aW51aW5nLi4uYDtcclxuICAgICAgICAgICAgICAgIGxvZyhlcnJvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX19jcmVhdGVEaXIocGF0aC5kaXJuYW1lKGRlc3QpKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3JjLCBcInV0ZjhcIik7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhkZXN0LCBjb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBmaWxlIG9yIGRpcmVjdG9yeS4gVGhlIGRpcmVjdG9yeSBjYW4gaGF2ZSByZWN1cnNpdmUgY29udGVudHMuIExpa2Ugcm0gLXJmXHJcbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFBhdGhcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19yZW1vdmUgPSBmdW5jdGlvbihzcmMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgc3JjID0gX19yZXNvbHZlUGF0aChzcmMpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcclxuXHJcbiAgICAgICAgbG9nKGBSZW1vdmluZyAke3NyY31gKTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGZzLmxzdGF0U3luYyhzcmMpO1xyXG4gICAgICAgICAgICBpZihjdXJyZW50LmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgICAgIF9fcm1EaXIoc3JjKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnQuaXNGaWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIF9fcm1GaWxlKHNyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYoZXJyLmNvZGUgJiYgZXJyLmNvZGUgPT09IFwiRU5PRU5UXCIpe1xyXG4gICAgICAgICAgICAgICAgLy9pZ25vcmluZyBlcnJvcnMgbGlrZSBcImZpbGUvZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0XCJcclxuICAgICAgICAgICAgICAgIGVyciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbG9nKGVyciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBkaXJlY3RvcnkuIFRoZSBkaXJlY3RvcnkgY2FuIGhhdmUgcmVjdXJzaXZlIGNvbnRlbnRzLiBMaWtlIHJtIC1yZlxyXG4gICAgICogQHBhcmFtIGRpciB7U3RyaW5nfSBQYXRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19ybURpciA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICBkaXIgPSBfX3Jlc29sdmVQYXRoKGRpcik7XHJcblxyXG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XHJcbiAgICAgICAgICAgIGxvZyhgRGlyZWN0b3J5ICR7ZGlyfSBkb2VzIG5vdCBleGlzdCFgLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpc3QgPSBmcy5yZWFkZGlyU3luYyhkaXIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoLmpvaW4oZGlyLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoZmlsZW5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgX19ybURpcihmaWxlbmFtZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBybSBmaWxlbmFtZVxyXG4gICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZzLnJtZGlyU3luYyhkaXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gZmlsZSB7U3RyaW5nfSBQYXRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19ybUZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgZmlsZSA9IF9fcmVzb2x2ZVBhdGgoZmlsZSk7XHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGUpKSB7XHJcbiAgICAgICAgICAgIGxvZyhgRmlsZSAke2ZpbGV9IGRvZXMgbm90IGV4aXN0IWAsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmcy51bmxpbmtTeW5jKGZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGRhdGEgdG8gYSBmaWxlLCByZXBsYWNpbmcgdGhlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKiBAcGFyYW0gZmlsZSB7U3RyaW5nfSBQYXRoLlxyXG4gICAgICogQHBhcmFtIGRhdGEge1N0cmluZ31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX2NyZWF0ZUZpbGUgPSBmdW5jdGlvbihmaWxlLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZmlsZSA9IF9fcmVzb2x2ZVBhdGgoZmlsZSlcclxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgYSBmaWxlIG9yIGRpcmVjdG9yeS5cclxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gU291cmNlIHBhdGguXHJcbiAgICAgKiBAcGFyYW0gZGVzdCB7U3RyaW5nfSBEZXN0aW5hdGlvbiBwYXRoLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0uIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGNvcHkgYWN0aW9uLiBBdmFpbGFibGUgb3B0aW9uczpcclxuICAgICAqICAtIG92ZXJ3cml0ZSA8Ym9vbGVhbj46IG92ZXJ3cml0ZSBleGlzdGluZyBmaWxlIG9yIGRpcmVjdG9yeSwgZGVmYXVsdCBpcyBmYWxzZS4gTm90ZSB0aGF0IHRoZSBtb3ZlIG9wZXJhdGlvbiB3aWxsIHNpbGVudGx5IGZhaWwgaWYgeW91IHNldCB0aGlzIHRvIHRydWUgYW5kIHRoZSBkZXN0aW5hdGlvbiBleGlzdHMuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIF9fbW92ZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICBzcmMgPSBfX3Jlc29sdmVQYXRoKHNyYyk7XHJcbiAgICAgICAgZGVzdCA9IF9fcmVzb2x2ZVBhdGgoZGVzdCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKXt9O1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGVzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaWxlbnRseSBmYWlsIGlmIG92ZXJ3cml0ZSBpcyBzZXQgdG8gZmFsc2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yID0gYFNpbGVudCBmYWlsIC0gY2Fubm90IG1vdmUuIERlc3RpbmF0aW9uIGZpbGUgJHtkZXN0fSBhbHJlYWR5IGV4aXN0cyBhbmQgb3ZlcndyaXRlIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2UhIENvbnRpbnVpbmcuLi5gO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZyhlcnJvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9fY29weShzcmMsIGRlc3QsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBfX3JlbW92ZShzcmMpO1xyXG4gICAgICAgIH1jYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgY2hlY2tzdW0gdG8gYSBmaWxlIG9yIGEgZGlyZWN0b3J5IGJhc2VkIG9uIHRoZWlyIGNvbnRlbnRzIG9ubHkuXHJcbiAgICAgKiBJZiB0aGUgc291cmNlIGlzIGRpcmVjdG9yeSwgdGhlIGNoZWNrc3VtIGlzIGEgaGFzaCBvZiBhbGwgY29uY2F0ZW5hdGVkIGZpbGUgaGFzaGVzLlxyXG4gICAgICogQHBhcmFtIHNyYyB7U3RyaW5nfSBQYXRoIG9mIGEgZmlsZSBvciBkaXJlY3RvcnkuXHJcbiAgICAgKiBAcGFyYW0gYWxnb3JpdGhtIHtTdHJpbmd9IEhhc2hpbmcgYWxnb3JpdGhtKGRlZmF1bHQ6IG1kNSkuIFRoZSBhbGdvcml0aG0gaXMgZGVwZW5kZW50IG9uIHRoZSBhdmFpbGFibGUgYWxnb3JpdGhtc1xyXG4gICAgICogc3VwcG9ydGVkIGJ5IHRoZSB2ZXJzaW9uIG9mIE9wZW5TU0wgb24gdGhlIHBsYXRmb3JtLiBFLmcuICdtZDUnLCAnc2hhMjU2JywgJ3NoYTUxMicuXHJcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gSGFzaGluZyBlbmNvZGluZyAoZGVmYXVsdDogJ2hleCcpLiBUaGUgZW5jb2RpbmcgaXMgZGVwZW5kZW50IG9uIHRoZVxyXG4gICAgICogYXZhaWxhYmxlIGRpZ2VzdCBhbGdvcml0aG1zLiBFLmcuICdoZXgnLCAnbGF0aW4xJyBvciAnYmFzZTY0Jy5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IENoZWNrc3VtIG9mIHRoZSBmaWxlIG9yIGRpcmVjdG9yeS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX2NoZWNrc3VtID0gZnVuY3Rpb24oc3JjLCBhbGdvcml0aG0sIGVuY29kaW5nKSB7XHJcbiAgICAgICAgc3JjID0gX19yZXNvbHZlUGF0aChzcmMpO1xyXG5cclxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3JjKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBgUGF0aCAke3NyY30gZG9lcyBub3QgZXhpc3RzIWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2hlY2tzdW0gPSBcIlwiO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gZnMubHN0YXRTeW5jKHNyYyk7XHJcbiAgICAgICAgaWYoY3VycmVudC5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgIGxldCBoYXNoRGlyID0gX19oYXNoRGlyKHNyYywgYWxnb3JpdGhtLCBlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIGNoZWNrc3VtID0gaGFzaERpcltcImhhc2hcIl07XHJcbiAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnQuaXNGaWxlKCkpIHtcclxuICAgICAgICAgICAgY2hlY2tzdW0gPSBfX2hhc2hGaWxlKHNyYywgYWxnb3JpdGhtLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hlY2tzdW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHN0ciB7U3RyaW5nfVxyXG4gICAgICogQHBhcmFtIGFsZ29yaXRobSB7U3RyaW5nfSBIYXNoaW5nIGFsZ29yaXRobShkZWZhdWx0OiBtZDUpLiBUaGUgYWxnb3JpdGhtIGlzIGRlcGVuZGVudCBvbiB0aGUgYXZhaWxhYmxlIGFsZ29yaXRobXNcclxuICAgICAqIHN1cHBvcnRlZCBieSB0aGUgdmVyc2lvbiBvZiBPcGVuU1NMIG9uIHRoZSBwbGF0Zm9ybS4gRS5nLiAnbWQ1JywgJ3NoYTI1NicsICdzaGE1MTInLlxyXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHtTdHJpbmd9IEhhc2hpbmcgZW5jb2RpbmcgKGRlZmF1bHQ6ICdoZXgnKS4gVGhlIGVuY29kaW5nIGlzIGRlcGVuZGVudCBvbiB0aGVcclxuICAgICAqIGF2YWlsYWJsZSBkaWdlc3QgYWxnb3JpdGhtcy4gRS5nLiAnaGV4JywgJ2xhdGluMScgb3IgJ2Jhc2U2NCcuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIYXNoIG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19oYXNoID0gIGZ1bmN0aW9uKHN0ciwgYWxnb3JpdGhtLCBlbmNvZGluZykge1xyXG4gICAgICAgIHJldHVybiBjcnlwdG9cclxuICAgICAgICAgICAgLmNyZWF0ZUhhc2goYWxnb3JpdGhtIHx8ICdtZDUnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHN0ciwgJ3V0ZjgnKVxyXG4gICAgICAgICAgICAuZGlnZXN0KGVuY29kaW5nIHx8ICdoZXgnKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgaGFzaCBvZiBhIGZpbGUgYmFzZWQgb24gaXRzIGNvbnRlbnQgb25seS5cclxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gUGF0aCBvZiBhIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gYWxnb3JpdGhtIHtTdHJpbmd9IEhhc2hpbmcgYWxnb3JpdGhtKGRlZmF1bHQ6IG1kNSkuIFRoZSBhbGdvcml0aG0gaXMgZGVwZW5kZW50IG9uIHRoZSBhdmFpbGFibGUgYWxnb3JpdGhtc1xyXG4gICAgICogc3VwcG9ydGVkIGJ5IHRoZSB2ZXJzaW9uIG9mIE9wZW5TU0wgb24gdGhlIHBsYXRmb3JtLiBFLmcuICdtZDUnLCAnc2hhMjU2JywgJ3NoYTUxMicuXHJcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gSGFzaGluZyBlbmNvZGluZyAoZGVmYXVsdDogJ2hleCcpLiBUaGUgZW5jb2RpbmcgaXMgZGVwZW5kZW50IG9uIHRoZVxyXG4gICAgICogYXZhaWxhYmxlIGRpZ2VzdCBhbGdvcml0aG1zLiBFLmcuICdoZXgnLCAnbGF0aW4xJyBvciAnYmFzZTY0Jy5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhhc2ggb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19oYXNoRmlsZSA9IGZ1bmN0aW9uKHNyYywgYWxnb3JpdGhtLCBlbmNvZGluZykge1xyXG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcclxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3JjKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBgJHtzcmN9IGRvZXMgbm90IGV4aXN0IWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhzcmMsIFwidXRmOFwiKTtcclxuICAgICAgICByZXR1cm4gX19oYXNoKGNvbnRlbnQsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgaGFzaCBvZiBhIGRpcmVjdG9yeSBiYXNlZCBvbiBpdHMgY29udGVudCBvbmx5LlxyXG4gICAgICogSWYgZGlyZWN0b3J5IGhhcyBtdWx0aXBsZSBmaWxlcywgdGhlIHJlc3VsdCBpcyBhIGhhc2ggb2YgYWxsIGNvbmNhdGVuYXRlZCBmaWxlIGhhc2hlcy5cclxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gUGF0aCBvZiBhIGRpcmVjdG9yeS5cclxuICAgICAqIEBwYXJhbSBhbGdvcml0aG0ge1N0cmluZ30gSGFzaGluZyBhbGdvcml0aG0oZGVmYXVsdDogbWQ1KS4gVGhlIGFsZ29yaXRobSBpcyBkZXBlbmRlbnQgb24gdGhlIGF2YWlsYWJsZSBhbGdvcml0aG1zXHJcbiAgICAgKiBzdXBwb3J0ZWQgYnkgdGhlIHZlcnNpb24gb2YgT3BlblNTTCBvbiB0aGUgcGxhdGZvcm0uIEUuZy4gJ21kNScsICdzaGEyNTYnLCAnc2hhNTEyJy5cclxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7U3RyaW5nfSBIYXNoaW5nIGVuY29kaW5nIChkZWZhdWx0OiAnaGV4JykuIFRoZSBlbmNvZGluZyBpcyBkZXBlbmRlbnQgb24gdGhlXHJcbiAgICAgKiBhdmFpbGFibGUgZGlnZXN0IGFsZ29yaXRobXMuIEUuZy4gJ2hleCcsICdsYXRpbjEnIG9yICdiYXNlNjQnLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gSGFzaCBvZiB0aGUgZGlyZWN0b3J5LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIF9faGFzaERpciA9IGZ1bmN0aW9uKGRpciwgYWxnb3JpdGhtLCBlbmNvZGluZykge1xyXG4gICAgICAgIGRpciA9IF9fcmVzb2x2ZVBhdGgoZGlyKTtcclxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBgRGlyZWN0b3J5ICR7ZGlyfSBkb2VzIG5vdCBleGlzdCFgO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFzaGVzID0ge307XHJcbiAgICAgICAgdmFyIGxpc3QgPSBmcy5yZWFkZGlyU3luYyhkaXIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoLmpvaW4oZGlyLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoZmlsZW5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBIYXNoZXMgPSBfX2hhc2hEaXIoZmlsZW5hbWUsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICAgICAgaGFzaGVzID0gT2JqZWN0LmFzc2lnbihoYXNoZXMsIHRlbXBIYXNoZXNbXCJzdWItaGFzaGVzXCJdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wSGFzaCA9IF9faGFzaEZpbGUoZmlsZW5hbWUsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICAgICAgaGFzaGVzW2ZpbGVuYW1lXSA9IHRlbXBIYXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb21wdXRlIGRpciBoYXNoXHJcbiAgICAgICAgbGV0IGRpckNvbnRlbnQgPSBPYmplY3Qua2V5cyhoYXNoZXMpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKz0gaGFzaGVzW2tleV07XHJcbiAgICAgICAgfSwgXCJcIik7XHJcblxyXG4gICAgICAgIGxldCBkaXJIYXNoID0gX19oYXNoKGRpckNvbnRlbnQsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImhhc2hcIjogZGlySGFzaCxcclxuICAgICAgICAgICAgXCJzdWItaGFzaGVzXCI6IGhhc2hlc1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGd1aWQgKGdsb2JhbCB1bmlxdWUgaWRlbnRpZmllcikuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBHdWlkIGluIHRoZSBmb3JtYXQgeHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19ndWlkID0gZnVuY3Rpb24gZ3VpZCgpIHtcclxuICAgICAgICBmdW5jdGlvbiBfbWFrZV9ncm91cChzKSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpK1wiMDAwMDAwMDAwXCIpLnN1YnN0cigyLDgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcyA/IFwiLVwiICsgcC5zdWJzdHIoMCw0KSArIFwiLVwiICsgcC5zdWJzdHIoNCw0KSA6IHAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX21ha2VfZ3JvdXAoKSArIF9tYWtlX2dyb3VwKHRydWUpICsgX21ha2VfZ3JvdXAodHJ1ZSkgKyBfbWFrZV9ncm91cCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB3cmFwcGVyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2Uge1N0cmluZ31cclxuICAgICAqIEBwYXJhbSBpc0Vycm9yIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsb2cobWVzc2FnZSwgaXNFcnJvcikge1xyXG4gICAgICAgIGxldCBsb2dnZXIgPSBpc0Vycm9yID8gY29uc29sZS5lcnJvciA6IGNvbnNvbGUubG9nO1xyXG5cclxuICAgICAgICBpZihERUJVRykge1xyXG4gICAgICAgICAgICBsb2dnZXIobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2V0QmFzZVBhdGg6IF9fc2V0QmFzZVBhdGgsXHJcbiAgICAgICAgcmVzb2x2ZVBhdGg6IF9fcmVzb2x2ZVBhdGgsXHJcbiAgICAgICAgY3JlYXRlRGlyOiBfX2NyZWF0ZURpcixcclxuICAgICAgICBjb3B5RGlyOiBfX2NvcHlEaXIsXHJcbiAgICAgICAgcm1EaXI6IF9fcm1EaXIsXHJcbiAgICAgICAgcm1GaWxlOiBfX3JtRmlsZSxcclxuICAgICAgICBjcmVhdGVGaWxlOiBfX2NyZWF0ZUZpbGUsXHJcbiAgICAgICAgY29weTogX19jb3B5LFxyXG4gICAgICAgIG1vdmU6IF9fbW92ZSxcclxuICAgICAgICByZW1vdmU6IF9fcmVtb3ZlLFxyXG4gICAgICAgIGNoZWNrc3VtOiBfX2NoZWNrc3VtLFxyXG4gICAgICAgIGd1aWQ6IF9fZ3VpZFxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5mc0V4dCA9IG5ldyBGU0V4dGVudGlvbigpOyIsIiQkLkNPTlNUQU5UUyA9IHtcclxuICAgIFNXQVJNX0ZPUl9FWEVDVVRJT046XCJzd2FybV9mb3JfZXhlY3V0aW9uXCIsXHJcbiAgICBJTkJPVU5EOlwiaW5ib3VuZFwiLFxyXG4gICAgT1VUQk9VTkQ6XCJvdXRib3VuZFwiLFxyXG4gICAgUERTOlwiUHJpdmF0ZURhdGFTeXN0ZW1cIixcclxuICAgIENSTDpcIkNvbW11bmljYXRpb25SZXBsaWNhdGlvbkxheWVyXCIsXHJcbiAgICBTV0FSTV9SRVRVUk46ICdzd2FybV9yZXR1cm4nLFxyXG4gICAgQkVGT1JFX0lOVEVSQ0VQVE9SOiAnYmVmb3JlJyxcclxuICAgIEFGVEVSX0lOVEVSQ0VQVE9SOiAnYWZ0ZXInLFxyXG59O1xyXG5cclxuIiwiLy8gcmVsYXRlZCB0bzogU3dhcm1TcGFjZS5Td2FybURlc2NyaXB0aW9uLmNyZWF0ZVBoYXNlKClcclxuXHJcbmZ1bmN0aW9uIEludGVyY2VwdG9yUmVnaXN0cnkoKSB7XHJcbiAgICBjb25zdCBydWxlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgX0NMQVNTX05BTUUgPSAnSW50ZXJjZXB0b3JSZWdpc3RyeSc7XHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFJJVkFURSBNRVRIT0RTICoqKioqKioqKioqKiovXHJcblxyXG4gICAgZnVuY3Rpb24gX3Rocm93RXJyb3IoZXJyLCBtc2cpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlLCBgJHtfQ0xBU1NfTkFNRX0gZXJyb3IgbWVzc2FnZTpgLCBtc2cpO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfd2FybmluZyhtc2cpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYCR7X0NMQVNTX05BTUV9IHdhcm5pbmcgbWVzc2FnZTpgLCBtc2cpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldFdoZW5PcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgV0hFTl9PUFRJT05TO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChXSEVOX09QVElPTlMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgV0hFTl9PUFRJT05TID0gT2JqZWN0LmZyZWV6ZShbXHJcbiAgICAgICAgICAgICAgICAgICAgJCQuQ09OU1RBTlRTLkJFRk9SRV9JTlRFUkNFUFRPUixcclxuICAgICAgICAgICAgICAgICAgICAkJC5DT05TVEFOVFMuQUZURVJfSU5URVJDRVBUT1JcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBXSEVOX09QVElPTlM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gdmVyaWZ5V2hlbk9wdGlvbih3aGVuKSB7XHJcbiAgICAgICAgaWYgKCFnZXRXaGVuT3B0aW9ucygpLmluY2x1ZGVzKHdoZW4pKSB7XHJcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKG5ldyBSYW5nZUVycm9yKGBPcHRpb24gJyR7d2hlbn0nIGlzIHdyb25nIWApLFxyXG4gICAgICAgICAgICAgICAgYGl0IHNob3VsZCBiZSBvbmUgb2Y6ICR7Z2V0V2hlbk9wdGlvbnMoKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmVyaWZ5SXNGdW5jdGlvblR5cGUoZm4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtmbn0nIGlzIHdyb25nIWApLFxyXG4gICAgICAgICAgICAgICAgYGl0IHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBub3QgJHt0eXBlb2YgZm59IWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlUmVzb2x1dGlvbihzd2FybVR5cGVOYW1lKSB7XHJcbiAgICAgICAgaWYgKHN3YXJtVHlwZU5hbWUgPT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3dhcm1UeXBlTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoc3dhcm1UeXBlTmFtZS5pbmNsdWRlcyhcIi5cIikgPyBzd2FybVR5cGVOYW1lIDogKCQkLmxpYnJhcnlQcmVmaXggKyBcIi5cIiArIHN3YXJtVHlwZU5hbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgaW50byBhIGdlbmVyYXRvciB3aXRoIHRoZSBwYXJ0aWN1bGFyaXR5IHRoYXQgZG9uZSBpcyBzZXQgdG8gdHJ1ZSBvbiB0aGUgbGFzdCBlbGVtZW50LFxyXG4gICAgICogbm90IGFmdGVyIGl0IGZpbmlzaGVkIGl0ZXJhdGluZywgdGhpcyBpcyBoZWxwZnVsIGluIG9wdGltaXppbmcgc29tZSBvdGhlciBmdW5jdGlvbnNcclxuICAgICAqIEl0IGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCBjYWxsIGEgcmVjdXJzaXZlIGZ1bmN0aW9uIG92ZXIgdGhlIGFycmF5IGVsZW1lbnRzIGJ1dCB3aXRob3V0IHBvcHBpbmcgdGhlIGZpcnN0XHJcbiAgICAgKiBlbGVtZW50IG9mIHRoZSBBcnJheSBvciBzZW5kaW5nIHRoZSBpbmRleCBhcyBhbiBleHRyYSBwYXJhbWV0ZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyclxyXG4gICAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjwqPn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24qIGNyZWF0ZUFycmF5R2VuZXJhdG9yKGFycikge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGFycltpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJbbGVuIC0gMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSB0cmVlIGxpa2Ugc3RydWN0dXJlIG92ZXIgdGltZSAoaWYgY2FsbGVkIG9uIHRoZSBzYW1lIHJvb3Qgbm9kZSkgd2hlcmUgaW50ZXJuYWwgbm9kZXMgYXJlIGluc3RhbmNlcyBvZlxyXG4gICAgICogTWFwIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGNoaWxkcmVuIG5vZGVzIChlYWNoIGNoaWxkIG5hbWUgaXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIG5leHQgb24gYGtleXNHZW5lcmF0b3IpXHJcbiAgICAgKiBhbmQgYSByZWZlcmVuY2UgdG8gdGhlbSBhbmQgb24gbGVhZnMgaXQgY29udGFpbnMgYW4gaW5zdGFuY2Ugb2YgU2V0IHdoZXJlIGl0IGFkZHMgdGhlIGZ1bmN0aW9uIGdpdmVuIGFzIHBhcmFtZXRlclxyXG4gICAgICogKGV4OiBmb3IgYSBrZXlHZW5lcmF0b3IgdGhhdCByZXR1cm5zIGluIHRoaXMgb3JkZXIgKFwia2V5MVwiLCBcImtleTJcIikgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgd2lsbCBiZTpcclxuICAgICAqIHtcImtleTFcIjoge1wia2V5MVwiOiBTZXQoW2ZuXSl9fSAtIHVzaW5nIEpTT04ganVzdCBmb3IgaWxsdXN0cmF0aW9uIHB1cnBvc2VzIGJlY2F1c2UgaXQncyBlYXNpZXIgdG8gcmVwcmVzZW50KVxyXG4gICAgICogQHBhcmFtIHtNYXB9IHJ1bGVzTWFwXHJcbiAgICAgKiBAcGFyYW0ge0l0ZXJhYmxlSXRlcmF0b3J9IGtleXNHZW5lcmF0b3IgLSBpdCBoYXMgdGhlIHBhcnRpY3VsYXJpdHkgdGhhdCBkb25lIGlzIHNldCBvbiBsYXN0IGVsZW1lbnQsIG5vdCBhZnRlciBpdFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJSZWN1cnNpdmVSdWxlKHJ1bGVzTWFwLCBrZXlzR2VuZXJhdG9yLCBmbikge1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBrZXlzR2VuZXJhdG9yLm5leHQoKTtcclxuXHJcbiAgICAgICAgaWYgKCFkb25lKSB7IC8vIGludGVybmFsIG5vZGVcclxuICAgICAgICAgICAgY29uc3QgbmV4dEtleSA9IHJ1bGVzTWFwLmdldCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5leHRLZXkgPT09ICd1bmRlZmluZWQnKSB7IC8vIGlmIHZhbHVlIG5vdCBmb3VuZCBpbiBydWxlc01hcFxyXG4gICAgICAgICAgICAgICAgcnVsZXNNYXAuc2V0KHZhbHVlLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZWdpc3RlclJlY3Vyc2l2ZVJ1bGUocnVsZXNNYXAuZ2V0KHZhbHVlKSwga2V5c0dlbmVyYXRvciwgZm4pO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIHJlYWNoZWQgbGVhZiBub2RlXHJcbiAgICAgICAgICAgIGlmICghcnVsZXNNYXAuaGFzKHZhbHVlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJ1bGVzTWFwLnNldCh2YWx1ZSwgbmV3IFNldChbZm5dKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBydWxlc01hcC5nZXQodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXQuaGFzKGZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF93YXJuaW5nKGBEdXBsaWNhdGVkIGludGVyY2VwdG9yIGZvciAnJHtrZXl9J2ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldC5hZGQoZm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBzZXQgb2YgZnVuY3Rpb25zIGZvciB0aGUgZ2l2ZW4ga2V5IGlmIGZvdW5kXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gZm9ybWF0dGVkIGFzIGEgcGF0aCB3aXRob3V0IHRoZSBmaXJzdCAnLycgKGV4OiBzd2FybVR5cGUvc3dhcm1QaGFzZS9iZWZvcmUpXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxTZXQ8ZnVuY3Rpb24+Pn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW50ZXJjZXB0b3JzRm9yS2V5KGtleSkge1xyXG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIF93YXJuaW5nKGBJbnRlcmNlcHRvciBjYWxsZWQgb24ga2V5ICR7a2V5fSBzdGFydGluZyB3aXRoICcvJywgYXV0b21hdGljYWxseSByZW1vdmluZyBpdGApO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qga2V5RWxlbWVudHMgPSBrZXkuc3BsaXQoJy8nKTtcclxuICAgICAgICBjb25zdCBrZXlzR2VuZXJhdG9yID0gY3JlYXRlQXJyYXlHZW5lcmF0b3Ioa2V5RWxlbWVudHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2V0VmFsdWVSZWN1cnNpdmVseShbcnVsZXNdLCBrZXlzR2VuZXJhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IHdvcmtzIGxpa2UgYSBCRlMgc2VhcmNoIHJldHVybmluZyB0aGUgbGVhZnMgcmVzdWx0aW5nIGZyb20gdHJhdmVyc2luZyB0aGUgaW50ZXJuYWwgbm9kZXMgd2l0aCBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiBuYW1lcyBnaXZlbiBmb3IgZWFjaCBsZXZlbCAoZGVwdGgpIGJ5IGBrZXlzR2VuZXJhdG9yYFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxNYXA+fSBzZWFyY2hhYmxlTm9kZXNcclxuICAgICAqIEBwYXJhbSB7SXRlcmFibGVJdGVyYXRvcn0ga2V5c0dlbmVyYXRvciAtIGl0IGhhcyB0aGUgcGFydGljdWxhcml0eSB0aGF0IGRvbmUgaXMgc2V0IG9uIGxhc3QgZWxlbWVudCwgbm90IGFmdGVyIGl0XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxTZXQ8ZnVuY3Rpb24+Pn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVSZWN1cnNpdmVseShzZWFyY2hhYmxlTm9kZXMsIGtleXNHZW5lcmF0b3IpIHtcclxuICAgICAgICBjb25zdCB7dmFsdWU6IG5vZGVOYW1lLCBkb25lfSA9IGtleXNHZW5lcmF0b3IubmV4dCgpO1xyXG5cclxuICAgICAgICBjb25zdCBuZXh0Tm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlSW5SdWxlcyBvZiBzZWFyY2hhYmxlTm9kZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE5vZGVGb3JBbGwgPSBub2RlSW5SdWxlcy5nZXQoJyonKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBub2RlSW5SdWxlcy5nZXQobm9kZU5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0Tm9kZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVzLnB1c2gobmV4dE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5leHROb2RlRm9yQWxsICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZXMucHVzaChuZXh0Tm9kZUZvckFsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlUmVjdXJzaXZlbHkobmV4dE5vZGVzLCBrZXlzR2VuZXJhdG9yKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFVCTElDIE1FVEhPRFMgKioqKioqKioqKioqKi9cclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgd2hlbiwgZm4pIHtcclxuICAgICAgICB2ZXJpZnlXaGVuT3B0aW9uKHdoZW4pO1xyXG4gICAgICAgIHZlcmlmeUlzRnVuY3Rpb25UeXBlKGZuKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRTd2FybVR5cGVOYW1lID0gcmVzb2x2ZU5hbWVzcGFjZVJlc29sdXRpb24oc3dhcm1UeXBlTmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyZWF0ZUFycmF5R2VuZXJhdG9yKFtyZXNvbHZlZFN3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgd2hlbl0pO1xyXG5cclxuICAgICAgICByZWdpc3RlclJlY3Vyc2l2ZVJ1bGUocnVsZXMsIGtleXMsIGZuKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdGhpcy51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkgeyB9XHJcblxyXG4gICAgdGhpcy5jYWxsSW50ZXJjZXB0b3JzID0gZnVuY3Rpb24gKGtleSwgdGFyZ2V0T2JqZWN0LCBhcmdzKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JzID0gZ2V0SW50ZXJjZXB0b3JzRm9yS2V5KGtleSk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcmNlcHRvcnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpbnRlcmNlcHRvclNldCBvZiBpbnRlcmNlcHRvcnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgaW50ZXJjZXB0b3JTZXQpIHsgLy8gaW50ZXJjZXB0b3JzIG9uIGtleSAnKicgYXJlIGNhbGxlZCBiZWZvcmUgdGhvc2Ugc3BlY2lmaWVkIGJ5IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0YXJnZXRPYmplY3QsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbmV4cG9ydHMuY3JlYXRlSW50ZXJjZXB0b3JSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgSW50ZXJjZXB0b3JSZWdpc3RyeSgpO1xyXG59O1xyXG4iLCIvKlxyXG4gSW5pdGlhbCBMaWNlbnNlOiAoYykgQXhpb2xvZ2ljIFJlc2VhcmNoICYgQWxib2FpZSBTw65uaWPEgy5cclxuIENvbnRyaWJ1dG9yczogQXhpb2xvZ2ljIFJlc2VhcmNoICwgUHJpdmF0ZVNreSBwcm9qZWN0XHJcbiBDb2RlIExpY2Vuc2U6IExHUEwgb3IgTUlULlxyXG4gKi9cclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuY3ByaW50ID0gY29uc29sZS5sb2c7XHJcbndwcmludCA9IGNvbnNvbGUud2FybjtcclxuZHByaW50ID0gY29uc29sZS5kZWJ1ZztcclxuZXByaW50ID0gY29uc29sZS5lcnJvcjtcclxuXHJcblxyXG4vKipcclxuICogU2hvcnRjdXQgdG8gSlNPTi5zdHJpbmdpZnlcclxuICogQHBhcmFtIG9ialxyXG4gKi9cclxuSiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFByaW50IHN3YXJtIGNvbnRleHRzIChNZXNzYWdlcykgYW5kIGVhc2llciB0byByZWFkIGNvbXBhcmVkIHdpdGggSlxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydHMuY2xlYW5EdW1wID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdmFyIG8gPSBvYmoudmFsdWVPZigpO1xyXG4gICAgdmFyIG1ldGEgPSB7XHJcbiAgICAgICAgc3dhcm1UeXBlTmFtZTpvLm1ldGEuc3dhcm1UeXBlTmFtZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBcIlxcdCBzd2FybUlkOiBcIiArIG8ubWV0YS5zd2FybUlkICsgXCJ7XFxuXFx0XFx0bWV0YTogXCIgICAgKyBKKG1ldGEpICtcclxuICAgICAgICBcIlxcblxcdFxcdHB1YmxpYzogXCIgICAgICAgICsgSihvLnB1YmxpY1ZhcnMpICtcclxuICAgICAgICBcIlxcblxcdFxcdHByb3RlY3RlZDogXCIgICAgICsgSihvLnByb3RlY3RlZFZhcnMpICtcclxuICAgICAgICBcIlxcblxcdFxcdHByaXZhdGU6IFwiICAgICAgICsgSihvLnByaXZhdGVWYXJzKSArIFwiXFxuXFx0fVxcblwiO1xyXG59XHJcblxyXG4vL00gPSBleHBvcnRzLmNsZWFuRHVtcDtcclxuLyoqXHJcbiAqIEV4cGVyaW1lbnRhbCBmdW5jdGlvbnNcclxuICovXHJcblxyXG5cclxuLypcclxuXHJcbiBsb2dnZXIgICAgICA9IG1vbml0b3IubG9nZ2VyO1xyXG4gYXNzZXJ0ICAgICAgPSBtb25pdG9yLmFzc2VydDtcclxuIHRocm93aW5nICAgID0gbW9uaXRvci5leGNlcHRpb25zO1xyXG5cclxuXHJcbiB2YXIgdGVtcG9yYXJ5TG9nQnVmZmVyID0gW107XHJcblxyXG4gdmFyIGN1cnJlbnRTd2FybUNvbUltcGwgPSBudWxsO1xyXG5cclxuIGxvZ2dlci5yZWNvcmQgPSBmdW5jdGlvbihyZWNvcmQpe1xyXG4gaWYoY3VycmVudFN3YXJtQ29tSW1wbD09PW51bGwpe1xyXG4gdGVtcG9yYXJ5TG9nQnVmZmVyLnB1c2gocmVjb3JkKTtcclxuIH0gZWxzZSB7XHJcbiBjdXJyZW50U3dhcm1Db21JbXBsLnJlY29yZExvZyhyZWNvcmQpO1xyXG4gfVxyXG4gfVxyXG5cclxuIHZhciBjb250YWluZXIgPSByZXF1aXJlKFwiZGljb250YWluZXJcIikuY29udGFpbmVyO1xyXG5cclxuIGNvbnRhaW5lci5zZXJ2aWNlKFwic3dhcm1Mb2dnaW5nTW9uaXRvclwiLCBbXCJzd2FybWluZ0lzV29ya2luZ1wiLCBcInN3YXJtQ29tSW1wbFwiXSwgZnVuY3Rpb24ob3V0T2ZTZXJ2aWNlLHN3YXJtaW5nLCBzd2FybUNvbUltcGwpe1xyXG5cclxuIGlmKG91dE9mU2VydmljZSl7XHJcbiBpZighdGVtcG9yYXJ5TG9nQnVmZmVyKXtcclxuIHRlbXBvcmFyeUxvZ0J1ZmZlciA9IFtdO1xyXG4gfVxyXG4gfSBlbHNlIHtcclxuIHZhciB0bXAgPSB0ZW1wb3JhcnlMb2dCdWZmZXI7XHJcbiB0ZW1wb3JhcnlMb2dCdWZmZXIgPSBbXTtcclxuIGN1cnJlbnRTd2FybUNvbUltcGwgPSBzd2FybUNvbUltcGw7XHJcbiBsb2dnZXIucmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKXtcclxuIGN1cnJlbnRTd2FybUNvbUltcGwucmVjb3JkTG9nKHJlY29yZCk7XHJcbiB9XHJcblxyXG4gdG1wLmZvckVhY2goZnVuY3Rpb24ocmVjb3JkKXtcclxuIGxvZ2dlci5yZWNvcmQocmVjb3JkKTtcclxuIH0pO1xyXG4gfVxyXG4gfSlcclxuXHJcbiAqL1xyXG51bmNhdWdodEV4Y2VwdGlvblN0cmluZyA9IFwiXCI7XHJcbnVuY2F1Z2h0RXhjZXB0aW9uRXhpc3RzID0gZmFsc2U7XHJcbmlmKHR5cGVvZiBnbG9iYWxWZXJib3NpdHkgPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgZ2xvYmFsVmVyYm9zaXR5ID0gZmFsc2U7XHJcbn1cclxuXHJcbnZhciBERUJVR19TVEFSVF9USU1FID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG5mdW5jdGlvbiBnZXREZWJ1Z0RlbHRhKCl7XHJcbiAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHJldHVybiBjdXJyZW50VGltZSAtIERFQlVHX1NUQVJUX1RJTUU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWJ1ZyBmdW5jdGlvbnMsIGluZmx1ZW5jZWQgYnkgZ2xvYmFsVmVyYm9zaXR5IGdsb2JhbCB2YXJpYWJsZVxyXG4gKiBAcGFyYW0gdHh0XHJcbiAqL1xyXG5kcHJpbnQgPSBmdW5jdGlvbiAodHh0KSB7XHJcbiAgICBpZiAoZ2xvYmFsVmVyYm9zaXR5ID09IHRydWUpIHtcclxuICAgICAgICBpZiAodGhpc0FkYXB0ZXIuaW5pdGlsaXNlZCApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogW1wiICsgdGhpc0FkYXB0ZXIubm9kZU5hbWUgKyBcIl0oXCIgKyBnZXREZWJ1Z0RlbHRhKCkrIFwiKTpcIit0eHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogKFwiICsgZ2V0RGVidWdEZWx0YSgpKyBcIik6XCIrdHh0KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogXCIgKyB0eHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIG9ic29sZXRlIT9cclxuICogQHBhcmFtIHR4dFxyXG4gKi9cclxuYXByaW50ID0gZnVuY3Rpb24gKHR4dCkge1xyXG4gICAgY29uc29sZS5sb2coXCJERUJVRzogW1wiICsgdGhpc0FkYXB0ZXIubm9kZU5hbWUgKyBcIl06IFwiICsgdHh0KTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiB1c3VhbGx5IHVzZWQgaW4gdGVzdHMsIGV4aXQgY3VycmVudCBwcm9jZXNzIGFmdGVyIGEgd2hpbGVcclxuICogQHBhcmFtIG1zZ1xyXG4gKiBAcGFyYW0gdGltZW91dFxyXG4gKi9cclxuZGVsYXlFeGl0ID0gZnVuY3Rpb24gKG1zZywgcmV0Q29kZSx0aW1lb3V0KSB7XHJcbiAgICBpZihyZXRDb2RlID09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgcmV0Q29kZSA9IEV4aXRDb2Rlcy5Vbmtub3duRXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGltZW91dCA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHRpbWVvdXQgPSAxMDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYobXNnID09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgbXNnID0gXCJEZWxheWluZyBleGl0IHdpdGggXCIrIHRpbWVvdXQgKyBcIm1zXCI7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHByb2Nlc3MuZXhpdChyZXRDb2RlKTtcclxuICAgIH0sIHRpbWVvdXQpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbG9jYWxMb2cgKGxvZ1R5cGUsIG1lc3NhZ2UsIGVycikge1xyXG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgdmFyIG5vdyA9IHRpbWUuZ2V0RGF0ZSgpICsgXCItXCIgKyAodGltZS5nZXRNb250aCgpICsgMSkgKyBcIixcIiArIHRpbWUuZ2V0SG91cnMoKSArIFwiOlwiICsgdGltZS5nZXRNaW51dGVzKCk7XHJcbiAgICB2YXIgbXNnO1xyXG5cclxuICAgIG1zZyA9ICdbJyArIG5vdyArICddWycgKyB0aGlzQWRhcHRlci5ub2RlTmFtZSArICddICcgKyBtZXNzYWdlO1xyXG5cclxuICAgIGlmIChlcnIgIT0gbnVsbCAmJiBlcnIgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbXNnICs9ICdcXG4gICAgIEVycjogJyArIGVyci50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChlcnIuc3RhY2sgJiYgZXJyLnN0YWNrICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgbXNnICs9ICdcXG4gICAgIFN0YWNrOiAnICsgZXJyLnN0YWNrICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgY3ByaW50KG1zZyk7XHJcbiAgICBpZih0aGlzQWRhcHRlci5pbml0aWxpc2VkKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKGdldFN3YXJtRmlsZVBhdGgodGhpc0FkYXB0ZXIuY29uZmlnLmxvZ3NQYXRoICsgXCIvXCIgKyBsb2dUeXBlKSwgbXNnKTtcclxuICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGluZyB0byB3cml0ZSBsb2dzIGluIFwiLCB0aGlzQWRhcHRlci5jb25maWcubG9nc1BhdGggKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8gcHJpbnRmID0gZnVuY3Rpb24gKC4uLnBhcmFtcykge1xyXG4vLyAgICAgdmFyIGFyZ3MgPSBbXTsgLy8gZW1wdHkgYXJyYXlcclxuLy8gICAgIC8vIGNvcHkgYWxsIG90aGVyIGFyZ3VtZW50cyB3ZSB3YW50IHRvIFwicGFzcyB0aHJvdWdoXCJcclxuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbi8vICAgICAgICAgYXJncy5wdXNoKHBhcmFtc1tpXSk7XHJcbi8vICAgICB9XHJcbi8vICAgICB2YXIgb3V0ID0gdXRpbC5mb3JtYXQuYXBwbHkodGhpcywgYXJncyk7XHJcbi8vICAgICBjb25zb2xlLmxvZyhvdXQpO1xyXG4vLyB9XHJcbi8vXHJcbi8vIHNwcmludGYgPSBmdW5jdGlvbiAoLi4ucGFyYW1zKSB7XHJcbi8vICAgICB2YXIgYXJncyA9IFtdOyAvLyBlbXB0eSBhcnJheVxyXG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuLy8gICAgICAgICBhcmdzLnB1c2gocGFyYW1zW2ldKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiB1dGlsLmZvcm1hdC5hcHBseSh0aGlzLCBhcmdzKTtcclxuLy8gfVxyXG5cclxuIiwiZXhwb3J0cy5jcmVhdGVGb3JPYmplY3QgPSBmdW5jdGlvbih2YWx1ZU9iamVjdCwgdGhpc09iamVjdCwgbG9jYWxJZCl7XHJcblx0cmV0dXJuIHJlcXVpcmUoXCIuLi91dGlsaXR5RnVuY3Rpb25zL2Jhc2VcIikuY3JlYXRlRm9yT2JqZWN0KHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKTtcclxufTsiLCJcclxuXHJcbmZ1bmN0aW9uIFN3YXJtc0luc3RhbmNlc01hbmFnZXIoKXtcclxuICAgIHZhciBzd2FybUFsaXZlSW5zdGFuY2VzID0ge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLndhaXRGb3JTd2FybSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzd2FybSwga2VlcEFsaXZlQ2hlY2spe1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkb0xvZ2ljKCl7XHJcbiAgICAgICAgICAgIHZhciBzd2FybUlkID0gc3dhcm0uZ2V0SW5uZXJWYWx1ZSgpLm1ldGEuc3dhcm1JZDtcclxuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdO1xyXG4gICAgICAgICAgICBpZighd2F0Y2hlcil7XHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3YXJtOnN3YXJtLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOmNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZUNoZWNrOmtlZXBBbGl2ZUNoZWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdID0gd2F0Y2hlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmlsdGVyKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBzd2FybS5nZXRJbm5lclZhbHVlKCkubWV0YS5zd2FybUlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8kJC51aWRHZW5lcmF0b3Iud2FpdF9mb3JfY29uZGl0aW9uKGNvbmRpdGlvbixkb0xvZ2ljKTtcclxuICAgICAgICBzd2FybS5vYnNlcnZlKGRvTG9naWMsIG51bGwsIGZpbHRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYW5Td2FybVdhaXRlcihzd2FybVNlcmlhbGlzYXRpb24peyAvLyBUT0RPOiBhZGQgYmV0dGVyIG1lY2hhbmlzbXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcclxuICAgICAgICB2YXIgc3dhcm1JZCA9IHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLnN3YXJtSWQ7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdO1xyXG5cclxuICAgICAgICBpZighd2F0Y2hlcil7XHJcbiAgICAgICAgICAgICQkLndhcm4oXCJJbnZhbGlkIHN3YXJtIHJlY2VpdmVkOiBcIiArIHN3YXJtSWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXJncyA9IHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLmFyZ3M7XHJcbiAgICAgICAgYXJncy5wdXNoKHN3YXJtU2VyaWFsaXNhdGlvbik7XHJcblxyXG4gICAgICAgIHdhdGNoZXIuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgaWYoIXdhdGNoZXIua2VlcEFsaXZlQ2hlY2soKSl7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJldml2ZV9zd2FybSA9IGZ1bmN0aW9uKHN3YXJtU2VyaWFsaXNhdGlvbil7XHJcblxyXG5cclxuICAgICAgICB2YXIgc3dhcm1JZCAgICAgPSBzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5zd2FybUlkO1xyXG4gICAgICAgIHZhciBzd2FybVR5cGUgICA9IHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLnN3YXJtVHlwZU5hbWU7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlICAgID0gc3dhcm1BbGl2ZUluc3RhbmNlc1tzd2FybUlkXTtcclxuXHJcbiAgICAgICAgdmFyIHN3YXJtO1xyXG5cclxuICAgICAgICBpZihpbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHN3YXJtID0gaW5zdGFuY2Uuc3dhcm07XHJcbiAgICAgICAgICAgIHN3YXJtLnVwZGF0ZShzd2FybVNlcmlhbGlzYXRpb24pO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2FybSA9ICQkLnN3YXJtLnN0YXJ0KHN3YXJtVHlwZSk7XHJcbiAgICAgICAgICAgIGlmKCFzd2FybSl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3dhcm0gdHlwZSA8JHtzd2FybVR5cGV9Pi4gQ2hlY2sgaWYgc3dhcm0gdHlwZSBpcyBwcmVzZW50IGluIGRvbWFpbiBjb25zdGl0dWlvbiFgKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzd2FybS51cGRhdGUoc3dhcm1TZXJpYWxpc2F0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLypzd2FybSA9ICQkLnN3YXJtLnN0YXJ0KHN3YXJtVHlwZSwgc3dhcm1TZXJpYWxpc2F0aW9uKTsqL1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLmNvbW1hbmQgPT0gXCJhc3luY1JldHVyblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBjbyA9ICQkLlBTS19QdWJTdWIucHVibGlzaCgkJC5DT05TVEFOVFMuU1dBUk1fUkVUVVJOLCBzd2FybVNlcmlhbGlzYXRpb24pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1YnNjcmliZXJzIGxpc3RlbmluZyBvblwiLCAkJC5DT05TVEFOVFMuU1dBUk1fUkVUVVJOLCBjbyk7XHJcbiAgICAgICAgICAgIC8vIGNsZWFuU3dhcm1XYWl0ZXIoc3dhcm1TZXJpYWxpc2F0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLmNvbW1hbmQgPT0gXCJleGVjdXRlU3dhcm1QaGFzZVwiKSB7XHJcbiAgICAgICAgICAgIHN3YXJtLnJ1blBoYXNlKHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLnBoYXNlTmFtZSwgc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuYXJncyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGNvbW1hbmRcIiwgc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuY29tbWFuZCwgXCJpbiBzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5jb21tYW5kXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN3YXJtO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuJCQuc3dhcm1zSW5zdGFuY2VzTWFuYWdlciA9IG5ldyBTd2FybXNJbnN0YW5jZXNNYW5hZ2VyKCk7XHJcblxyXG5cclxuIiwiLypcclxuSW5pdGlhbCBMaWNlbnNlOiAoYykgQXhpb2xvZ2ljIFJlc2VhcmNoICYgQWxib2FpZSBTw65uaWPEgy5cclxuQ29udHJpYnV0b3JzOiBBeGlvbG9naWMgUmVzZWFyY2ggLCBQcml2YXRlU2t5IHByb2plY3RcclxuQ29kZSBMaWNlbnNlOiBMR1BMIG9yIE1JVC5cclxuKi9cclxuXHJcbi8vdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG4vL3ZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG5cclxuZnVuY3Rpb24gU3dhcm1MaWJyYXJ5KHByZWZpeE5hbWUsIGZvbGRlcil7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBmdW5jdGlvbiB3cmFwQ2FsbChvcmlnaW5hbCwgcHJlZml4TmFtZSl7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicHJlZml4TmFtZVwiLCBwcmVmaXhOYW1lKVxyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmVmaXggPSAkJC5saWJyYXJ5UHJlZml4O1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNMaWJyYXJ5ID0gJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnk7XHJcblxyXG4gICAgICAgICAgICAkJC5saWJyYXJ5UHJlZml4ID0gcHJlZml4TmFtZTtcclxuICAgICAgICAgICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnkgPSBzZWxmO1xyXG4gICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAkJC5saWJyYXJ5UHJlZml4ID0gcHJldmlvdXNQcmVmaXggO1xyXG4gICAgICAgICAgICAgICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnkgPSBwcmV2aW91c0xpYnJhcnk7XHJcbiAgICAgICAgICAgIH1jYXRjaChlcnIpe1xyXG4gICAgICAgICAgICAgICAgJCQubGlicmFyeVByZWZpeCA9IHByZXZpb3VzUHJlZml4IDtcclxuICAgICAgICAgICAgICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5ID0gcHJldmlvdXNMaWJyYXJ5O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICQkLmxpYnJhcmllc1twcmVmaXhOYW1lXSA9IHRoaXM7XHJcbiAgICB2YXIgcHJlZml4ZWRSZXF1aXJlID0gd3JhcENhbGwoZnVuY3Rpb24ocGF0aCl7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUocGF0aCk7XHJcbiAgICB9LCBwcmVmaXhOYW1lKTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbmNsdWRlQWxsSW5Sb290KGZvbGRlcikge1xyXG4gICAgICAgIGlmKHR5cGVvZiBmb2xkZXIgIT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgICAgIC8vd2UgYXNzdW1lIHRoYXQgaXQgaXMgYSBsaWJyYXJ5IG1vZHVsZSBwcm9wZXJseSByZXF1aXJlZCB3aXRoIHJlcXVpcmUgYW5kIGNvbnRhaW5pbmcgJCQubGlicmFyeVxyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gZm9sZGVyKXtcclxuICAgICAgICAgICAgICAgICQkLnJlZ2lzdGVyU3dhcm1EZXNjcmlwdGlvbihwcmVmaXhOYW1lLHYsIHByZWZpeE5hbWUgKyBcIi5cIiArIHYsICBmb2xkZXJbdl0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3TmFtZXMgPSAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbcHJlZml4TmFtZV07XHJcbiAgICAgICAgICAgIGZvcih2YXIgdiBpbiBuZXdOYW1lcyl7XHJcbiAgICAgICAgICAgICAgICBzZWxmW3ZdID0gIG5ld05hbWVzW3ZdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmb2xkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIHJlcyA9IHByZWZpeGVkUmVxdWlyZShmb2xkZXIpOyAvLyBhIGxpYnJhcnkgaXMganVzdCBhIG1vZHVsZVxyXG4gICAgICAgIGlmKHR5cGVvZiByZXMuX19hdXRvZ2VuZXJhdGVkX3ByaXZhdGVza3lfbGlicmFyeU5hbWUgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIHZhciBzd2FybXMgPSAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbcmVzLl9fYXV0b2dlbmVyYXRlZF9wcml2YXRlc2t5X2xpYnJhcnlOYW1lXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgc3dhcm1zID0gJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW2ZvbGRlcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdOYW1lO1xyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gc3dhcm1zKXtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTmFtZSA9IHN3YXJtc1t2XTtcclxuICAgICAgICAgICAgICAgIHNlbGZbdl0gPSBleGlzdGluZ05hbWU7XHJcbiAgICAgICAgICAgICAgICAkJC5yZWdpc3RlclN3YXJtRGVzY3JpcHRpb24ocHJlZml4TmFtZSx2LCBwcmVmaXhOYW1lICsgXCIuXCIgKyB2LCAgZXhpc3RpbmdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucyhzcGFjZSwgcHJlZml4TmFtZSl7XHJcbiAgICAgICAgdmFyIHJldCA9IHt9O1xyXG4gICAgICAgIHZhciBuYW1lcyA9IFtcImNyZWF0ZVwiLCBcImRlc2NyaWJlXCIsIFwic3RhcnRcIiwgXCJyZXN0YXJ0XCJdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bmFtZXMubGVuZ3RoOyBpKysgKXtcclxuICAgICAgICAgICAgcmV0W25hbWVzW2ldXSA9IHdyYXBDYWxsKHNwYWNlW25hbWVzW2ldXSwgcHJlZml4TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWxsZmxvd3MgICAgICAgID0gdGhpcy5jYWxsZmxvdyAgID0gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucygkJC5jYWxsZmxvd3MsIHByZWZpeE5hbWUpO1xyXG4gICAgdGhpcy5zd2FybXMgICAgICAgICAgID0gdGhpcy5zd2FybSAgICAgID0gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucygkJC5zd2FybXMsIHByZWZpeE5hbWUpO1xyXG4gICAgdGhpcy5jb250cmFjdHMgICAgICAgID0gdGhpcy5jb250cmFjdCAgID0gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucygkJC5jb250cmFjdHMsIHByZWZpeE5hbWUpO1xyXG4gICAgaW5jbHVkZUFsbEluUm9vdChmb2xkZXIsIHByZWZpeE5hbWUpO1xyXG59XHJcblxyXG5leHBvcnRzLmxvYWRMaWJyYXJ5ID0gZnVuY3Rpb24ocHJlZml4TmFtZSwgZm9sZGVyKXtcclxuICAgIHZhciBleGlzdGluZyA9ICQkLmxpYnJhcmllc1twcmVmaXhOYW1lXTtcclxuICAgIGlmKGV4aXN0aW5nICl7XHJcbiAgICAgICAgaWYoIShleGlzdGluZyBpbnN0YW5jZW9mIFN3YXJtTGlicmFyeSkpe1xyXG4gICAgICAgICAgICB2YXIgc0wgPSBuZXcgU3dhcm1MaWJyYXJ5KHByZWZpeE5hbWUsIGZvbGRlcik7XHJcbiAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiBleGlzdGluZyl7XHJcbiAgICAgICAgICAgICAgICBzTFtwcm9wXSA9IGV4aXN0aW5nW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICQkLnN5bnRheEVycm9yKFwiUmV1c2luZyBhbHJlYWR5IGxvYWRlZCBsaWJyYXJ5IFwiICsgcHJlZml4TmFtZSArIFwiY291bGQgYmUgYW4gZXJyb3IhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XHJcbiAgICB9XHJcbiAgICAvL3ZhciBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUoZm9sZGVyKTtcclxuICAgIHJldHVybiBuZXcgU3dhcm1MaWJyYXJ5KHByZWZpeE5hbWUsIGZvbGRlcik7XHJcbn1cclxuXHJcbiIsIi8qXHJcbiByZXF1aXJlIGFuZCAkJC5yZXF1aXJlIGFyZSBvdmVyd3JpdGluZyB0aGUgbm9kZS5qcyBkZWZhdWx0cyBpbiBsb2FkaW5nIG1vZHVsZXMgZm9yIGluY3JlYXNpbmcgc2VjdXJpdHksc3BlZWQgYW5kIG1ha2luZyBpdCB3b3JrIHRvIHRoZSBwcml2YXRlc2t5IHJ1bnRpbWUgYnVpbGQgd2l0aCBicm93c2VyaWZ5LlxyXG4gVGhlIHByaXZhdGVza3kgY29kZSBmb3IgZG9tYWlucyBzaG91bGQgd29yayBpbiBub2RlIGFuZCBicm93c2Vycy5cclxuICovXHJcblxyXG5cclxuaWYgKHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBnbG9iYWwgPSB3aW5kb3c7XHJcbn1cclxuXHJcblxyXG5pZiAodHlwZW9mKGdsb2JhbC4kJCkgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgZ2xvYmFsLiQkID0ge307XHJcbiAgICAkJC5fX2dsb2JhbCA9IHt9O1xyXG59XHJcblxyXG5pZiAodHlwZW9mKCQkLl9fZ2xvYmFsKSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAkJC5fX2dsb2JhbCA9IHt9O1xyXG59XHJcblxyXG5pZiAodHlwZW9mKCQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lcykgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnlOYW1lID0gbnVsbDtcclxuICAgICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lcyA9IHt9O1xyXG59XHJcblxyXG5cclxuaWYgKHR5cGVvZigkJC5fX3J1bnRpbWVNb2R1bGVzKSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAkJC5fX3J1bnRpbWVNb2R1bGVzID0ge307XHJcbn1cclxuXHJcbnJlcXVpcmUoXCIuLy4uL3N0YW5kYXJkR2xvYmFsU3ltYm9sc1wiKTtcclxuXHJcbmlmICh0eXBlb2YoZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkKSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBnbG9iYWwuZnVuY3Rpb25VbmRlZmluZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDYWxsZWQgb2YgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uISEhIVwiKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgb2YgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uXCIpO1xyXG4gICAgfTtcclxuICAgIGlmICh0eXBlb2YoZ2xvYmFsLndlYnNoaW1zUmVxdWlyZSkgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGdsb2JhbC53ZWJzaGltc1JlcXVpcmUgPSBnbG9iYWwuZnVuY3Rpb25VbmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZihnbG9iYWwuZG9tYWluUmVxdWlyZSkgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGdsb2JhbC5kb21haW5SZXF1aXJlID0gZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YoZ2xvYmFsLnBza3J1bnRpbWVSZXF1aXJlKSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgZ2xvYmFsLnBza3J1bnRpbWVSZXF1aXJlID0gZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCB3ZUFyZUluYnJvd3NlciA9ICh0eXBlb2YgKCQkLmJyb3dzZXJSdW50aW1lKSAhPSBcInVuZGVmaW5lZFwiKTtcclxuY29uc3Qgd2VBcmVJblNhbmRib3ggPSAodHlwZW9mIGdsb2JhbC5yZXF1aXJlICE9PSAndW5kZWZpbmVkJyk7XHJcblxyXG5cclxuY29uc3QgcGFzdFJlcXVlc3RzID0ge307XHJcblxyXG5mdW5jdGlvbiBwcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KSB7XHJcbiAgICBpZiAocGFzdFJlcXVlc3RzW3JlcXVlc3RdKSB7XHJcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiUHJldmVudGluZyByZWN1cnNpdmUgcmVxdWlyZSBmb3IgXCIgKyByZXF1ZXN0KTtcclxuICAgICAgICBlcnIudHlwZSA9IFwiUFNLSWdub3JhYmxlRXJyb3JcIjtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBkaXNhYmxlUmVxdWlyZShyZXF1ZXN0KSB7XHJcbiAgICBwYXN0UmVxdWVzdHNbcmVxdWVzdF0gPSB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmFibGVSZXF1aXJlKHJlcXVlc3QpIHtcclxuICAgIHBhc3RSZXF1ZXN0c1tyZXF1ZXN0XSA9IGZhbHNlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZUZyb21DYWNoZShyZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBleGlzdGluZ01vZHVsZSA9ICQkLl9fcnVudGltZU1vZHVsZXNbcmVxdWVzdF07XHJcbiAgICByZXR1cm4gZXhpc3RpbmdNb2R1bGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXBTdGVwKGNhbGxiYWNrTmFtZSkge1xyXG4gICAgY29uc3QgY2FsbGJhY2sgPSBnbG9iYWxbY2FsbGJhY2tOYW1lXTtcclxuXHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWxsYmFjayA9PT0gZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2socmVxdWVzdCk7XHJcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tyZXF1ZXN0XSA9IHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0cnlSZXF1aXJlU2VxdWVuY2Uob3JpZ2luYWxSZXF1aXJlLCByZXF1ZXN0KSB7XHJcbiAgICBsZXQgYXJyO1xyXG4gICAgaWYgKG9yaWdpbmFsUmVxdWlyZSkge1xyXG4gICAgICAgIGFyciA9ICQkLl9fcmVxdWlyZUZ1bmN0aW9uc0NoYWluLnNsaWNlKCk7XHJcbiAgICAgICAgYXJyLnB1c2gob3JpZ2luYWxSZXF1aXJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXJyID0gJCQuX19yZXF1aXJlRnVuY3Rpb25zQ2hhaW47XHJcbiAgICB9XHJcblxyXG4gICAgcHJldmVudFJlY3Vyc2l2ZVJlcXVpcmUocmVxdWVzdCk7XHJcbiAgICBkaXNhYmxlUmVxdWlyZShyZXF1ZXN0KTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBjb25zdCBwcmV2aW91c1JlcXVpcmUgPSAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWU7XHJcbiAgICBsZXQgcHJldmlvdXNSZXF1aXJlQ2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghcHJldmlvdXNSZXF1aXJlKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJMb2FkaW5nIGxpYnJhcnkgZm9yIHJlcXVpcmVcIiwgcmVxdWVzdCk7XHJcbiAgICAgICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnlOYW1lID0gcmVxdWVzdDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbcmVxdWVzdF0gPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbcmVxdWVzdF0gPSB7fTtcclxuICAgICAgICAgICAgLy8kJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzRGVzY3JpcHRpb25zW3JlcXVlc3RdICAgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNSZXF1aXJlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGZ1bmMgPSBhcnJbaV07XHJcbiAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChmdW5jID09PSBnbG9iYWwuZnVuY3Rpb25VbmRlZmluZWQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKHJlcXVlc3QpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIudHlwZSAhPT0gXCJQU0tJZ25vcmFibGVFcnJvclwiKSB7XHJcbiAgICAgICAgICAgICAgICAkJC5sb2coXCJSZXF1aXJlIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcgXCIsIHJlcXVlc3QsIFwiXFxuQ2F1c2U6XFxuXCIsIGVyci5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAkJC5sb2coXCJGYWlsZWQgdG8gbG9hZCBtb2R1bGUgXCIsIHJlcXVlc3QsIHJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlUmVxdWlyZShyZXF1ZXN0KTtcclxuICAgIGlmIChwcmV2aW91c1JlcXVpcmVDaGFuZ2VkKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVuZCBsb2FkaW5nIGxpYnJhcnkgZm9yIHJlcXVpcmVcIiwgcmVxdWVzdCwgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW3JlcXVlc3RdKTtcclxuICAgICAgICAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuaWYgKHR5cGVvZigkJC5yZXF1aXJlKSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcblxyXG4gICAgJCQuX19yZXF1aXJlTGlzdCA9IFtcIndlYnNoaW1zUmVxdWlyZVwiLCBcInBza3J1bnRpbWVSZXF1aXJlXCJdO1xyXG4gICAgJCQuX19yZXF1aXJlRnVuY3Rpb25zQ2hhaW4gPSBbXTtcclxuXHJcbiAgICAkJC5yZXF1aXJlQnVuZGxlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBuYW1lICs9IFwiUmVxdWlyZVwiO1xyXG4gICAgICAgICQkLl9fcmVxdWlyZUxpc3QucHVzaChuYW1lKTtcclxuICAgICAgICBjb25zdCBhcnIgPSBbcmVxdWlyZUZyb21DYWNoZV07XHJcbiAgICAgICAgJCQuX19yZXF1aXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gd3JhcFN0ZXAoaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICQkLl9fcmVxdWlyZUZ1bmN0aW9uc0NoYWluID0gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAkJC5yZXF1aXJlQnVuZGxlKFwiaW5pdFwiKTtcclxuXHJcbiAgICBpZiAod2VBcmVJbmJyb3dzZXIpIHtcclxuICAgICAgICAkJC5sb2coXCJEZWZpbmluZyBnbG9iYWwgcmVxdWlyZSBpbiBicm93c2VyXCIpO1xyXG5cclxuXHJcbiAgICAgICAgZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG5cclxuICAgICAgICAgICAgLy8vKltyZXF1aXJlRnJvbUNhY2hlLCB3cmFwU3RlcCh3ZWJzaGltc1JlcXVpcmUpLCAsIHdyYXBTdGVwKHBza3J1bnRpbWVSZXF1aXJlKSwgd3JhcFN0ZXAoZG9tYWluUmVxdWlyZSkqXVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ5UmVxdWlyZVNlcXVlbmNlKG51bGwsIHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZVxyXG4gICAgICAgIGlmICh3ZUFyZUluU2FuZGJveCkge1xyXG4gICAgICAgIC8vIHJlcXVpcmUgc2hvdWxkIGJlIHByb3ZpZGVkIHdoZW4gY29kZSBpcyBsb2FkZWQgaW4gYnJvd3NlcmlmeVxyXG4gICAgICAgIGNvbnN0IGJ1bmRsZVJlcXVpcmUgPSByZXF1aXJlO1xyXG5cclxuICAgICAgICAkJC5yZXF1aXJlQnVuZGxlKCdzYW5kYm94QmFzZScpO1xyXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHNldCB1cCBieSBzYW5kYm94IHByaW9yIHRvXHJcbiAgICAgICAgY29uc3Qgc2FuZGJveFJlcXVpcmUgPSBnbG9iYWwucmVxdWlyZTtcclxuICAgICAgICBnbG9iYWwuY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5ld0xvYWRlcihyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV3TG9hZGVyOlwiLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgLy9wcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndHJ5aW5nIHRvIGxvYWQgJywgcmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB0cnlCdW5kbGVSZXF1aXJlKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuICQkLl9fb3JpZ2luYWxSZXF1aXJlLmFwcGx5KHNlbGYsYXJncyk7XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBNb2R1bGUuX2xvYWQuYXBwbHkoc2VsZixhcmdzKVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlcztcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gc2FuZGJveFJlcXVpcmUuYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiTU9EVUxFX05PVF9GT1VORFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHNhbmRib3hSZXF1aXJlLmFwcGx5KHNlbGYsIFtwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHRyeVJlcXVpcmVTZXF1ZW5jZSh0cnlCdW5kbGVSZXF1aXJlLCByZXF1ZXN0KTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2xvYmFsLnJlcXVpcmUgPSBuZXdMb2FkZXI7XHJcblxyXG4gICAgfSBlbHNlIHsgIC8vd2UgYXJlIGluIG5vZGVcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tcImNyeXB0b1wiXSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XHJcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tcInV0aWxcIl0gPSByZXF1aXJlKFwidXRpbFwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgTW9kdWxlID0gcmVxdWlyZSgnbW9kdWxlJyk7XHJcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tcIm1vZHVsZVwiXSA9IE1vZHVsZTtcclxuXHJcbiAgICAgICAgJCQubG9nKFwiUmVkZWZpbmluZyByZXF1aXJlIGZvciBub2RlXCIpO1xyXG5cclxuICAgICAgICAkJC5fX29yaWdpbmFsUmVxdWlyZSA9IE1vZHVsZS5fbG9hZDtcclxuICAgICAgICBjb25zdCBtb2R1bGVPcmlnaW5hbFJlcXVpcmUgPSBNb2R1bGUucHJvdG90eXBlLnJlcXVpcmU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5ld0xvYWRlcihyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV3TG9hZGVyOlwiLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgLy9wcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBvcmlnaW5hbFJlcXVpcmUoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gJCQuX19vcmlnaW5hbFJlcXVpcmUuYXBwbHkoc2VsZixhcmdzKTtcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIE1vZHVsZS5fbG9hZC5hcHBseShzZWxmLGFyZ3MpXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBtb2R1bGVPcmlnaW5hbFJlcXVpcmUuYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiTU9EVUxFX05PVF9GT1VORFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IG1vZHVsZU9yaWdpbmFsUmVxdWlyZS5hcHBseShzZWxmLCBbcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3VycmVudEZvbGRlclJlcXVpcmUocmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vW3JlcXVpcmVGcm9tQ2FjaGUsIHdyYXBTdGVwKHBza3J1bnRpbWVSZXF1aXJlKSwgd3JhcFN0ZXAoZG9tYWluUmVxdWlyZSksIG9yaWdpbmFsUmVxdWlyZV1cclxuICAgICAgICAgICAgcmV0dXJuIHRyeVJlcXVpcmVTZXF1ZW5jZShvcmlnaW5hbFJlcXVpcmUsIHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gbmV3TG9hZGVyO1xyXG4gICAgfVxyXG5cclxuICAgICQkLnJlcXVpcmUgPSByZXF1aXJlO1xyXG59XHJcbiIsIlxyXG52YXIgZ2xvYmFsSm9pbkNvdW50ZXIgPSAwO1xyXG5cclxuZnVuY3Rpb24gUGFyYWxsZWxKb2luUG9pbnQoc3dhcm0sIGNhbGxiYWNrLCBhcmdzKXtcclxuICAgIGdsb2JhbEpvaW5Db3VudGVyKys7XHJcbiAgICB2YXIgY2hhbm5lbElkID0gXCJQYXJhbGxlbEpvaW5Qb2ludFwiICsgZ2xvYmFsSm9pbkNvdW50ZXI7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgY291bnRlciA9IDA7XHJcbiAgICB2YXIgc3RvcE90aGVyRXhlY3V0aW9uICAgICA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGV4ZWN1dGlvblN0ZXAoc3RlcEZ1bmMsIGxvY2FsQXJncywgc3RvcCl7XHJcblxyXG4gICAgICAgIHRoaXMuZG9FeGVjdXRlID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYoc3RvcE90aGVyRXhlY3V0aW9uKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICBzdGVwRnVuYy5hcHBseShzd2FybSwgbG9jYWxBcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmKHN0b3Ape1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BPdGhlckV4ZWN1dGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vZXZlcnl0aW5nIGlzIGZpbmVcclxuICAgICAgICAgICAgfSBjYXRjaChlcnIpe1xyXG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGVycik7XHJcbiAgICAgICAgICAgICAgICBzZW5kRm9yU291bmRFeGVjdXRpb24oY2FsbGJhY2ssIGFyZ3MsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL3N0b3AgaXQsIGRvIG5vdCBjYWxsIGFnYWluIGFueXRoaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xyXG4gICAgICAgICQkLnN5bnRheEVycm9yKFwiaW52YWxpZCBqb2luXCIsc3dhcm0sIFwiaW52YWxpZCBmdW5jdGlvbiBhdCBqb2luIGluIHN3YXJtXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAkJC5QU0tfUHViU3ViLnN1YnNjcmliZShjaGFubmVsSWQsZnVuY3Rpb24oZm9yRXhlY3V0aW9uKXtcclxuICAgICAgICBpZihzdG9wT3RoZXJFeGVjdXRpb24pe1xyXG4gICAgICAgICAgICByZXR1cm4gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBpZihmb3JFeGVjdXRpb24uZG9FeGVjdXRlKCkpe1xyXG4gICAgICAgICAgICAgICAgZGVjQ291bnRlcigpO1xyXG4gICAgICAgICAgICB9IC8vIGhhZCBhbiBlcnJvci4uLlxyXG4gICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgJCQuaW5mbyhlcnIpO1xyXG4gICAgICAgICAgICAvLyQkLmVycm9ySGFuZGxlci5zeW50YXhFcnJvcihcIl9faW50ZXJuYWxfX1wiLHN3YXJtLCBcImV4Y2VwdGlvbiBpbiB0aGUgZXhlY3V0aW9uIG9mIHRoZSBqb2luIGZ1bmN0aW9uIG9mIGEgcGFyYWxsZWwgdGFza1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbmNDb3VudGVyKCl7XHJcbiAgICAgICAgaWYodGVzdElmVW5kZXJJbnNwZWN0aW9uKCkpe1xyXG4gICAgICAgICAgICAvL3ByZXZlbnRpbmcgaW5zcGVjdG9yIGZyb20gaW5jcmVhc2luZyBjb3VudGVyIHdoZW4gcmVhZGluZyB0aGUgdmFsdWVzIGZvciBkZWJ1ZyByZWFzb25cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInByZXZlbnRpbmcgaW5zcGVjdGlvblwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudGVyKys7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdElmVW5kZXJJbnNwZWN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHJlcyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBjb25zdEFyZ3YgPSBwcm9jZXNzLmV4ZWNBcmd2LmpvaW4oKTtcclxuICAgICAgICBpZihjb25zdEFyZ3YuaW5kZXhPZihcImluc3BlY3RcIikhPT0tMSB8fCBjb25zdEFyZ3YuaW5kZXhPZihcImRlYnVnXCIpIT09LTEpe1xyXG4gICAgICAgICAgICAvL29ubHkgd2hlbiBydW5uaW5nIGluIGRlYnVnXHJcbiAgICAgICAgICAgIHZhciBjYWxsc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcclxuICAgICAgICAgICAgaWYoY2FsbHN0YWNrLmluZGV4T2YoXCJEZWJ1Z0NvbW1hbmRQcm9jZXNzb3JcIikhPT0tMSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlYnVnQ29tbWFuZFByb2Nlc3NvciBkZXRlY3RlZCFcIik7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VuZEZvclNvdW5kRXhlY3V0aW9uKGZ1bmN0LCBhcmdzLCBzdG9wKXtcclxuICAgICAgICB2YXIgb2JqID0gbmV3IGV4ZWN1dGlvblN0ZXAoZnVuY3QsIGFyZ3MsIHN0b3ApO1xyXG4gICAgICAgICQkLlBTS19QdWJTdWIucHVibGlzaChjaGFubmVsSWQsIG9iaik7IC8vIGZvcmNlIGV4ZWN1dGlvbiB0byBiZSBcInNvdW5kXCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNDb3VudGVyKCl7XHJcbiAgICAgICAgY291bnRlci0tO1xyXG4gICAgICAgIGlmKGNvdW50ZXIgPT0gMCkge1xyXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XHJcbiAgICAgICAgICAgIHNlbmRGb3JTb3VuZEV4ZWN1dGlvbihjYWxsYmFjaywgYXJncywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5uZXIgPSBzd2FybS5nZXRJbm5lclZhbHVlKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByb2dyZXNzUmVwb3J0KGVyciwgcmVzKXtcclxuICAgICAgICBpZihlcnIpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OlwiUGFyYWxsZWwgZXhlY3V0aW9uIHByb2dyZXNzIGV2ZW50XCIsXHJcbiAgICAgICAgICAgIHN3YXJtOnN3YXJtLFxyXG4gICAgICAgICAgICBhcmdzOmFyZ3MsXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZXN1bHQ6cmVzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBta0Z1bmN0aW9uKG5hbWUpe1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcclxuICAgICAgICAgICAgdmFyIGYgPSBkZWZhdWx0UHJvZ3Jlc3NSZXBvcnQ7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgIT0gXCJwcm9ncmVzc1wiKXtcclxuICAgICAgICAgICAgICAgIGYgPSBpbm5lci5teUZ1bmN0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9ICQkLl9faW50ZXJuLm1rQXJncyhhcmdzLCAwKTtcclxuICAgICAgICAgICAgc2VuZEZvclNvdW5kRXhlY3V0aW9uKGYsIGFyZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fcHJveHlPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpe1xyXG4gICAgICAgIGlmKGlubmVyLm15RnVuY3Rpb25zLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3AgPT0gXCJwcm9ncmVzc1wiKXtcclxuICAgICAgICAgICAgaW5jQ291bnRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWtGdW5jdGlvbihwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN3YXJtW3Byb3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX19wcm94eU9iamVjdDtcclxuXHJcbiAgICB0aGlzLl9fc2V0UHJveHlPYmplY3QgPSBmdW5jdGlvbihwKXtcclxuICAgICAgICBfX3Byb3h5T2JqZWN0ID0gcDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0cy5jcmVhdGVKb2luUG9pbnQgPSBmdW5jdGlvbihzd2FybSwgY2FsbGJhY2ssIGFyZ3Mpe1xyXG4gICAgdmFyIGpwID0gbmV3IFBhcmFsbGVsSm9pblBvaW50KHN3YXJtLCBjYWxsYmFjaywgYXJncyk7XHJcbiAgICB2YXIgaW5uZXIgPSBzd2FybS5nZXRJbm5lclZhbHVlKCk7XHJcbiAgICB2YXIgcCA9IG5ldyBQcm94eShpbm5lciwganApO1xyXG4gICAganAuX19zZXRQcm94eU9iamVjdChwKTtcclxuICAgIHJldHVybiBwO1xyXG59OyIsIlxyXG52YXIgam9pbkNvdW50ZXIgPSAwO1xyXG5cclxuZnVuY3Rpb24gU2VyaWFsSm9pblBvaW50KHN3YXJtLCBjYWxsYmFjaywgYXJncyl7XHJcblxyXG4gICAgam9pbkNvdW50ZXIrKztcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgY2hhbm5lbElkID0gXCJTZXJpYWxKb2luUG9pbnRcIiArIGpvaW5Db3VudGVyO1xyXG5cclxuICAgIGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcclxuICAgICAgICAkJC5zeW50YXhFcnJvcihcInVua25vd25cIiwgc3dhcm0sIFwiaW52YWxpZCBmdW5jdGlvbiBnaXZlbiB0byBzZXJpYWwgaW4gc3dhcm1cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbm5lciA9IHN3YXJtLmdldElubmVyVmFsdWUoKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByb2dyZXNzUmVwb3J0KGVyciwgcmVzKXtcclxuICAgICAgICBpZihlcnIpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgZnVuY3Rpb25Db3VudGVyICAgICA9IDA7XHJcbiAgICB2YXIgZXhlY3V0aW9uQ291bnRlciAgICA9IDA7XHJcblxyXG4gICAgdmFyIHBsYW5uZWRFeGVjdXRpb25zICAgPSBbXTtcclxuICAgIHZhciBwbGFubmVkQXJndW1lbnRzICAgID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gbWtGdW5jdGlvbihuYW1lLCBwb3Mpe1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDcmVhdGluZyBmdW5jdGlvbiBcIiwgbmFtZSwgcG9zKTtcclxuICAgICAgICBwbGFubmVkQXJndW1lbnRzW3Bvc10gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXROZXh0U3RlcCgpe1xyXG4gICAgICAgICAgICBpZihwbGFubmVkRXhlY3V0aW9ucy5sZW5ndGggPT0gZXhlY3V0aW9uQ291bnRlciB8fCBwbGFubmVkQXJndW1lbnRzW2V4ZWN1dGlvbkNvdW50ZXJdICkgIHtcclxuICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIucHVibGlzaChjaGFubmVsSWQsIHNlbGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uICguLi5hcmdzKXtcclxuICAgICAgICAgICAgaWYoZXhlY3V0aW9uQ291bnRlciAhPSBwb3MpIHtcclxuICAgICAgICAgICAgICAgIHBsYW5uZWRBcmd1bWVudHNbcG9zXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRGVsYXlpbmcgZnVuY3Rpb246XCIsIGV4ZWN1dGlvbkNvdW50ZXIsIHBvcywgcGxhbm5lZEFyZ3VtZW50cywgYXJndW1lbnRzLCBmdW5jdGlvbkNvdW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fcHJveHk7XHJcbiAgICAgICAgICAgIH0gZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKHBsYW5uZWRBcmd1bWVudHNbcG9zXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkV4ZWN1dGluZyAgZnVuY3Rpb246XCIsIGV4ZWN1dGlvbkNvdW50ZXIsIHBvcywgcGxhbm5lZEFyZ3VtZW50cywgYXJndW1lbnRzLCBmdW5jdGlvbkNvdW50ZXIpO1xyXG5cdFx0XHRcdFx0YXJncyA9IHBsYW5uZWRBcmd1bWVudHNbcG9zXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhbm5lZEFyZ3VtZW50c1twb3NdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2V0TmV4dFN0ZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19wcm94eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGYgPSBkZWZhdWx0UHJvZ3Jlc3NSZXBvcnQ7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgIT0gXCJwcm9ncmVzc1wiKXtcclxuICAgICAgICAgICAgICAgIGYgPSBpbm5lci5teUZ1bmN0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIGYuYXBwbHkoc2VsZixhcmdzKTtcclxuICAgICAgICAgICAgfSBjYXRjaChlcnIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHN3YXJtLGFyZ3MpOyAvL2Vycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgJCQuUFNLX1B1YlN1Yi51bnN1YnNjcmliZShjaGFubmVsSWQscnVuTmV4dEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy90ZXJtaW5hdGUgZXhlY3V0aW9uIHdpdGggYW4gZXJyb3IuLi4hXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhlY3V0aW9uQ291bnRlcisrO1xyXG5cclxuICAgICAgICAgICAgdHJpZ2dldE5leHRTdGVwKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX19wcm94eTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwbGFubmVkRXhlY3V0aW9ucy5wdXNoKGYpO1xyXG4gICAgICAgIGZ1bmN0aW9uQ291bnRlcisrO1xyXG4gICAgICAgIHJldHVybiBmO1xyXG4gICAgfVxyXG5cclxuICAgICB2YXIgZmluaXNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICBmdW5jdGlvbiBydW5OZXh0RnVuY3Rpb24oKXtcclxuICAgICAgICBpZihleGVjdXRpb25Db3VudGVyID09IHBsYW5uZWRFeGVjdXRpb25zLmxlbmd0aCApe1xyXG4gICAgICAgICAgICBpZighZmluaXNoZWQpe1xyXG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc3dhcm0sYXJncyk7XHJcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAkJC5QU0tfUHViU3ViLnVuc3Vic2NyaWJlKGNoYW5uZWxJZCxydW5OZXh0RnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZXJpYWwgY29uc3RydWN0IGlzIHVzaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuLi5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwbGFubmVkRXhlY3V0aW9uc1tleGVjdXRpb25Db3VudGVyXSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAkJC5QU0tfUHViU3ViLnN1YnNjcmliZShjaGFubmVsSWQscnVuTmV4dEZ1bmN0aW9uKTsgLy8gZm9yY2UgaXQgdG8gYmUgXCJzb3VuZFwiXHJcblxyXG5cclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCByZWNlaXZlcil7XHJcbiAgICAgICAgaWYocHJvcCA9PSBcInByb2dyZXNzXCIgfHwgaW5uZXIubXlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gbWtGdW5jdGlvbihwcm9wLCBmdW5jdGlvbkNvdW50ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3dhcm1bcHJvcF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9fcHJveHk7XHJcbiAgICB0aGlzLnNldFByb3h5T2JqZWN0ID0gZnVuY3Rpb24ocCl7XHJcbiAgICAgICAgX19wcm94eSA9IHA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuY3JlYXRlU2VyaWFsSm9pblBvaW50ID0gZnVuY3Rpb24oc3dhcm0sIGNhbGxiYWNrLCBhcmdzKXtcclxuICAgIHZhciBqcCA9IG5ldyBTZXJpYWxKb2luUG9pbnQoc3dhcm0sIGNhbGxiYWNrLCBhcmdzKTtcclxuICAgIHZhciBpbm5lciA9IHN3YXJtLmdldElubmVyVmFsdWUoKTtcclxuICAgIHZhciBwID0gbmV3IFByb3h5KGlubmVyLCBqcCk7XHJcbiAgICBqcC5zZXRQcm94eU9iamVjdChwKTtcclxuICAgIHJldHVybiBwO1xyXG59IiwiY29uc3QgT3dNID0gcmVxdWlyZShcInN3YXJtdXRpbHNcIikuT3dNO1xyXG5cclxudmFyIHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnkgPSB7fTtcclxubGV0IGN1cnJlbnRJbmxpbmVDb3VudGVyID0gMDtcclxuXHJcbiQkLnJlZ2lzdGVyU3dhcm1EZXNjcmlwdGlvbiA9ICBmdW5jdGlvbihsaWJyYXJ5TmFtZSwgc2hvcnROYW1lLCBzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbil7XHJcbiAgICBpZighJCQubGlicmFyaWVzW2xpYnJhcnlOYW1lXSl7XHJcbiAgICAgICAgJCQubGlicmFyaWVzW2xpYnJhcnlOYW1lXSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCEkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbbGlicmFyeU5hbWVdKXtcclxuICAgICAgICAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbbGlicmFyeU5hbWVdID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgJCQubGlicmFyaWVzW2xpYnJhcnlOYW1lXVtzaG9ydE5hbWVdID0gZGVzY3JpcHRpb247XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiUmVnaXN0ZXJpbmcgXCIsIGxpYnJhcnlOYW1lLHNob3J0TmFtZSwgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnlOYW1lKTtcclxuICAgIGlmKCQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSl7XHJcbiAgICAgICAgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzWyQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZV1bc2hvcnROYW1lXSA9IGxpYnJhcnlOYW1lICsgXCIuXCIgKyBzaG9ydE5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW2xpYnJhcnlOYW1lXVtzaG9ydE5hbWVdID0gc3dhcm1UeXBlTmFtZTtcclxuXHJcbiAgICBpZih0eXBlb2YgZGVzY3JpcHRpb24gPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgZGVzY3JpcHRpb24gPSBzd2FybURlc2NyaXB0aW9uc1JlZ2lzdHJ5W2Rlc2NyaXB0aW9uXTtcclxuICAgIH1cclxuICAgIHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV0gPSBkZXNjcmlwdGlvbjtcclxufVxyXG5cclxuXHJcbnZhciBjdXJyZW50TGlicmFyeUNvdW50ZXIgPSAwO1xyXG4kJC5saWJyYXJ5ID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgY3VycmVudExpYnJhcnlDb3VudGVyKys7XHJcbiAgICB2YXIgcHJldmlvdXNDdXJyZW50TGlicmFyeSA9ICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZTtcclxuICAgIHZhciBsaWJyYXJ5TmFtZSA9IFwiX19fcHJpdmF0ZXNreV9saWJyYXJ5XCIrY3VycmVudExpYnJhcnlDb3VudGVyO1xyXG4gICAgdmFyIHJldCA9ICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1tsaWJyYXJ5TmFtZV0gPSB7fTtcclxuICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSA9IGxpYnJhcnlOYW1lO1xyXG4gICAgY2FsbGJhY2soKTtcclxuICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSA9IHByZXZpb3VzQ3VycmVudExpYnJhcnk7XHJcbiAgICByZXQuX19hdXRvZ2VuZXJhdGVkX3ByaXZhdGVza3lfbGlicmFyeU5hbWUgPSBsaWJyYXJ5TmFtZTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcblxyXG4kJC5maXhTd2FybU5hbWUgPSBmdW5jdGlvbihzaG9ydE5hbWUpe1xyXG4gICAgbGV0IGZ1bGxOYW1lO1xyXG4gICAgaWYoc2hvcnROYW1lICYmIHNob3J0TmFtZS5pbmNsdWRlcyhcIi5cIikpIHtcclxuICAgICAgICBmdWxsTmFtZSA9IHNob3J0TmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZnVsbE5hbWUgPSAkJC5saWJyYXJ5UHJlZml4ICsgXCIuXCIgKyBzaG9ydE5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVsbE5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFN3YXJtU3BhY2Uoc3dhcm1UeXBlLCB1dGlscykge1xyXG5cclxuICAgIGxldCBiZWVzSGVhbGVyID0gcmVxdWlyZShcInN3YXJtdXRpbHNcIikuYmVlc0hlYWxlcjtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGdWxsTmFtZShzaG9ydE5hbWUpe1xyXG4gICAgICAgIHJldHVybiAkJC5maXhTd2FybU5hbWUoc2hvcnROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYXJEZXNjcmlwdGlvbihkZXNjKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbml0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0b3JlOmZ1bmN0aW9uKGpzb25TdHJpbmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvSnNvblN0cmluZzpmdW5jdGlvbih4KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBTd2FybURlc2NyaXB0aW9uKHN3YXJtVHlwZU5hbWUsIGRlc2NyaXB0aW9uKXtcclxuXHJcbiAgICAgICAgc3dhcm1UeXBlTmFtZSA9IGdldEZ1bGxOYW1lKHN3YXJtVHlwZU5hbWUpO1xyXG5cclxuICAgICAgICB2YXIgbG9jYWxJZCA9IDA7ICAvLyB1bmlxdWUgZm9yIGVhY2ggc3dhcm1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmFycyhkZXNjcil7XHJcbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge307XHJcbiAgICAgICAgICAgIGZvcih2YXIgdiBpbiBkZXNjcil7XHJcbiAgICAgICAgICAgICAgICBtZW1iZXJzW3ZdID0gbmV3IFZhckRlc2NyaXB0aW9uKGRlc2NyW3ZdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVtYmVycztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZU1lbWJlcnMoZGVzY3Ipe1xyXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gZGVzY3JpcHRpb24pe1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHYgIT0gXCJwdWJsaWNcIiAmJiB2ICE9IFwicHJpdmF0ZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW3ZdID0gZGVzY3JpcHRpb25bdl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHVibGljVmFycyA9IGNyZWF0ZVZhcnMoZGVzY3JpcHRpb24ucHVibGljKTtcclxuICAgICAgICB2YXIgcHJpdmF0ZVZhcnMgPSBjcmVhdGVWYXJzKGRlc2NyaXB0aW9uLnByaXZhdGUpO1xyXG4gICAgICAgIHZhciBteUZ1bmN0aW9ucyA9IGNyZWF0ZU1lbWJlcnMoZGVzY3JpcHRpb24pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQaGFzZSh0aGlzSW5zdGFuY2UsIGZ1bmMsIHBoYXNlTmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBrZXlCZWZvcmUgPSBgJHtzd2FybVR5cGVOYW1lfS8ke3BoYXNlTmFtZX0vJHskJC5DT05TVEFOVFMuQkVGT1JFX0lOVEVSQ0VQVE9SfWA7XHJcbiAgICAgICAgICAgIHZhciBrZXlBZnRlciA9IGAke3N3YXJtVHlwZU5hbWV9LyR7cGhhc2VOYW1lfS8keyQkLkNPTlNUQU5UUy5BRlRFUl9JTlRFUkNFUFRPUn1gO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBoYXNlID0gZnVuY3Rpb24oLi4uYXJncyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0O1xyXG4gICAgICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIuYmxvY2tDYWxsQmFja3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzSW5zdGFuY2Uuc2V0TWV0YWRhdGEoJ3BoYXNlTmFtZScsIHBoYXNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJCQuaW50ZXJjZXB0b3IuY2FsbEludGVyY2VwdG9ycyhrZXlCZWZvcmUsIHRoaXNJbnN0YW5jZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZnVuYy5hcHBseSh0aGlzSW5zdGFuY2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICQkLmludGVyY2VwdG9yLmNhbGxJbnRlcmNlcHRvcnMoa2V5QWZ0ZXIsIHRoaXNJbnN0YW5jZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJCQuUFNLX1B1YlN1Yi5yZWxlYXNlQ2FsbEJhY2tzKCk7XHJcbiAgICAgICAgICAgICAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgICAgICAgICAkJC5QU0tfUHViU3ViLnJlbGVhc2VDYWxsQmFja3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZHluYW1pYyBuYW1lZCBmdW5jIGluIG9yZGVyIHRvIGltcHJvdmUgY2FsbHN0YWNrXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwaGFzZSwgXCJuYW1lXCIsIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN3YXJtVHlwZU5hbWUrXCIuXCIrZnVuYy5uYW1lfX0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGhhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluaXRpYWxpc2UgPSBmdW5jdGlvbihzZXJpYWxpc2VkVmFsdWVzKXtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT3dNKHtcclxuICAgICAgICAgICAgICAgIHB1YmxpY1ZhcnM6e1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcml2YXRlVmFyczp7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByb3RlY3RlZFZhcnM6e1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBteUZ1bmN0aW9uczp7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHV0aWxpdHlGdW5jdGlvbnM6e1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtZXRhOntcclxuICAgICAgICAgICAgICAgICAgICBzd2FybVR5cGVOYW1lOnN3YXJtVHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcm1EZXNjcmlwdGlvbjpkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gcHVibGljVmFycyl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVibGljVmFyc1t2XSA9IHB1YmxpY1ZhcnNbdl0uaW5pdCgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciB2IGluIHByaXZhdGVWYXJzKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wcml2YXRlVmFyc1t2XSA9IHByaXZhdGVWYXJzW3ZdLmluaXQoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICBpZihzZXJpYWxpc2VkVmFsdWVzKXtcclxuICAgICAgICAgICAgICAgIGJlZXNIZWFsZXIuanNvblRvTmF0aXZlKHNlcmlhbGlzZWRWYWx1ZXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmluaXRpYWxpc2VGdW5jdGlvbnMgPSBmdW5jdGlvbih2YWx1ZU9iamVjdCwgdGhpc09iamVjdCl7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gbXlGdW5jdGlvbnMpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWVPYmplY3QubXlGdW5jdGlvbnNbdl0gPSBjcmVhdGVQaGFzZSh0aGlzT2JqZWN0LCBteUZ1bmN0aW9uc1t2XSwgdik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBsb2NhbElkKys7XHJcbiAgICAgICAgICAgIHZhbHVlT2JqZWN0LnV0aWxpdHlGdW5jdGlvbnMgPSB1dGlscy5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpe1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHB1YmxpY1ZhcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnB1YmxpY1ZhcnNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihwcml2YXRlVmFycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQucHJpdmF0ZVZhcnNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0YXJnZXQudXRpbGl0eUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnV0aWxpdHlGdW5jdGlvbnNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYobXlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm15RnVuY3Rpb25zW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGFyZ2V0LnByb3RlY3RlZFZhcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnByb3RlY3RlZFZhcnNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0eXBlb2YgcHJvcGVydHkgIT0gXCJzeW1ib2xcIikge1xyXG4gICAgICAgICAgICAgICAgJCQuc3ludGF4RXJyb3IocHJvcGVydHksIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRhcmdldC51dGlsaXR5RnVuY3Rpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSB8fCB0YXJnZXQubXlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAkJC5zeW50YXhFcnJvcihwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gb3ZlcndyaXRlIGltbXV0YWJsZSBtZW1iZXJcIiArIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocHJpdmF0ZVZhcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJpdmF0ZVZhcnNbcHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBpZihwdWJsaWNWYXJzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1YmxpY1ZhcnNbcHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJvdGVjdGVkVmFyc1twcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3Qpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb3h5IGFwcGx5XCIpO1xyXG4gICAgICAgICAgICAvL3ZhciBmdW5jID0gdGFyZ2V0W11cclxuICAgICAgICAgICAgLy9zd2FybUdsb2JhbHMuZXhlY3V0aW9uUHJvdmlkZXIuZXhlY3V0ZShudWxsLCB0aGlzQXJnLCBmdW5jLCBhcmd1bWVudHNMaXN0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5oYXMgPSBmdW5jdGlvbih0YXJnZXQsIHByb3ApIHtcclxuICAgICAgICAgICAgaWYodGFyZ2V0LnB1YmxpY1ZhcnNbcHJvcF0gfHwgdGFyZ2V0LnByb3RlY3RlZFZhcnNbcHJvcF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm93bktleXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQucHVibGljVmFycyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmlhbGlzZWRWYWx1ZXMpe1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVPYmplY3QgPSBzZWxmLmluaXRpYWxpc2Uoc2VyaWFsaXNlZFZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUHJveHkodmFsdWVPYmplY3Qsc2VsZik7XHJcbiAgICAgICAgICAgIHNlbGYuaW5pdGlhbGlzZUZ1bmN0aW9ucyh2YWx1ZU9iamVjdCxyZXN1bHQpO1xyXG5cdFx0XHRpZighc2VyaWFsaXNlZFZhbHVlcyl7XHJcblx0XHRcdFx0aWYoIXZhbHVlT2JqZWN0LmdldE1ldGEoXCJzd2FybUlkXCIpKXtcclxuXHRcdFx0XHRcdHZhbHVlT2JqZWN0LnNldE1ldGEoXCJzd2FybUlkXCIsICQkLnVpZEdlbmVyYXRvci5zYWZlX3V1aWQoKSk7ICAvL2RvIG5vdCBvdmVyd3JpdGUhISFcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFsdWVPYmplY3QudXRpbGl0eUZ1bmN0aW9ucy5ub3RpZnkoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYocmVzdWx0LmF1dG9Jbml0KXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRvSW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgJCQuZml4TWUoXCJSZWluc3RhdGUgc29tZWhvdyB0aGUgbmV4dCBjb21tZW50XCIpXHJcbiAgICAgICAgICAgICAgICAvL3Jlc3VsdC5hdXRvSW5pdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHRoaXMuZGVzY3JpYmUgPSBmdW5jdGlvbiBkZXNjcmliZVN3YXJtKHN3YXJtVHlwZU5hbWUsIGRlc2NyaXB0aW9uKXtcclxuICAgICAgICBzd2FybVR5cGVOYW1lID0gZ2V0RnVsbE5hbWUoc3dhcm1UeXBlTmFtZSk7XHJcblxyXG4gICAgICAgIHZhciBwb2ludFBvcyA9IHN3YXJtVHlwZU5hbWUubGFzdEluZGV4T2YoJy4nKTtcclxuICAgICAgICB2YXIgc2hvcnROYW1lID0gc3dhcm1UeXBlTmFtZS5zdWJzdHIoIHBvaW50UG9zKyAxKTtcclxuICAgICAgICB2YXIgbGlicmFyeU5hbWUgPSBzd2FybVR5cGVOYW1lLnN1YnN0cigwLCBwb2ludFBvcyk7XHJcbiAgICAgICAgaWYoIWxpYnJhcnlOYW1lKXtcclxuICAgICAgICAgICAgbGlicmFyeU5hbWUgPSBcImdsb2JhbFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gbmV3IFN3YXJtRGVzY3JpcHRpb24oc3dhcm1UeXBlTmFtZSwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIGlmKHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV0gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgJCQud2FybihcIkR1cGxpY2F0ZSBzd2FybSBkZXNjcmlwdGlvbiBcIisgc3dhcm1UeXBlTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3N3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV0gPSBkZXNjcmlwdGlvbjtcclxuXHRcdCQkLnJlZ2lzdGVyU3dhcm1EZXNjcmlwdGlvbihsaWJyYXJ5TmFtZSwgc2hvcnROYW1lLCBzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbik7XHJcblxyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgJCQuZml4TWUoXCJUaGlzIGNvdWxkIGdlbmVyYXRlIG1lbW9yeSBsZWFrcy4gRml4IGl0IGxhdGVyXCIpO1xyXG4gICAgdGhpcy5pbmxpbmUgPSBmdW5jdGlvbiBpbmxpbmUoZGVzY3JpcHRpb24sIC4uLmFyZ3Mpe1xyXG4gICAgICAgIGN1cnJlbnRJbmxpbmVDb3VudGVyKys7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBzZWxmLmRlc2NyaWJlKFwiaW5saW5lU3dhcm1cIiArIGN1cnJlbnRJbmxpbmVDb3VudGVyLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgdmFyIGZsb3cgPSBkZXNjKCk7XHJcbiAgICAgICAgZmxvdy5zdGFydCguLi5hcmdzKTtcclxuICAgICAgICByZXR1cm4gZmxvdztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgJCQuZXJyKFwiQ3JlYXRlIEFQSXMgZm9yIGNyZWF0aW9uIG9mIHN3YXJtcyB3YXMgIHJlbW92ZWQuIFVzZSBkZXNjcmliZSFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb250aW51ZSA9IGZ1bmN0aW9uKHN3YXJtVHlwZU5hbWUsIGluaXRpYWxWYWx1ZXMpe1xyXG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcclxuICAgICAgICB2YXIgZGVzYyA9IHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV07XHJcblxyXG4gICAgICAgIGlmKGRlc2Mpe1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzYyhpbml0aWFsVmFsdWVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkJC5zeW50YXhFcnJvcihzd2FybVR5cGVOYW1lLGluaXRpYWxWYWx1ZXMsXHJcbiAgICAgICAgICAgICAgICBcIkZhaWxlZCB0byByZXN0YXJ0IGEgc3dhcm0gd2l0aCB0eXBlIFwiICsgc3dhcm1UeXBlTmFtZSArIFwiXFxuIE1heWJlIGRpZmZlcmVudCBzd2FybSBzcGFjZSAodXNlZCBmbG93IGluc3RlYWQgb2Ygc3dhcm0hPylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihzd2FybVR5cGVOYW1lLCBjdG9yLCAuLi5wYXJhbXMpe1xyXG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcclxuICAgICAgICB2YXIgZGVzYyA9IHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV07XHJcbiAgICAgICAgaWYoIWRlc2Mpe1xyXG4gICAgICAgICAgICAkJC5zeW50YXhFcnJvcihudWxsLCBzd2FybVR5cGVOYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXMgPSBkZXNjKCk7XHJcbiAgICAgICAgcmVzLnNldE1ldGFkYXRhKFwiaG9tZVNlY3VyaXR5Q29udGV4dFwiLCAkJC5zZWN1cml0eUNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZihjdG9yKXtcclxuICAgICAgICAgICAgcmVzW2N0b3JdLmFwcGx5KHJlcywgcGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuY3JlYXRlU3dhcm1FbmdpbmUgPSBmdW5jdGlvbihzd2FybVR5cGUsIHV0aWxzKXtcclxuICAgIGlmKHR5cGVvZiB1dGlscyA9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxpdHlGdW5jdGlvbnMvY2FsbGZsb3dcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFN3YXJtU3BhY2Uoc3dhcm1UeXBlLCB1dGlscyk7XHJcbn07XHJcblxyXG4iLCJleHBvcnRzLmNyZWF0ZUZvck9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKXtcclxuXHR2YXIgcmV0ID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xyXG5cclxuXHRyZXQuc3dhcm0gICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXR1cm4gICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXN1bHQgICAgICAgID0gbnVsbDtcclxuXHRyZXQuYXN5bmNSZXR1cm4gICAgID0gbnVsbDtcclxuXHRyZXQucmV0dXJuICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQuaG9tZSAgICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQuaXNQZXJzaXN0ZWQgIFx0PSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpc09iamVjdC5nZXRNZXRhZGF0YSgncGVyc2lzdGVkJykgPT09IHRydWU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHJldDtcclxufTsiLCJ2YXIgYmVlc0hlYWxlciA9IHJlcXVpcmUoXCJzd2FybXV0aWxzXCIpLmJlZXNIZWFsZXI7XHJcbnZhciBzd2FybURlYnVnID0gcmVxdWlyZShcIi4uL2Nob3Jlb2dyYXBoaWVzL1N3YXJtRGVidWdcIik7XHJcblxyXG5leHBvcnRzLmNyZWF0ZUZvck9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKXtcclxuXHR2YXIgcmV0ID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZvclNlcmlhbGlzYWJsZSAodmFsdWVPYmplY3Qpe1xyXG5cdFx0cmV0dXJuIHZhbHVlT2JqZWN0Lm1ldGEuc3dhcm1JZDtcclxuXHR9XHJcblxyXG5cdHZhciBzd2FybUZ1bmN0aW9uID0gZnVuY3Rpb24oY29udGV4dCwgcGhhc2VOYW1lKXtcclxuXHRcdHZhciBhcmdzID1bXTtcclxuXHRcdGZvcih2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL21ha2UgdGhlIGV4ZWN1dGlvbiBhdCBsZXZlbCAwICAoYWZ0ZXIgYWxsIHBlbmRpbmcgZXZlbnRzKSBhbmQgd2FpdCB0byBoYXZlIGEgc3dhcm1JZFxyXG5cdFx0cmV0Lm9ic2VydmUoZnVuY3Rpb24oKXtcclxuXHRcdFx0YmVlc0hlYWxlci5hc0pTT04odmFsdWVPYmplY3QsIHBoYXNlTmFtZSwgYXJncywgZnVuY3Rpb24oZXJyLGpzTXNnKXtcclxuXHRcdFx0XHRqc01zZy5tZXRhLnRhcmdldCA9IGNvbnRleHQ7XHJcblx0XHRcdFx0dmFyIHN1YnNjcmliZXJzQ291bnQgPSAkJC5QU0tfUHViU3ViLnB1Ymxpc2goJCQuQ09OU1RBTlRTLlNXQVJNX0ZPUl9FWEVDVVRJT04sIGpzTXNnKTtcclxuXHRcdFx0XHRpZighc3Vic2NyaWJlcnNDb3VudCl7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgTm9ib2R5IGxpc3RlbmluZyBmb3IgPCR7JCQuQ09OU1RBTlRTLlNXQVJNX0ZPUl9FWEVDVVRJT059PiFgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxudWxsLGZpbHRlckZvclNlcmlhbGlzYWJsZSk7XHJcblxyXG5cdFx0cmV0Lm5vdGlmeSgpO1xyXG5cclxuXHJcblx0XHRyZXR1cm4gdGhpc09iamVjdDtcclxuXHR9O1xyXG5cclxuXHR2YXIgYXN5bmNSZXR1cm4gPSBmdW5jdGlvbihlcnIsIHJlc3VsdCl7XHJcblx0XHR2YXIgY29udGV4dCA9IHZhbHVlT2JqZWN0LnByb3RlY3RlZFZhcnMuY29udGV4dDtcclxuXHJcblx0XHRpZighY29udGV4dCAmJiB2YWx1ZU9iamVjdC5tZXRhLndhaXRTdGFjayl7XHJcblx0XHRcdGNvbnRleHQgPSB2YWx1ZU9iamVjdC5tZXRhLndhaXRTdGFjay5wb3AoKTtcclxuXHRcdFx0dmFsdWVPYmplY3QucHJvdGVjdGVkVmFycy5jb250ZXh0ID0gY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRiZWVzSGVhbGVyLmFzSlNPTih2YWx1ZU9iamVjdCwgXCJfX3JldHVybl9fXCIsIFtlcnIsIHJlc3VsdF0sIGZ1bmN0aW9uKGVycixqc01zZyl7XHJcblx0XHRcdGpzTXNnLm1ldGEuY29tbWFuZCA9IFwiYXN5bmNSZXR1cm5cIjtcclxuXHRcdFx0aWYoIWNvbnRleHQpe1xyXG5cdFx0XHRcdGNvbnRleHQgPSB2YWx1ZU9iamVjdC5tZXRhLmhvbWVTZWN1cml0eUNvbnRleHQ7Ly9UT0RPOiBDSEVDSyBUSElTXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGpzTXNnLm1ldGEudGFyZ2V0ID0gY29udGV4dDtcclxuXHJcblx0XHRcdGlmKCFjb250ZXh0KXtcclxuXHRcdFx0XHQkJC5lcnIobmV3IEVycm9yKFwiQXN5bmNocm9ub3VzIHJldHVybiBpbnNpZGUgb2YgYSBzd2FybSB0aGF0IGRvZXMgbm90IHdhaXQgZm9yIHJlc3VsdHNcIikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLlBTS19QdWJTdWIucHVibGlzaCgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTiwganNNc2cpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBob21lKGVyciwgcmVzdWx0KXtcclxuXHRcdGJlZXNIZWFsZXIuYXNKU09OKHZhbHVlT2JqZWN0LCBcImhvbWVcIiwgW2VyciwgcmVzdWx0XSwgZnVuY3Rpb24oZXJyLGpzTXNnKXtcclxuXHRcdFx0dmFyIGNvbnRleHQgPSB2YWx1ZU9iamVjdC5tZXRhLmhvbWVDb250ZXh0O1xyXG5cdFx0XHRqc01zZy5tZXRhLnRhcmdldCA9IGNvbnRleHQ7XHJcblx0XHRcdCQkLlBTS19QdWJTdWIucHVibGlzaCgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTiwganNNc2cpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHdhaXRSZXN1bHRzKGNhbGxiYWNrLCBrZWVwQWxpdmVDaGVjaywgc3dhcm0pe1xyXG5cdFx0aWYoIXN3YXJtKXtcclxuXHRcdFx0c3dhcm0gPSB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYoIWtlZXBBbGl2ZUNoZWNrKXtcclxuXHRcdFx0a2VlcEFsaXZlQ2hlY2sgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dmFyIGlubmVyID0gc3dhcm0uZ2V0SW5uZXJWYWx1ZSgpO1xyXG5cdFx0aWYoIWlubmVyLm1ldGEud2FpdFN0YWNrKXtcclxuXHRcdFx0aW5uZXIubWV0YS53YWl0U3RhY2sgPSBbXTtcclxuXHRcdFx0aW5uZXIubWV0YS53YWl0U3RhY2sucHVzaCgkJC5zZWN1cml0eUNvbnRleHQpXHJcblx0XHR9XHJcblx0XHQkJC5zd2FybXNJbnN0YW5jZXNNYW5hZ2VyLndhaXRGb3JTd2FybShjYWxsYmFjaywgc3dhcm0sIGtlZXBBbGl2ZUNoZWNrKTtcclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBnZXRJbm5lclZhbHVlKCl7XHJcblx0XHRyZXR1cm4gdmFsdWVPYmplY3Q7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBydW5QaGFzZShmdW5jdE5hbWUsIGFyZ3Mpe1xyXG5cdFx0dmFyIGZ1bmMgPSB2YWx1ZU9iamVjdC5teUZ1bmN0aW9uc1tmdW5jdE5hbWVdO1xyXG5cdFx0aWYoZnVuYyl7XHJcblx0XHRcdGZ1bmMuYXBwbHkodGhpc09iamVjdCwgYXJncyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5zeW50YXhFcnJvcihmdW5jdE5hbWUsIHZhbHVlT2JqZWN0LCBcIkZ1bmN0aW9uIFwiICsgZnVuY3ROYW1lICsgXCIgZG9lcyBub3QgZXhpc3QhXCIpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZShzZXJpYWxpc2F0aW9uKXtcclxuXHRcdGJlZXNIZWFsZXIuanNvblRvTmF0aXZlKHNlcmlhbGlzYXRpb24sdmFsdWVPYmplY3QpO1xyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHZhbHVlT2YoKXtcclxuXHRcdHZhciByZXQgPSB7fTtcclxuXHRcdHJldC5tZXRhICAgICAgICAgICAgICAgID0gdmFsdWVPYmplY3QubWV0YTtcclxuXHRcdHJldC5wdWJsaWNWYXJzICAgICAgICAgID0gdmFsdWVPYmplY3QucHVibGljVmFycztcclxuXHRcdHJldC5wcml2YXRlVmFycyAgICAgICAgID0gdmFsdWVPYmplY3QucHJpdmF0ZVZhcnM7XHJcblx0XHRyZXQucHJvdGVjdGVkVmFycyAgICAgICA9IHZhbHVlT2JqZWN0LnByb3RlY3RlZFZhcnM7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG9TdHJpbmcgKCl7XHJcblx0XHRyZXR1cm4gc3dhcm1EZWJ1Zy5jbGVhbkR1bXAodGhpc09iamVjdC52YWx1ZU9mKCkpO1xyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhcmFsbGVsKGNhbGxiYWNrKXtcclxuXHRcdHJldHVybiByZXF1aXJlKFwiLi4vcGFyYWxsZWxKb2luUG9pbnRcIikuY3JlYXRlSm9pblBvaW50KHRoaXNPYmplY3QsIGNhbGxiYWNrLCAkJC5fX2ludGVybi5ta0FyZ3MoYXJndW1lbnRzLDEpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVNlcmlhbChjYWxsYmFjayl7XHJcblx0XHRyZXR1cm4gcmVxdWlyZShcIi4uL3NlcmlhbEpvaW5Qb2ludFwiKS5jcmVhdGVTZXJpYWxKb2luUG9pbnQodGhpc09iamVjdCwgY2FsbGJhY2ssICQkLl9faW50ZXJuLm1rQXJncyhhcmd1bWVudHMsMSkpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5zcGVjdCgpe1xyXG5cdFx0cmV0dXJuIHN3YXJtRGVidWcuY2xlYW5EdW1wKHRoaXNPYmplY3QudmFsdWVPZigpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCl7XHJcblx0XHRyZXR1cm4gU3dhcm1EZXNjcmlwdGlvbjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGVuc3VyZUxvY2FsSWQoKXtcclxuXHRcdGlmKCF2YWx1ZU9iamVjdC5sb2NhbElkKXtcclxuXHRcdFx0dmFsdWVPYmplY3QubG9jYWxJZCA9IHZhbHVlT2JqZWN0Lm1ldGEuc3dhcm1UeXBlTmFtZSArIFwiLVwiICsgbG9jYWxJZDtcclxuXHRcdFx0bG9jYWxJZCsrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb2JzZXJ2ZShjYWxsYmFjaywgd2FpdEZvck1vcmUsIGZpbHRlcil7XHJcblx0XHRpZighd2FpdEZvck1vcmUpe1xyXG5cdFx0XHR3YWl0Rm9yTW9yZSA9IGZ1bmN0aW9uICgpe1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGVuc3VyZUxvY2FsSWQoKTtcclxuXHJcblx0XHQkJC5QU0tfUHViU3ViLnN1YnNjcmliZSh2YWx1ZU9iamVjdC5sb2NhbElkLCBjYWxsYmFjaywgd2FpdEZvck1vcmUsIGZpbHRlcik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0b0pTT04ocHJvcCl7XHJcblx0XHQvL3ByZXZlbnRpbmcgbWF4IGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRpbmcgb24gcHJveHkgYXV0byByZWZlcmVuY2luZ1xyXG5cdFx0Ly9yZXBsYWNlIHt9IGFzIHJlc3VsdCBvZiBKU09OKFByb3h5KSB3aXRoIHRoZSBzdHJpbmcgW09iamVjdCBwcm90ZWN0ZWQgb2JqZWN0XVxyXG5cdFx0cmV0dXJuIFwiW09iamVjdCBwcm90ZWN0ZWQgb2JqZWN0XVwiO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0SlNPTihjYWxsYmFjayl7XHJcblx0XHRyZXR1cm5cdGJlZXNIZWFsZXIuYXNKU09OKHZhbHVlT2JqZWN0LCBudWxsLCBudWxsLGNhbGxiYWNrKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG5vdGlmeShldmVudCl7XHJcblx0XHRpZighZXZlbnQpe1xyXG5cdFx0XHRldmVudCA9IHZhbHVlT2JqZWN0O1xyXG5cdFx0fVxyXG5cdFx0ZW5zdXJlTG9jYWxJZCgpO1xyXG5cdFx0JCQuUFNLX1B1YlN1Yi5wdWJsaXNoKHZhbHVlT2JqZWN0LmxvY2FsSWQsIGV2ZW50KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE1ldGEobmFtZSl7XHJcblx0XHRyZXR1cm4gdmFsdWVPYmplY3QuZ2V0TWV0YShuYW1lKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1ldGEobmFtZSwgdmFsdWUpe1xyXG5cdFx0cmV0dXJuIHZhbHVlT2JqZWN0LnNldE1ldGEobmFtZSwgdmFsdWUpO1xyXG5cdH1cclxuXHJcblx0cmV0LnNldE1ldGFcdFx0XHQ9IHNldE1ldGE7XHJcblx0cmV0LmdldE1ldGFcdFx0XHQ9IGdldE1ldGE7XHJcblx0cmV0LnN3YXJtICAgICAgICAgICA9IHN3YXJtRnVuY3Rpb247XHJcblx0cmV0Lm5vdGlmeSAgICAgICAgICA9IG5vdGlmeTtcclxuXHRyZXQuZ2V0SlNPTiAgICBcdCAgICA9IGdldEpTT047XHJcblx0cmV0LnRvSlNPTiAgICAgICAgICA9IHRvSlNPTjtcclxuXHRyZXQub2JzZXJ2ZSAgICAgICAgID0gb2JzZXJ2ZTtcclxuXHRyZXQuaW5zcGVjdCAgICAgICAgID0gaW5zcGVjdDtcclxuXHRyZXQuam9pbiAgICAgICAgICAgID0gY3JlYXRlUGFyYWxsZWw7XHJcblx0cmV0LnBhcmFsbGVsICAgICAgICA9IGNyZWF0ZVBhcmFsbGVsO1xyXG5cdHJldC5zZXJpYWwgICAgICAgICAgPSBjcmVhdGVTZXJpYWw7XHJcblx0cmV0LnZhbHVlT2YgICAgICAgICA9IHZhbHVlT2Y7XHJcblx0cmV0LnVwZGF0ZSAgICAgICAgICA9IHVwZGF0ZTtcclxuXHRyZXQucnVuUGhhc2UgICAgICAgID0gcnVuUGhhc2U7XHJcblx0cmV0Lm9uUmV0dXJuICAgICAgICA9IHdhaXRSZXN1bHRzO1xyXG5cdHJldC5vblJlc3VsdCAgICAgICAgPSB3YWl0UmVzdWx0cztcclxuXHRyZXQuYXN5bmNSZXR1cm4gICAgID0gYXN5bmNSZXR1cm47XHJcblx0cmV0LnJldHVybiAgICAgICAgICA9IGFzeW5jUmV0dXJuO1xyXG5cdHJldC5nZXRJbm5lclZhbHVlICAgPSBnZXRJbm5lclZhbHVlO1xyXG5cdHJldC5ob21lICAgICAgICAgICAgPSBob21lO1xyXG5cdHJldC50b1N0cmluZyAgICAgICAgPSB0b1N0cmluZztcclxuXHRyZXQuY29uc3RydWN0b3IgICAgID0gY29uc3RydWN0b3I7XHJcblx0cmV0LnNldE1ldGFkYXRhXHRcdD0gdmFsdWVPYmplY3Quc2V0TWV0YS5iaW5kKHZhbHVlT2JqZWN0KTtcclxuXHRyZXQuZ2V0TWV0YWRhdGFcdFx0PSB2YWx1ZU9iamVjdC5nZXRNZXRhLmJpbmQodmFsdWVPYmplY3QpO1xyXG5cclxuXHRyZXQuYXV0b0luaXRcdFx0PSBudWxsO1xyXG5cdHJldHVybiByZXQ7XHJcblxyXG59O1xyXG4iLCJleHBvcnRzLmNyZWF0ZUZvck9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKXtcclxuXHR2YXIgcmV0ID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xyXG5cclxuXHRyZXQuc3dhcm0gICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXR1cm4gICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXN1bHQgICAgICAgID0gbnVsbDtcclxuXHRyZXQuYXN5bmNSZXR1cm4gICAgID0gbnVsbDtcclxuXHRyZXQucmV0dXJuICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQuaG9tZSAgICAgICAgICAgID0gbnVsbDtcclxuXHJcblx0cmV0dXJuIHJldDtcclxufTsiLCJleHBvcnRzLmNyZWF0ZUZvck9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKXtcclxuXHR2YXIgcmV0ID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xyXG5cclxuXHRyZXQuc3dhcm0gICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXR1cm4gICAgICAgID0gbnVsbDtcclxuXHRyZXQub25SZXN1bHQgICAgICAgID0gbnVsbDtcclxuXHRyZXQuYXN5bmNSZXR1cm4gICAgID0gbnVsbDtcclxuXHRyZXQucmV0dXJuICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQuaG9tZSAgICAgICAgICAgID0gbnVsbDtcclxuXHRyZXQuYXV0b0luaXQgICAgICAgID0gZnVuY3Rpb24oKXtcclxuXHRcdHRoaXNPYmplY3QudHJhbnNhY3Rpb24gPSAkJC5ibG9ja2NoYWluLmJlZ2luVHJhbnNhY3Rpb24odGhpc09iamVjdCk7XHJcblx0fTtcclxuXHRyZXQuaXNQZXJzaXN0ZWQgIFx0PSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpc09iamVjdC5nZXRNZXRhZGF0YSgncGVyc2lzdGVkJykgPT09IHRydWU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHJldDtcclxufTsiLCJsZXQgbG9nZ2VyID0gY29uc29sZTtcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT19MT0dTICE9PSAndHJ1ZScpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgUFNLTG9nZ2VyTW9kdWxlID0gcmVxdWlyZSgncHNrbG9nZ2VyJyk7XHJcbiAgICAgICAgY29uc3QgUFNLTG9nZ2VyID0gUFNLTG9nZ2VyTW9kdWxlLlBTS0xvZ2dlcjtcclxuICAgICAgICBcclxuICAgICAgICBsb2dnZXIgPSBQU0tMb2dnZXIuZ2V0TG9nZ2VyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSAkJCBsb2dnZXIgaXMgdXNlZCBpbnN0ZWFkIG9mIGNvbnNvbGVcclxuICAgICAgICBQU0tMb2dnZXJNb2R1bGUub3ZlcndyaXRlQ29uc29sZSgpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnTG9nZ2VyIGluaXQgc3VjY2Vzc2Z1bCcsIHByb2Nlc3MucGlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0xvZ2dlciBub3QgYXZhaWxhYmxlLCB1c2luZyBjb25zb2xlJywgZSk7XHJcbiAgICAgICAgbG9nZ2VyID0gY29uc29sZTtcclxuICAgIH1cclxufSBlbHNlIHtcclxuICAgIGNvbnNvbGUubG9nKCdFbnZpcm9ubWVudCBmbGFnIE5PX0xPR1MgaXMgc2V0LCBsb2dnaW5nIHRvIGNvbnNvbGUnKTtcclxufVxyXG5cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2wgPSBmdW5jdGlvbiAobmV3U3ltYm9sLCB2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiAkJFtuZXdTeW1ib2xdID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJCQsIG5ld1N5bWJvbCwge1xyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoXCJSZWZ1c2luZyB0byBvdmVyd3JpdGUgJCQuXCIgKyBuZXdTeW1ib2wpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJhdXRvVGhyb3dcIiwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgaWYgKCFlcnIpIHtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJwcm9wYWdhdGVFcnJvclwiLCBmdW5jdGlvbiAoZXJyLGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICB0aHJvdyBlcnI7IC8vc3RvcCBleGVjdXRpb25cclxuICAgIH1cclxufSk7XHJcblxyXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcImxvZ0Vycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICQkLmVycihlcnIpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmNvbnNvbGUubG9nKFwiRml4IHRoZSBmaXhNZSB0byBub3QgZGlzcGxheSBvbiBjb25zb2xlIGJ1dCBwdXQgaW4gbG9nc1wiKTtcclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJmaXhNZVwiLCBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIC8vJCQubG9nKC4uLmFyZ3MpO1xyXG59KTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiZXhjZXB0aW9uXCIsIGZ1bmN0aW9uIChtZXNzYWdlLCB0eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59KTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwidGhyb3dcIiwgZnVuY3Rpb24gKG1lc3NhZ2UsIHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn0pO1xyXG5cclxuLyogYSBmZWF0dXJlIGlzIHBsYW5uZWQgYnV0IG5vdCBpbXBsZW1lbnRlZCAoZHVyaW5nIGRldmVsb3BtZW50KSBidXRcclxuYWxzbyBpdCBjb3VsZCByZW1haW4gaW4gcHJvZHVjdGlvbiBhbmQgc2hvdWxkIGJlIGZsYWdnZWQgYXNhcCovXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiaW5jb21wbGV0ZVwiLCBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgYXJncy51bnNoaWZ0KFwiSW5jb21wbGV0ZSBmZWF0dXJlIHRvdWNoZWQ6XCIpO1xyXG4gICAgbG9nZ2VyLndhcm4oLi4uYXJncyk7XHJcbn0pO1xyXG5cclxuLyogdXNlZCBkdXJpbmcgZGV2ZWxvcG1lbnQgYW5kIHdoZW4gdHJ5aW5nIHRvIGRpc2NvdmVyIGVsdXNpdmUgZXJyb3JzKi9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJhc3NlcnRcIiwgZnVuY3Rpb24gKHZhbHVlLCBleHBsYWluV2h5KSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0IGZhbHNlIFwiICsgZXhwbGFpbldoeSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyogZW5hYmxlL2Rpc2FiYWxlIGZsYWdzIHRoYXQgY29udHJvbCBwc2sgYmVoYXZpb3VyKi9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJmbGFnc1wiLCBmdW5jdGlvbiAoZmxhZ05hbWUsIHZhbHVlKSB7XHJcbiAgICAkJC5pbmNvbXBsZXRlKFwiZmxhZ3MgaGFuZGxpbmcgbm90IGltcGxlbWVudGVkXCIpO1xyXG59KTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwib2Jzb2xldGVcIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgIGFyZ3MudW5zaGlmdChcIk9ic29sZXRlIGZlYXR1cmU6XCIpO1xyXG4gICAgbG9nZ2VyLmxvZyguLi5hcmdzKTtcclxuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xyXG59KTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwibG9nXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICBhcmdzLnVuc2hpZnQoXCJMb2c6XCIpO1xyXG4gICAgbG9nZ2VyLmxvZyguLi5hcmdzKTtcclxuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xyXG59KTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiaW5mb1wiLCBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgYXJncy51bnNoaWZ0KFwiSW5mbzpcIik7XHJcbiAgICBsb2dnZXIubG9nKC4uLmFyZ3MpO1xyXG4gICAgY29uc29sZS5sb2coLi4uYXJncyk7XHJcbn0pO1xyXG5cclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiZXJyXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICBhcmdzLnVuc2hpZnQoXCJFcnJvcjpcIik7XHJcbiAgICBsb2dnZXIuZXJyb3IoLi4uYXJncyk7XHJcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcclxufSk7XHJcblxyXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcIndhcm5cIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgIGFyZ3MudW5zaGlmdChcIldhcm46XCIpO1xyXG4gICAgbG9nZ2VyLndhcm4oLi4uYXJncyk7XHJcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcclxufSk7XHJcblxyXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcInN5bnRheEVycm9yXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICBhcmdzLnVuc2hpZnQoXCJVbmtub3duIHN5bnRheEVycm9yOlwiKTtcclxuICAgIGxvZ2dlci5sb2coLi4uYXJncyk7XHJcbn0pO1xyXG5cclxuJCQuaW52YWxpZE1lbWJlck5hbWUgPSBmdW5jdGlvbiAobmFtZSwgc3dhcm0pIHtcclxuICAgIHZhciBzd2FybU5hbWUgPSBcInVua25vd25cIlxyXG4gICAgaWYoc3dhcm0gJiYgc3dhcm0ubWV0YSl7XHJcbiAgICAgICAgc3dhcm1OYW1lID0gc3dhcm0ubWV0YS5zd2FybVR5cGVOYW1lO1xyXG4gICAgfVxyXG4gICAgdmFyIHRleHQgPSBcIkludmFsaWQgbWVtYmVyIG5hbWUgXCIgKyBuYW1lICsgXCJpbiBzd2FybSBcIiArIHN3YXJtTmFtZTtcclxuICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG4gICAgbG9nZ2VyLmxvZyh0ZXh0KTtcclxufTtcclxuXHJcbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiaW52YWxpZFN3YXJtTmFtZVwiLCBmdW5jdGlvbiAoIHN3YXJtTmFtZSkge1xyXG4gICAgdmFyIHRleHQgPSBcIkludmFsaWQgc3dhcm0gbmFtZSBcIiArIHN3YXJtTmFtZTtcclxuICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG4gICAgbG9nZ2VyLmxvZyh0ZXh0KTtcclxufSk7XHJcblxyXG4vKiBsb2cgdW5rbm93biBleGNlcHRpb25zKi9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJ1bmtub3duRXhjZXB0aW9uXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICBhcmdzLnVuc2hpZnQoXCJ1bmtub3duRXhjZXB0aW9uOlwiKTtcclxuICAgIGxvZ2dlci5sb2coLi4uYXJncyk7XHJcbn0pO1xyXG5cclxuLyogUHJpdmF0ZVNreSBldmVudCwgdXNlZCBieSBtb25pdG9yaW5nIGFuZCBzdGF0aXN0aWNzKi9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJldmVudFwiLCBmdW5jdGlvbiAoZXZlbnQsIC4uLmFyZ3MpIHtcclxuICAgIGlmIChsb2dnZXIuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcclxuICAgICAgICBsb2dnZXIuZXZlbnQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhldmVudCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyogKi9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJyZWRpcmVjdExvZ1wiLCBmdW5jdGlvbihsb2dUeXBlLCBsb2dPYmplY3QpIHtcclxuICAgIGxvZ2dlci5yZWRpcmVjdChsb2dUeXBlLCBsb2dPYmplY3QpO1xyXG59KTtcclxuXHJcbi8qIGxvZyB0aHJvdHRsaW5nIGV2ZW50IC8vIGl0IGlzIGp1c3QgYW4gZXZlbnQ/Ki9cclxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJ0aHJvdHRsaW5nRXZlbnRcIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgIGxvZ2dlci5sb2coLi4uYXJncyk7XHJcbn0pO1xyXG4iLCJcclxubW9kdWxlLmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKHNmLCBsb2dnZXIpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBoYW5kbGVyIGZvciBmYWlsZWQgYXNzZXJ0cy4gVGhlIGhhbmRsZXIgaXMgZG9pbmcgbG9nZ2luZyBhbmQgaXMgdGhyb3dpbmcgYW4gZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBsZXQgX19mYWlsV2FzQWxyZWFkeUdlbmVyYXRlZCA9IGZhbHNlO1xyXG4gICAgbGV0IF9fYXNzZXRzQ291bnRlciA9IDA7XHJcblxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKCFiZWdpbldhc0NhbGxlZCl7XHJcbiAgICAgICAgICAgIHNmLmFzc2VydC5iZWdpbihcIkJlZ2luIHdhcyBub3QgY2FsbGVkLCBzZXR0aW5nIGV4aXQgdGltZSBmb3IgdGhlIHRlc3QgaW4gMSBzZWNvbmRcIikgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LDEwMDApXHJcblxyXG5cclxuICAgIHZhciBiZWdpbldhc0NhbGxlZCA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIHByaW50aW5nIGEgbWVzc2FnZSBhbmQgYXN5bmNocm9ub3VzbHkgcHJpbnRpbmcgYWxsIGxvZ3MgZnJvbSBsb2dnZXIuZHVtcFdoeXMuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB7U3RyaW5nfSAtIG1lc3NhZ2UgdG8gYmUgcmVjb3JkZWRcclxuICAgICAqIEBwYXJhbSBjbGVhbkZ1bmN0aW9ucyB7RnVuY3Rpb259IC0gY2xlYW5pbmcgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB0aW1lb3V0IHtOdW1iZXJ9IC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRpbWVvdXQgY2hlY2suIERlZmF1bHQgdG8gNTAwbXMuXHJcbiAgICAgKi9cclxuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnYmVnaW4nLCBmdW5jdGlvbihtZXNzYWdlLCBjbGVhbkZ1bmN0aW9ucywgdGltZW91dCl7XHJcbiAgICAgICAgLy9sb2dnZXIucmVjb3JkQXNzZXJ0KG1lc3NhZ2UpO1xyXG4gICAgICAgIGJlZ2luV2FzQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgICAgICBzZi5hc3NlcnQuZW5kKGNsZWFuRnVuY3Rpb25zLCB0aW1lb3V0LCB0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNmLmFzc2VydC5hZGRDaGVjaygncHJldmVudFByZW1hdHVyZUVuZCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgYmVnaW5XYXNDYWxsZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVjb3JkRmFpbCguLi5hcmdzKXsgLy9yZWNvcmQgZmFpbCBvbmx5IG9uY2VcclxuICAgICAgICBpZighX19mYWlsV2FzQWxyZWFkeUdlbmVyYXRlZCl7XHJcbiAgICAgICAgICAgIF9fZmFpbFdhc0FscmVhZHlHZW5lcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBzZi5leGNlcHRpb25zLnJlZ2lzdGVyKCdhc3NlcnRGYWlsJywgZnVuY3Rpb24oZXhwbGFuYXRpb24pe1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkFzc2VydCBvciBpbnZhcmlhbnQgaGFzIGZhaWxlZCBcIiArIChleHBsYW5hdGlvbiA/IGV4cGxhbmF0aW9uIDogXCJcIik7XHJcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG5cclxuICAgICAgICByZWNvcmRGYWlsKCdbRmFpbF0gJyArIG1lc3NhZ2UsIGVyciwgdHJ1ZSk7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGVxdWFsaXR5LiBJZiBjaGVjayBmYWlscywgdGhlIGFzc2VydEZhaWwgaXMgaW52b2tlZC5cclxuICAgICAqIEBwYXJhbSB2MSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IC0gZmlyc3QgdmFsdWVcclxuICAgICAqIEBwYXJhbSB2MSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IC0gc2Vjb25kIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlscy5cclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdlcXVhbCcsIGZ1bmN0aW9uKHYxICwgdjIsIGV4cGxhbmF0aW9uKXtcclxuICAgICAgICBpZih2MSAhPT0gdjIpe1xyXG4gICAgICAgICAgICBpZighZXhwbGFuYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb24gPSAgXCJBc3NlcnRpb24gZmFpbGVkOiBbXCIgKyB2MSArIFwiICE9PSBcIiArIHYyICsgXCJdXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5hc3NlcnRGYWlsKGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgaW5lcXVhbGl0eS4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0gdjEge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSAtIGZpcnN0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gdjEge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSAtIHNlY29uZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZSBpbiBjYXNlIHRoZSBhc3NlcnQgZmFpbHNcclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdub3RFcXVhbCcsIGZ1bmN0aW9uKHYxLCB2MiwgZXhwbGFuYXRpb24pe1xyXG4gICAgICAgIGlmKHYxID09PSB2Mil7XHJcbiAgICAgICAgICAgIGlmKCFleHBsYW5hdGlvbil7XHJcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBbXCIrIHYxICsgXCIgPT0gXCIgKyB2MiArIFwiXVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuYXNzZXJ0RmFpbChleHBsYW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiB0byB0cnVlLiBJZiBjaGVjayBmYWlscywgdGhlIGFzc2VydEZhaWwgaXMgaW52b2tlZC5cclxuICAgICAqIEBwYXJhbSBiIHtCb29sZWFufSAtIHJlc3VsdCBvZiBhbiBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xyXG4gICAgICovXHJcbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soJ3RydWUnLCBmdW5jdGlvbihiLCBleHBsYW5hdGlvbil7XHJcbiAgICAgICAgaWYoIWIpe1xyXG4gICAgICAgICAgICBpZighZXhwbGFuYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb24gPSAgXCIgZXhwcmVzc2lvbiBpcyBmYWxzZSBidXQgaXMgZXhwZWN0ZWQgdG8gYmUgdHJ1ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuYXNzZXJ0RmFpbChleHBsYW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiB0byBmYWxzZS4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0gYiB7Qm9vbGVhbn0gLSByZXN1bHQgb2YgYW4gZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZSBpbiBjYXNlIHRoZSBhc3NlcnQgZmFpbHNcclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdmYWxzZScsIGZ1bmN0aW9uKGIsIGV4cGxhbmF0aW9uKXtcclxuICAgICAgICBpZihiKXtcclxuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcclxuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gIFwiIGV4cHJlc3Npb24gaXMgdHJ1ZSBidXQgaXMgZXhwZWN0ZWQgdG8gYmUgZmFsc2VcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJpbmcgYXNzZXJ0IGZvciBldmFsdWF0aW5nIGEgdmFsdWUgdG8gbnVsbC4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0gYiB7Qm9vbGVhbn0gLSByZXN1bHQgb2YgYW4gZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZSBpbiBjYXNlIHRoZSBhc3NlcnQgZmFpbHNcclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdpc051bGwnLCBmdW5jdGlvbih2MSwgZXhwbGFuYXRpb24pe1xyXG4gICAgICAgIGlmKHYxICE9PSBudWxsKXtcclxuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5hc3NlcnRGYWlsKGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgZXZhbHVhdGluZyBhIHZhbHVlIHRvIGJlIG5vdCBudWxsLiBJZiBjaGVjayBmYWlscywgdGhlIGFzc2VydEZhaWwgaXMgaW52b2tlZC5cclxuICAgICAqIEBwYXJhbSBiIHtCb29sZWFufSAtIHJlc3VsdCBvZiBhbiBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xyXG4gICAgICovXHJcbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soJ25vdE51bGwnLCBmdW5jdGlvbih2MSAsIGV4cGxhbmF0aW9uKXtcclxuICAgICAgICBpZih2MSA9PT0gbnVsbCAmJiB0eXBlb2YgdjEgPT09IFwib2JqZWN0XCIpe1xyXG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0IGFyZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGZpcnN0T2JqIHtPYmplY3R9IC0gZmlyc3Qgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gc2Vjb25kT2Jqe09iamVjdH0gLSBzZWNvbmQgb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSByZXR1cm5zIHRydWUsIGlmIHRoZSBjaGVjayBoYXMgcGFzc2VkIG9yIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb2JqZWN0SGFzRmllbGRzKGZpcnN0T2JqLCBzZWNvbmRPYmope1xyXG4gICAgICAgIGZvcihsZXQgZmllbGQgaW4gc2Vjb25kT2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdE9iai5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE9ialtmaWVsZF0gIT09IHNlY29uZE9ialtmaWVsZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvYmplY3RzQXJlRXF1YWwoZmlyc3RPYmosIHNlY29uZE9iaikge1xyXG4gICAgICAgIGxldCBhcmVFcXVhbCA9IHRydWU7XHJcbiAgICAgICAgaWYoZmlyc3RPYmogIT09IHNlY29uZE9iaikge1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgZmlyc3RPYmogIT09IHR5cGVvZiBzZWNvbmRPYmopIHtcclxuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdE9iaikgJiYgQXJyYXkuaXNBcnJheShzZWNvbmRPYmopKSB7XHJcblx0ICAgICAgICAgICAgZmlyc3RPYmouc29ydCgpO1xyXG5cdCAgICAgICAgICAgIHNlY29uZE9iai5zb3J0KCk7XHJcblx0XHQgICAgICAgIGlmIChmaXJzdE9iai5sZW5ndGggIT09IHNlY29uZE9iai5sZW5ndGgpIHtcclxuXHRcdFx0ICAgICAgICBhcmVFcXVhbCA9IGZhbHNlO1xyXG5cdFx0ICAgICAgICB9IGVsc2Uge1xyXG5cdFx0XHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RPYmoubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHQgICAgICAgIGlmICghb2JqZWN0c0FyZUVxdWFsKGZpcnN0T2JqW2ldLCBzZWNvbmRPYmpbaV0pKSB7XHJcblx0XHRcdFx0XHQgICAgICAgIGFyZUVxdWFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHQgICAgICAgIGJyZWFrO1xyXG5cdFx0XHRcdCAgICAgICAgfVxyXG5cdFx0XHQgICAgICAgIH1cclxuXHRcdCAgICAgICAgfVxyXG5cdCAgICAgICAgfSBlbHNlIGlmKCh0eXBlb2YgZmlyc3RPYmogPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNlY29uZE9iaiA9PT0gJ2Z1bmN0aW9uJykgfHxcclxuXHRcdCAgICAgICAgKGZpcnN0T2JqIGluc3RhbmNlb2YgRGF0ZSAmJiBzZWNvbmRPYmogaW5zdGFuY2VvZiBEYXRlKSB8fFxyXG5cdFx0ICAgICAgICAoZmlyc3RPYmogaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2Vjb25kT2JqIGluc3RhbmNlb2YgUmVnRXhwKSB8fFxyXG5cdFx0ICAgICAgICAoZmlyc3RPYmogaW5zdGFuY2VvZiBTdHJpbmcgJiYgc2Vjb25kT2JqIGluc3RhbmNlb2YgU3RyaW5nKSB8fFxyXG5cdFx0ICAgICAgICAoZmlyc3RPYmogaW5zdGFuY2VvZiBOdW1iZXIgJiYgc2Vjb25kT2JqIGluc3RhbmNlb2YgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gZmlyc3RPYmoudG9TdHJpbmcoKSA9PT0gc2Vjb25kT2JqLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YgZmlyc3RPYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZWNvbmRPYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBhcmVFcXVhbCA9IG9iamVjdEhhc0ZpZWxkcyhmaXJzdE9iaiwgc2Vjb25kT2JqKTtcclxuICAgICAgICAgICAgLy8gaXNOYU4odW5kZWZpbmVkKSByZXR1cm5zIHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGlzTmFOKGZpcnN0T2JqKSAmJiBpc05hTihzZWNvbmRPYmopICYmIHR5cGVvZiBmaXJzdE9iaiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNlY29uZE9iaiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcmVFcXVhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgZXZhbHVhdGluZyBpZiBhbGwgcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdCBhcmUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdC5cclxuICAgICAqIElmIGNoZWNrIGZhaWxzLCB0aGUgYXNzZXJ0RmFpbCBpcyBpbnZva2VkLlxyXG4gICAgICogQHBhcmFtIGZpcnN0T2JqIHtPYmplY3R9IC0gZmlyc3Qgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gc2Vjb25kT2Jqe09iamVjdH0gLSBzZWNvbmQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xyXG4gICAgICovXHJcbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soXCJvYmplY3RIYXNGaWVsZHNcIiwgZnVuY3Rpb24oZmlyc3RPYmosIHNlY29uZE9iaiwgZXhwbGFuYXRpb24pe1xyXG4gICAgICAgIGlmKCFvYmplY3RIYXNGaWVsZHMoZmlyc3RPYmosIHNlY29uZE9iaikpIHtcclxuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5hc3NlcnRGYWlsKGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgZXZhbHVhdGluZyBpZiBhbGwgZWxlbWVudCBmcm9tIHRoZSBzZWNvbmQgYXJyYXkgYXJlIHByZXNlbnQgaW4gdGhlIGZpcnN0IGFycmF5LlxyXG4gICAgICogRGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBpcyB1c2VkLlxyXG4gICAgICogSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlyc3RBcnJheSB7QXJyYXl9LSBmaXJzdCBhcnJheVxyXG4gICAgICogQHBhcmFtIHNlY29uZEFycmF5IHtBcnJheX0gLSBzZWNvbmQgYXJyYXlcclxuICAgICAqIEBwYXJhbSBleHBsYW5hdGlvbiB7U3RyaW5nfSAtIGZhaWxpbmcgcmVhc29uIG1lc3NhZ2UgaW4gY2FzZSB0aGUgYXNzZXJ0IGZhaWxzXHJcbiAgICAgKi9cclxuICAgIHNmLmFzc2VydC5hZGRDaGVjayhcImFycmF5c01hdGNoXCIsIGZ1bmN0aW9uKGZpcnN0QXJyYXksIHNlY29uZEFycmF5LCBleHBsYW5hdGlvbil7XHJcbiAgICAgICAgaWYoZmlyc3RBcnJheS5sZW5ndGggIT09IHNlY29uZEFycmF5Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuYXNzZXJ0RmFpbChleHBsYW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvYmplY3RzQXJlRXF1YWwoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXkpO1xyXG4gICAgICAgICAgICAvLyBjb25zdCBhcnJheXNEb250TWF0Y2ggPSBzZWNvbmRBcnJheS5ldmVyeShlbGVtZW50ID0+IGZpcnN0QXJyYXkuaW5kZXhPZihlbGVtZW50KSAhPT0gLTEpO1xyXG4gICAgICAgICAgICAvLyBsZXQgYXJyYXlzRG9udE1hdGNoID0gc2Vjb25kQXJyYXkuc29tZShmdW5jdGlvbiAoZXhwZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsZXQgZm91bmQgPSBmaXJzdEFycmF5LnNvbWUoZnVuY3Rpb24ocmVzdWx0RWxlbWVudCl7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG9iamVjdEhhc0ZpZWxkcyhyZXN1bHRFbGVtZW50LGV4cGVjdGVkRWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vICAgICB9KTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBmb3VuZCA9PT0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYoIXJlc3VsdCl7XHJcbiAgICAgICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gYWRkZWQgbWFpbmx5IGZvciB0ZXN0IHB1cnBvc2VzLCBiZXR0ZXIgdGVzdCBmcmFtZXdvcmtzIGxpa2UgbW9jaGEgY291bGQgYmUgbXVjaCBiZXR0ZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgY2hlY2tpbmcgaWYgYSBmdW5jdGlvbiBpcyBmYWlsaW5nLlxyXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIGlzIHRocm93aW5nIGFuIGV4Y2VwdGlvbiwgdGhlIHRlc3QgaXMgcGFzc2VkIG9yIGZhaWxlZCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0gdGVzdE5hbWUge1N0cmluZ30gLSB0ZXN0IG5hbWUgb3IgZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSBmdW5jIHtGdW5jdGlvbn0gLSBmdW5jdGlvbiB0byBiZSBpbnZva2VkXHJcbiAgICAgKi9cclxuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnZmFpbCcsIGZ1bmN0aW9uKHRlc3ROYW1lLCBmdW5jKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgcmVjb3JkRmFpbChcIltGYWlsXSBcIiArIHRlc3ROYW1lKTtcclxuICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIGxvZ2dlci5yZWNvcmRBc3NlcnQoXCJbUGFzc10gXCIgKyB0ZXN0TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGNoZWNraW5nIGlmIGEgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCBubyBleGNlcHRpb25zLlxyXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCB0aHJvd2luZyBhbnkgZXhjZXB0aW9uLCB0aGUgdGVzdCBpcyBwYXNzZWQgb3IgZmFpbGVkIG90aGVyd2lzZS5cclxuICAgICAqIEBwYXJhbSB0ZXN0TmFtZSB7U3RyaW5nfSAtIHRlc3QgbmFtZSBvciBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdwYXNzJywgZnVuY3Rpb24odGVzdE5hbWUsIGZ1bmMpe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW1Bhc3NdIFwiICsgdGVzdE5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgcmVjb3JkRmFpbChcIltGYWlsXSBcIiArIHRlc3ROYW1lLCBlcnIuc3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIHRoZSBwYXNzIGFzc2VydC5cclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFsaWFzKCd0ZXN0JywgJ3Bhc3MnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgY2hlY2tpbmcgaWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBleGVjdXRlZCBiZWZvcmUgdGltZW91dCBpcyByZWFjaGVkIHdpdGhvdXQgYW55IGV4Y2VwdGlvbnMuXHJcbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gaXMgdGhyb3dpbmcgYW55IGV4Y2VwdGlvbiBvciB0aGUgdGltZW91dCBpcyByZWFjaGVkLCB0aGUgdGVzdCBpcyBmYWlsZWQgb3IgcGFzc2VkIG90aGVyd2lzZS5cclxuICAgICAqIEBwYXJhbSB0ZXN0TmFtZSB7U3RyaW5nfSAtIHRlc3QgbmFtZSBvciBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcclxuICAgICAqIEBwYXJhbSB0aW1lb3V0IHtOdW1iZXJ9IC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRpbWVvdXQgY2hlY2suIERlZmF1bHQgdG8gNTAwbXMuXHJcbiAgICAgKi9cclxuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnY2FsbGJhY2snLCBmdW5jdGlvbih0ZXN0TmFtZSwgZnVuYywgdGltZW91dCl7XHJcbiAgICAgICAgX19hc3NldHNDb3VudGVyKys7XHJcbiAgICAgICAgaWYoIWZ1bmMgfHwgdHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdXNhZ2Ugb2YgYXNzZXJ0LmNhbGxiYWNrIVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCF0aW1lb3V0KXtcclxuICAgICAgICAgICAgdGltZW91dCA9IDUwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpe1xyXG4gICAgICAgICAgICBfX2Fzc2V0c0NvdW50ZXItLTtcclxuICAgICAgICAgICAgaWYoIXBhc3NlZCl7XHJcbiAgICAgICAgICAgICAgICBwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltQYXNzXSBcIiArIHRlc3ROYW1lKTtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NUZXN0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRGYWlsKFwiW0ZhaWwgKG11bHRpcGxlIGNhbGxzKV0gXCIgKyB0ZXN0TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBmdW5jKGNhbGxiYWNrKTtcclxuICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIHJlY29yZEZhaWwoXCJbRmFpbF0gXCIgKyB0ZXN0TmFtZSwgIGVyciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzVGVzdChmb3JjZSl7XHJcbiAgICAgICAgICAgIGlmKCFwYXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltGYWlsIFRpbWVvdXRdIFwiICsgdGVzdE5hbWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChzdWNjZXNzVGVzdCwgdGltZW91dCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgY2hlY2tpbmcgaWYgYW4gYXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBpbiBhIHdhdGVyZmFsbCBtYW5uZXIsXHJcbiAgICAgKiBiZWZvcmUgdGltZW91dCBpcyByZWFjaGVkIHdpdGhvdXQgYW55IGV4Y2VwdGlvbnMuXHJcbiAgICAgKiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBpcyB0aHJvd2luZyBhbnkgZXhjZXB0aW9uIG9yIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHRoZSB0ZXN0IGlzIGZhaWxlZCBvciBwYXNzZWQgb3RoZXJ3aXNlLlxyXG4gICAgICogQHBhcmFtIHRlc3ROYW1lIHtTdHJpbmd9IC0gdGVzdCBuYW1lIG9yIGRlc2NyaXB0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnVuYyB7RnVuY3Rpb259IC0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxyXG4gICAgICogQHBhcmFtIHRpbWVvdXQge051bWJlcn0gLSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZvciB0aGUgdGltZW91dCBjaGVjay4gRGVmYXVsdCB0byA1MDBtcy5cclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdzdGVwcycsIGZ1bmN0aW9uKHRlc3ROYW1lLCBhcnIsIHRpbWVvdXQpe1xyXG4gICAgICAgIGlmKCF0aW1lb3V0KXtcclxuICAgICAgICAgICAgdGltZW91dCA9IDUwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50U3RlcCA9IDA7XHJcbiAgICAgICAgdmFyIHBhc3NlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBuZXh0KCl7XHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTdGVwID09PSBhcnIubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIHBhc3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW1Bhc3NdIFwiICsgdGVzdE5hbWUgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBhcnJbY3VycmVudFN0ZXBdO1xyXG4gICAgICAgICAgICBjdXJyZW50U3RlcCsrO1xyXG4gICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICBmdW5jKG5leHQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRGYWlsKFwiW0ZhaWxdIFwiICsgdGVzdE5hbWUgICsgXCIgW2F0IHN0ZXAgXCIgKyBjdXJyZW50U3RlcCArIFwiXVwiLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzVGVzdChmb3JjZSl7XHJcbiAgICAgICAgICAgIGlmKCFwYXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkRmFpbChcIltGYWlsIFRpbWVvdXRdIFwiICsgdGVzdE5hbWUgICsgXCIgW2F0IHN0ZXAgXCIgKyBjdXJyZW50U3RlcCArIFwiXVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChzdWNjZXNzVGVzdCwgdGltZW91dCk7XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgdGhlIHN0ZXBzIGFzc2VydC5cclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFsaWFzKCd3YXRlcmZhbGwnLCAnc3RlcHMnKTtcclxuXHJcblxyXG4gICAgdmFyIGNsZWFuaW5nQXJyYXkgPSBbXTtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJpbmcgYSBjbGVhbmluZyBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcclxuICAgICAqL1xyXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdhZGRDbGVhbmluZ0Z1bmN0aW9uJywgZnVuY3Rpb24oZnVuYyl7XHJcbiAgICAgICAgY2xlYW5pbmdBcnJheS5wdXNoKGZ1bmMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBhIGNsZWFuaW5nIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnVuYyB7RnVuY3Rpb259IC0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxyXG4gICAgICovXHJcbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soJ2Rpc2FibGVDbGVhbmluZ3MnLCBmdW5jdGlvbihmdW5jKXtcclxuICAgICAgICBjbGVhbmluZ0FycmF5ID0gW107XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgYXN5bmNocm9ub3VzbHkgcHJpbnRpbmcgYWxsIGV4ZWN1dGlvbiBzdW1tYXJ5IGZyb20gbG9nZ2VyLmR1bXBXaHlzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2Uge1N0cmluZ30gLSBtZXNzYWdlIHRvIGJlIHJlY29yZGVkXHJcbiAgICAgKiBAcGFyYW0gdGltZW91dCB7TnVtYmVyfSAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0aW1lb3V0IGNoZWNrLiBEZWZhdWx0IHRvIDUwMG1zLlxyXG4gICAgICovXHJcbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soJ2VuZCcsIGZ1bmN0aW9uKGNsZWFuaW5nRnVuY3Rpb24sIHRpbWVvdXQsIHNpbGVuY2Upe1xyXG4gICAgICAgIGlmKCF0aW1lb3V0KXtcclxuICAgICAgICAgICAgdGltZW91dCA9IDEwMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xyXG4gICAgICAgICAgICBpZihsb2dnZXIuZHVtcFdoeXMpe1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmR1bXBXaHlzKCkuZm9yRWFjaChmdW5jdGlvbihjKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25TdW1tYXJ5ID0gYy5nZXRFeGVjdXRpb25TdW1tYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZXhlY3V0aW9uU3VtbWFyeSwgbnVsbCwgNCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFzaWxlbmNlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm9yY2luZyBleGl0IGFmdGVyXCIsIHRpbWVvdXQsIFwibXNcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIGlmKF9fZmFpbFdhc0FscmVhZHlHZW5lcmF0ZWQgfHwgX19hc3NldHNDb3VudGVyICE9IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcclxuICAgICAgICAgICAgICAgIH0gIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTAwMClcclxuXHJcbiAgICAgICAgICAgIGNsZWFuaW5nQXJyYXkubWFwKGZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBpZihjbGVhbmluZ0Z1bmN0aW9uKXtcclxuICAgICAgICAgICAgICAgIGNsZWFuaW5nRnVuY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KTtcclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbn07IiwiLypcclxuICAgIGNoZWNrcyBhcmUgbGlrZSBhc3NlcnRzIGJ1dCBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGNvZGUgdG8gaGVscCBkZWJ1Z2dpbmcgYW5kIHNpZ25hbGluZyB3cm9uZyBiZWhhdmlvdXJzXHJcblxyXG4gKi9cclxuXHJcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKHNmKXtcclxuICAgIHNmLmV4Y2VwdGlvbnMucmVnaXN0ZXIoJ2NoZWNrRmFpbCcsIGZ1bmN0aW9uKGV4cGxhbmF0aW9uLCBlcnIpe1xyXG4gICAgICAgIHZhciBzdGFjaztcclxuICAgICAgICBpZihlcnIpe1xyXG4gICAgICAgICAgICBzdGFjayA9IGVyci5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDaGVjayBmYWlsZWQgXCIsIGV4cGxhbmF0aW9uLCBzdGFjayk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygnZXF1YWwnLCBmdW5jdGlvbih2MSAsIHYyLCBleHBsYW5hdGlvbil7XHJcblxyXG4gICAgICAgIGlmKHYxICE9PSB2Mil7XHJcbiAgICAgICAgICAgIGlmKCFleHBsYW5hdGlvbil7XHJcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBbXCIrIHYxICsgXCIgIT0gXCIgKyB2MiArIFwiXVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmNoZWNrRmFpbChleHBsYW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCd0cnVlJywgZnVuY3Rpb24oYiwgZXhwbGFuYXRpb24pe1xyXG4gICAgICAgIGlmKCFiKXtcclxuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcclxuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gIFwiIGV4cHJlc3Npb24gaXMgZmFsc2UgYnV0IGlzIGV4cGVjdGVkIHRvIGJlIHRydWVcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5jaGVja0ZhaWwoZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygnZmFsc2UnLCBmdW5jdGlvbihiLCBleHBsYW5hdGlvbil7XHJcbiAgICAgICAgaWYoYil7XHJcbiAgICAgICAgICAgIGlmKCFleHBsYW5hdGlvbil7XHJcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBleHByZXNzaW9uIGlzIHRydWUgYnV0IGlzIGV4cGVjdGVkIHRvIGJlIGZhbHNlXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuY2hlY2tGYWlsKGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygnbm90ZXF1YWwnLCBmdW5jdGlvbih2MSAsIHYyLCBleHBsYW5hdGlvbil7XHJcbiAgICAgICAgaWYodjEgPT0gdjIpe1xyXG4gICAgICAgICAgICBpZighZXhwbGFuYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb24gPSAgXCIgW1wiKyB2MSArIFwiID09IFwiICsgdjIgKyBcIl1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmNoZWNrRmFpbChleHBsYW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgICAgYWRkZWQgbWFpbmx5IGZvciB0ZXN0IHB1cnBvc2VzLCBiZXR0ZXIgdGVzdCBmcmFtZXdvcmtzIGxpa2UgbW9jaGEgY291bGQgYmUgbXVjaCBiZXR0ZXIgOilcclxuICAgICovXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygnZmFpbCcsIGZ1bmN0aW9uKHRlc3ROYW1lICxmdW5jKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRmFpbF0gXCIgKyB0ZXN0TmFtZSApO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUGFzc10gXCIgKyB0ZXN0TmFtZSApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygncGFzcycsIGZ1bmN0aW9uKHRlc3ROYW1lICxmdW5jKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUGFzc10gXCIgKyB0ZXN0TmFtZSApO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRmFpbF0gXCIgKyB0ZXN0TmFtZSAgLCAgZXJyLnN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgc2YuY2hlY2suYWxpYXMoJ3Rlc3QnLCdwYXNzJyk7XHJcblxyXG5cclxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdjYWxsYmFjaycsIGZ1bmN0aW9uKHRlc3ROYW1lICxmdW5jLCB0aW1lb3V0KXtcclxuICAgICAgICBpZighdGltZW91dCl7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSA1MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpe1xyXG4gICAgICAgICAgICBpZighcGFzc2VkKXtcclxuICAgICAgICAgICAgICAgIHBhc3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltQYXNzXSBcIiArIHRlc3ROYW1lICk7XHJcbiAgICAgICAgICAgICAgICBTdWNjZXNzVGVzdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRmFpbCAobXVsdGlwbGUgY2FsbHMpXSBcIiArIHRlc3ROYW1lICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBmdW5jKGNhbGxiYWNrKTtcclxuICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0ZhaWxdIFwiICsgdGVzdE5hbWUgICwgIGVyci5zdGFjayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBTdWNjZXNzVGVzdChmb3JjZSl7XHJcbiAgICAgICAgICAgIGlmKCFwYXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRmFpbCBUaW1lb3V0XSBcIiArIHRlc3ROYW1lICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoU3VjY2Vzc1Rlc3QsIHRpbWVvdXQpO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdzdGVwcycsIGZ1bmN0aW9uKHRlc3ROYW1lICwgYXJyLCB0aW1lb3V0KXtcclxuICAgICAgICB2YXIgIGN1cnJlbnRTdGVwID0gMDtcclxuICAgICAgICB2YXIgcGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYoIXRpbWVvdXQpe1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gNTAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpe1xyXG4gICAgICAgICAgICBpZihjdXJyZW50U3RlcCA9PT0gYXJyLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUGFzc10gXCIgKyB0ZXN0TmFtZSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IGFycltjdXJyZW50U3RlcF07XHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwKys7XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIGZ1bmMobmV4dCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0ZhaWxdIFwiICsgdGVzdE5hbWUgICxcIlxcblxcdFwiICwgZXJyLnN0YWNrICsgXCJcXG5cXHRcIiAsIFwiIFthdCBzdGVwIFwiLCBjdXJyZW50U3RlcCArIFwiXVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gU3VjY2Vzc1Rlc3QoZm9yY2Upe1xyXG4gICAgICAgICAgICBpZighcGFzc2VkKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0ZhaWwgVGltZW91dF0gXCIgKyB0ZXN0TmFtZSArIFwiXFxuXFx0XCIgLCBcIiBbYXQgc3RlcCBcIiwgY3VycmVudFN0ZXArIFwiXVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChTdWNjZXNzVGVzdCwgdGltZW91dCk7XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2YuY2hlY2suYWxpYXMoJ3dhdGVyZmFsbCcsJ3N0ZXBzJyk7XHJcbiAgICBzZi5jaGVjay5hbGlhcygnbm90RXF1YWwnLCdub3RlcXVhbCcpO1xyXG5cclxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdlbmQnLCBmdW5jdGlvbih0aW1lT3V0LCBzaWxlbmNlKXtcclxuICAgICAgICBpZighdGltZU91dCl7XHJcbiAgICAgICAgICAgIHRpbWVPdXQgPSAxMDAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZighc2lsZW5jZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvcmNpbmcgZXhpdCBhZnRlclwiLCB0aW1lT3V0LCBcIm1zXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcclxuICAgICAgICB9LCB0aW1lT3V0KTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBzZi5jaGVjay5hZGRDaGVjaygnYmVnaW4nLCBmdW5jdGlvbihtZXNzYWdlLCB0aW1lT3V0KXtcclxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgICAgICBzZi5jaGVjay5lbmQodGltZU91dCwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG59OyIsImV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKHNmKXtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJpbmcgdW5rbm93biBleGNlcHRpb24gaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3RlcigndW5rbm93bicsIGZ1bmN0aW9uKGV4cGxhbmF0aW9uKXtcclxuICAgICAgICBleHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uIHx8IFwiXCI7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiVW5rbm93biBleGNlcHRpb25cIiArIGV4cGxhbmF0aW9uO1xyXG4gICAgICAgIHRocm93KG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyByZXNlbmQgZXhjZXB0aW9uIGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHNmLmV4Y2VwdGlvbnMucmVnaXN0ZXIoJ3Jlc2VuZCcsIGZ1bmN0aW9uKGV4Y2VwdGlvbnMpe1xyXG4gICAgICAgIHRocm93KGV4Y2VwdGlvbnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmluZyBub3RJbXBsZW1lbnRlZCBleGNlcHRpb24gaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3Rlcignbm90SW1wbGVtZW50ZWQnLCBmdW5jdGlvbihleHBsYW5hdGlvbil7XHJcbiAgICAgICAgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbiB8fCBcIlwiO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIm5vdEltcGxlbWVudGVkIGV4Y2VwdGlvblwiICsgZXhwbGFuYXRpb247XHJcbiAgICAgICAgdGhyb3cobWVzc2FnZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyaW5nIHNlY3VyaXR5IGV4Y2VwdGlvbiBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBzZi5leGNlcHRpb25zLnJlZ2lzdGVyKCdzZWN1cml0eScsIGZ1bmN0aW9uKGV4cGxhbmF0aW9uKXtcclxuICAgICAgICBleHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uIHx8IFwiXCI7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2VjdXJpdHkgZXhjZXB0aW9uXCIgKyBleHBsYW5hdGlvbjtcclxuICAgICAgICB0aHJvdyhtZXNzYWdlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJpbmcgZHVwbGljYXRlRGVwZW5kZW5jeSBleGNlcHRpb24gaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3RlcignZHVwbGljYXRlRGVwZW5kZW5jeScsIGZ1bmN0aW9uKHZhcmlhYmxlKXtcclxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlIHx8IFwiXCI7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiZHVwbGljYXRlRGVwZW5kZW5jeSBleGNlcHRpb25cIiArIHZhcmlhYmxlO1xyXG4gICAgICAgIHRocm93KG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbn07IiwiY29uc3QgTE9HX0xFVkVMUyA9IHtcclxuICAgIEhBUkRfRVJST1I6IDAsICAvLyBzeXN0ZW0gbGV2ZWwgY3JpdGljYWwgZXJyb3I6IGhhcmRFcnJvclxyXG4gICAgRVJST1I6IDEsICAvLyBwb3RlbnRpYWxseSBjYXVzaW5nIHVzZXIncyBkYXRhIGxvb3NpbmcgZXJyb3I6IGVycm9yXHJcbiAgICBMT0dfRVJST1I6IDIsICAvLyBtaW5vciBhbm5veWFuY2UsIHJlY292ZXJhYmxlIGVycm9yOiAgIGxvZ0Vycm9yXHJcbiAgICBVWF9FUlJPUjogMywgIC8vIHVzZXIgZXhwZXJpZW5jZSBjYXVzaW5nIGlzc3VlcyBlcnJvcjogIHV4RXJyb3JcclxuICAgIFdBUk46IDQsICAvLyB3YXJuaW5nLHBvc3NpYmxlIGlzdWVzIGJ1dCBzb21laG93IHVuY2xlYXIgYmVoYXZpb3VyOiB3YXJuXHJcbiAgICBJTkZPOiA1LCAgLy8gc3RvcmUgZ2VuZXJhbCBpbmZvIGFib3V0IHRoZSBzeXN0ZW0gd29ya2luZzogaW5mb1xyXG4gICAgREVCVUc6IDYsICAvLyBzeXN0ZW0gbGV2ZWwgZGVidWc6IGRlYnVnXHJcbiAgICBMT0NBTF9ERUJVRzogNywgIC8vIGxvY2FsIG5vZGUvc2VydmljZSBkZWJ1ZzogbGRlYnVnXHJcbiAgICBVU0VSX0RFQlVHOiA4LCAgLy8gdXNlciBsZXZlbCBkZWJ1ZzsgdWRlYnVnXHJcbiAgICBERVZfREVCVUc6IDksICAvLyBkZXZlbG9wbWVudCB0aW1lIGRlYnVnOiBkZGVidWdcclxuICAgIFdIWVM6IDEwLCAvLyB3aHlMb2cgZm9yIGNvZGUgcmVhc29uaW5nXHJcbiAgICBURVNUX1JFU1VMVDogMTEsIC8vIHRlc3RSZXN1bHQgdG8gbG9nIHJ1bm5pbmcgdGVzdHNcclxufTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uIChzZikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjb3JkcyBsb2cgbWVzc2FnZXMgZnJvbSB2YXJpb3VzIHVzZSBjYXNlcy5cclxuICAgICAqIEBwYXJhbSByZWNvcmQge1N0cmluZ30gLSBsb2cgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLnJlY29yZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBjb25zdCB0cmlnZ2VyU3RyaW5ncyA9IFtcInBza3J1bnRpbWVcIiwgXCJkb3VibGUtY2hlY2tcIl07XHJcbiAgICAgICAgdmFyIGRpc3BsYXlPbkNvbnNvbGUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLnNlbmQpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5zZW5kKHJlY29yZCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPbkNvbnNvbGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUxpbmVzKHN0ciwgbmIpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTGluZShzdHIsICBmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHN0ci5pbmRleE9mKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpbGxCZVJlbW92ZWQgPSBzdHIuc2xpY2UoMCwgcG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kTWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTwgdHJpZ2dlclN0cmluZ3MubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdHJpZ2dlclN0cmluZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWxsQmVSZW1vdmVkLmluZGV4T2YoaXRlbSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBmb3VuZE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UocG9zICsgMSwgc3RyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByZXQgPSBzdHI7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgbmI7IHYrKykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSByZW1vdmVMaW5lKHJldCwgdj09MCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nLi4uIGV4aXQgZm9yXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXNwbGF5T25Db25zb2xlKSB7XHJcbiAgICAgICAgICAgIC8vY29uc3QgcHJldHR5TG9nID0gSlNPTi5zdHJpbmdpZnkocmVjb3JkLCBudWxsLCAyKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwcmV0dHlMb2cpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZWNvcmQubWVzc2FnZSwgdHlwZW9mIChyZWNvcmQuc3RhY2spKTtcclxuICAgICAgICAgICAgaWYgKHJlY29yZC5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHJlY29yZC5zdGFjay5pbmRleE9mKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZWNvcmQuc3RhY2suc2xpY2UoMCwgcG9zKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVtb3ZlTGluZXMocmVjb3JkLnN0YWNrLCAzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgc3lzdGVtIGxldmVsIGNyaXRpY2FsIGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2hhcmRFcnJvcicsIGZ1bmN0aW9uIChtZXNzYWdlLCBleGNlcHRpb24sIGFyZ3MsIHBvcywgZGF0YSkge1xyXG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5IQVJEX0VSUk9SLCAnc3lzdGVtRXJyb3InLCBtZXNzYWdlLCBleGNlcHRpb24sIHRydWUsIGFyZ3MsIHBvcywgZGF0YSkpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnZXhwbGFuYXRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBwb3RlbnRpYWxseSBjYXVzaW5nIHVzZXIncyBkYXRhIGxvb3NpbmcgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgnZXJyb3InLCBmdW5jdGlvbiAobWVzc2FnZSwgZXhjZXB0aW9uLCBhcmdzLCBwb3MsIGRhdGEpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuRVJST1IsICdlcnJvcicsIG1lc3NhZ2UsIGV4Y2VwdGlvbiwgdHJ1ZSwgYXJncywgcG9zLCBkYXRhKSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAnbWVzc2FnZSc6ICdleHBsYW5hdGlvbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgJ2V4Y2VwdGlvbic6ICdleGNlcHRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBtaW5vciBhbm5veWFuY2UsIHJlY292ZXJhYmxlIGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2xvZ0Vycm9yJywgZnVuY3Rpb24gKG1lc3NhZ2UsIGV4Y2VwdGlvbiwgYXJncywgcG9zLCBkYXRhKSB7XHJcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLkxPR19FUlJPUiwgJ2xvZ0Vycm9yJywgbWVzc2FnZSwgZXhjZXB0aW9uLCB0cnVlLCBhcmdzLCBwb3MsIGRhdGEpKTtcclxuICAgIH0sIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ2V4cGxhbmF0aW9uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAnZXhjZXB0aW9uJzogJ2V4Y2VwdGlvbidcclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIHVzZXIgZXhwZXJpZW5jZSBjYXVzaW5nIGlzc3VlcyBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHNmLmxvZ2dlci5hZGRDYXNlKCd1eEVycm9yJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuVVhfRVJST1IsICd1eEVycm9yJywgbWVzc2FnZSwgbnVsbCwgZmFsc2UpKTtcclxuICAgIH0sIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ2V4cGxhbmF0aW9uJ1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgdGhyb3R0bGluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ3Rocm90dGxpbmcnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5XQVJOLCAndGhyb3R0bGluZycsIG1lc3NhZ2UsIG51bGwsIGZhbHNlKSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAnbWVzc2FnZSc6ICdleHBsYW5hdGlvbidcclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIHdhcm5pbmcsIHBvc3NpYmxlIGlzc3VlcywgYnV0IHNvbWVob3cgdW5jbGVhciBiZWhhdmlvdXJzLlxyXG4gICAgICovXHJcbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgnd2FybmluZycsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLldBUk4sICd3YXJuaW5nJywgbWVzc2FnZSwgbnVsbCwgZmFsc2UsIGFyZ3VtZW50cywgMCkpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnZXhwbGFuYXRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgc2YubG9nZ2VyLmFsaWFzKCd3YXJuJywgJ3dhcm5pbmcnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGdlbmVyYWwgaW5mbyBhYm91dCB0aGUgc3lzdGVtIHdvcmtpbmcuXHJcbiAgICAgKi9cclxuICAgIHNmLmxvZ2dlci5hZGRDYXNlKCdpbmZvJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuSU5GTywgJ2luZm8nLCBtZXNzYWdlLCBudWxsLCBmYWxzZSwgYXJndW1lbnRzLCAwKSk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAnbWVzc2FnZSc6ICdleHBsYW5hdGlvbidcclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIHN5c3RlbSBsZXZlbCBkZWJ1ZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2RlYnVnJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuREVCVUcsICdkZWJ1ZycsIG1lc3NhZ2UsIG51bGwsIGZhbHNlLCBhcmd1bWVudHMsIDApKTtcclxuICAgIH0sIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ2V4cGxhbmF0aW9uJ1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGxvY2FsIG5vZGUvc2VydmljZSBkZWJ1ZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2xkZWJ1ZycsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLkxPQ0FMX0RFQlVHLCAnbGRlYnVnJywgbWVzc2FnZSwgbnVsbCwgZmFsc2UsIGFyZ3VtZW50cywgMCkpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnZXhwbGFuYXRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyB1c2VyIGxldmVsIGRlYnVnIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgndWRlYnVnJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuVVNFUl9ERUJVRywgJ3VkZWJ1ZycsIG1lc3NhZ2UsIG51bGwsIGZhbHNlLCBhcmd1bWVudHMsIDApKTtcclxuICAgIH0sIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ2V4cGxhbmF0aW9uJ1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgZGV2ZWxvcG1lbnQgZGVidWcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHNmLmxvZ2dlci5hZGRDYXNlKCdkZXZlbCcsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLkRFVl9ERUJVRywgJ2RldmVsJywgbWVzc2FnZSwgbnVsbCwgZmFsc2UsIGFyZ3VtZW50cywgMCkpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnZXhwbGFuYXRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBcIndoeXNcIiByZWFzb25pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHNmLmxvZ2dlci5hZGRDYXNlKFwibG9nV2h5XCIsIGZ1bmN0aW9uIChsb2dPbmx5Q3VycmVudFdoeUNvbnRleHQpIHtcclxuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuV0hZUywgJ2xvZ3doeScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGxvZ09ubHlDdXJyZW50V2h5Q29udGV4dCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBhc3NlcnRzIG1lc3NhZ2VzIHRvIHJ1bm5pbmcgdGVzdHMuXHJcbiAgICAgKi9cclxuICAgIHNmLmxvZ2dlci5hZGRDYXNlKFwicmVjb3JkQXNzZXJ0XCIsIGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvciwgc2hvd1N0YWNrKSB7XHJcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLlRFU1RfUkVTVUxULCAnYXNzZXJ0JywgbWVzc2FnZSwgZXJyb3IsIHNob3dTdGFjaykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmljIG1ldGhvZCB0byBjcmVhdGUgc3RydWN0dXJlZCBkZWJ1ZyByZWNvcmRzIGJhc2VkIG9uIHRoZSBsb2cgbGV2ZWwuXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwge051bWJlcn0gLSBudW1iZXIgZnJvbSAxLTExLCB1c2VkIHRvIGlkZW50aWZ5IHRoZSBsZXZlbCBvZiBhdHRlbnRpb24gdGhhdCBhIGxvZyBlbnRyeSBzaG91bGQgZ2V0IGZyb20gb3BlcmF0aW9ucyBwb2ludCBvZiB2aWV3XHJcbiAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAtIGlkZW50aWZpZXIgbmFtZSBmb3IgbG9nIHR5cGVcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtTdHJpbmd9IC0gZGVzY3JpcHRpb24gb2YgdGhlIGRlYnVnIHJlY29yZFxyXG4gICAgICogQHBhcmFtIGV4Y2VwdGlvbiB7U3RyaW5nfSAtIGV4Y2VwdGlvbiBkZXRhaWxzIGlmIGFueVxyXG4gICAgICogQHBhcmFtIHNhdmVTdGFjayB7Qm9vbGVhbn0gLSBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGV4Y2VwdGlvbiBjYWxsIHN0YWNrIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRlYnVnIHJlY29yZFxyXG4gICAgICogQHBhcmFtIGFyZ3Mge0FycmF5fSAtIGFyZ3VtZW50cyBvZiB0aGUgY2FsbGVyIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcG9zIHtOdW1iZXJ9IC0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSBkYXRhIHtTdHJpbmd8TnVtYmVyfEFycmF5fE9iamVjdH0gLSBwYXlsb2FkIGluZm9ybWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbG9nT25seUN1cnJlbnRXaHlDb250ZXh0IC0gaWYgd2h5cyBpcyBlbmFibGVkLCBvbmx5IHRoZSBjdXJyZW50IGNvbnRleHQgd2lsbCBiZSBsb2dnZWRcclxuICAgICAqIEByZXR1cm5zIERlYnVnIHJlY29yZCBtb2RlbCB7T2JqZWN0fSB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxyXG4gICAgICogW3JlcXVpcmVkXTogbGV2ZWw6ICosIHR5cGU6ICosIHRpbWVzdGFtcDogbnVtYmVyLCBtZXNzYWdlOiAqLCBkYXRhOiAqIGFuZFxyXG4gICAgICogW29wdGlvbmFsXTogc3RhY2s6ICosIGV4Y2VwdGlvbjogKiwgYXJnczogKiwgd2h5TG9nOiAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnUmVjb3JkKGxldmVsLCB0eXBlLCBtZXNzYWdlLCBleGNlcHRpb24sIHNhdmVTdGFjaywgYXJncywgcG9zLCBkYXRhLCBsb2dPbmx5Q3VycmVudFdoeUNvbnRleHQpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldCA9IHtcclxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoc2F2ZVN0YWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjayA9IGV4Y2VwdGlvbi5zdGFjaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXQuc3RhY2sgPSBzdGFjaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0LmV4Y2VwdGlvbiA9IGV4Y2VwdGlvbi5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0LmFyZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5SVU5fV0lUSF9XSFlTKSB7XHJcbiAgICAgICAgICAgIHZhciB3aHkgPSByZXF1aXJlKCd3aHlzJyk7XHJcbiAgICAgICAgICAgIGlmIChsb2dPbmx5Q3VycmVudFdoeUNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldFsnd2h5TG9nJ10gPSB3aHkuZ2V0R2xvYmFsQ3VycmVudENvbnRleHQoKS5nZXRFeGVjdXRpb25TdW1tYXJ5KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXRbJ3doeUxvZyddID0gd2h5LmdldEFsbENvbnRleHRzKCkubWFwKGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RXhlY3V0aW9uU3VtbWFyeSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbn1cclxuO1xyXG5cclxuIiwiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZm9ya2VyID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xyXG5cclxuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMjAwMDtcclxuXHJcbnZhciBnbG9iVG9SZWdFeHAgPSAgcmVxdWlyZShcIi4vdXRpbHMvZ2xvYi10by1yZWdleHBcIik7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgIGNvbmZGaWxlTmFtZTogXCJkb3VibGUtY2hlY2suanNvblwiLCAgICAgIC8vIG5hbWUgb2YgdGhlIGNvbmYgZmlsZVxyXG4gICAgZmlsZUV4dDogXCIuanNcIiwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBmaWxlIHN1cHBvcnRlZCBieSBleHRlbnNpb25cclxuICAgIG1hdGNoRGlyczogWyAndGVzdCcsICd0ZXN0cycgXSwgICAgICAgICAgIC8vIGRpcnMgbmFtZXMgZm9yIHRlc3RzIC0gY2FzZSBpbnNlbnNpdGl2ZSAodXNlZCBpbiBkaXNjb3ZlcnkgcHJvY2VzcylcclxuICAgIHRlc3RzRGlyOiBwcm9jZXNzLmN3ZCgpLCAgICAgICAgICAgICAgICAvLyBwYXRoIHRvIHRoZSByb290IHRlc3RzIGxvY2F0aW9uXHJcbiAgICByZXBvcnRzOiB7XHJcbiAgICAgICAgYmFzZVBhdGg6IHByb2Nlc3MuY3dkKCksICAgICAgICAgICAgLy8gcGF0aCB3aGVyZSB0aGUgcmVwb3J0cyB3aWxsIGJlIHNhdmVkXHJcbiAgICAgICAgcHJlZml4OiBcIlJlcG9ydC1cIiwgICAgICAgICAgICAgICAgICAvLyBwcmVmaXggZm9yIHJlcG9ydCBmaWxlcywgZmlsZW5hbWUgcGF0dGVybjogW3ByZWZpeF0te3RpbWVzdGFtcH17ZXh0fVxyXG4gICAgICAgIGV4dDogXCIudHh0XCIgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IGZpbGUgZXh0ZW5zaW9uXHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBUQUcgPSBcIltURVNUX1JVTk5FUl1cIjtcclxuY29uc3QgTUFYX1dPUktFUlMgPSBwcm9jZXNzLmVudlsnRE9VQkxFX0NIRUNLX1BPT0xfU0laRSddIHx8IDEwO1xyXG5jb25zdCBERUJVRyA9IHR5cGVvZiB2OGRlYnVnID09PSAnb2JqZWN0JztcclxuXHJcbmNvbnN0IFRFU1RfU1RBVEVTID0ge1xyXG4gICAgUkVBRFk6ICdyZWFkeScsXHJcbiAgICBSVU5OSU5HOiAncnVubmluZycsXHJcbiAgICBGSU5JU0hFRDogJ2ZpbmlzaGVkJyxcclxuICAgIFRJTUVPVVQ6ICd0aW1lb3V0J1xyXG59O1xyXG5cclxuLy8gU2Vzc2lvbiBvYmplY3RcclxudmFyIGRlZmF1bHRTZXNzaW9uID0ge1xyXG4gICAgdGVzdENvdW50OiAwLFxyXG4gICAgY3VycmVudFRlc3RJbmRleDogMCxcclxuICAgIGRlYnVnUG9ydDogcHJvY2Vzcy5kZWJ1Z1BvcnQsICAgLy8gY3VycmVudCBwcm9jZXNzIGRlYnVnIHBvcnQuIFRoZSBjaGlsZCBwcm9jZXNzIHdpbGwgYmUgaW5jcmVhc2VkIGZyb20gdGhpcyBwb3J0XHJcbiAgICB3b3JrZXJzOiB7XHJcbiAgICAgICAgcnVubmluZzogMCxcclxuICAgICAgICB0ZXJtaW5hdGVkOiAwXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBUZW1wbGF0ZSBzdHJ1Y3R1cmUgZm9yIHRlc3QgcmVwb3J0cy5cclxudmFyIHJlcG9ydEZpbGVTdHJ1Y3R1cmUgPSB7XHJcbiAgICBjb3VudDogMCxcclxuICAgIHN1aXRlczoge1xyXG4gICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgIGl0ZW1zOiBbXVxyXG4gICAgfSxcclxuICAgIHBhc3NlZDoge1xyXG4gICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgIGl0ZW1zOiBbXVxyXG4gICAgfSxcclxuICAgIGZhaWxlZDoge1xyXG4gICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgIGl0ZW1zOiBbXVxyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKHNmKXtcclxuICAgIHNmLnRlc3RSdW5uZXIgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHRlc3QgcnVubmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcge09iamVjdH0gLSBzZXR0aW5ncyBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0IG9uZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLl9fZXh0ZW5kKGRlZmF1bHRDb25maWcsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMudGVzdFRyZWUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy50ZXN0TGlzdCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gZGVmYXVsdFNlc3Npb247XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVwb3J0cyBkaXJlY3RvcnkgaWYgbm90IGV4aXN0XHJcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLmNvbmZpZy5yZXBvcnRzLmJhc2VQYXRoKSl7XHJcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmModGhpcy5jb25maWcucmVwb3J0cy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1haW4gZW50cnkgcG9pbnQuIEl0IHdpbGwgc3RhcnQgdGhlIGZsb3cgcnVubmVyIGZsb3cuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSAtIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHN1Y2ggYXMgY29uZiBmaWxlIG5hbWUsIHRlc3QgZGlyLlxyXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259IC0gaGFuZGxlcihlcnJvciwgcmVzdWx0KSBpbnZva2VkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHJ1bm5lciBoYXMgY29tcGxldGVkIGFsbCBqb2JzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyB3cmFwcGVyIGZvciBwcm92aWRlZCBjYWxsYmFjaywgaWYgYW55XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlYnVnSW5mbyhlcnIubWVzc2FnZSB8fCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19pbml0KGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9fY29uc29sZUxvZyhcIkRpc2NvdmVyaW5nIHRlc3RzIC4uLlwiKTtcclxuICAgICAgICAgICAgdGhpcy50ZXN0VHJlZSA9IHRoaXMuX19kaXNjb3ZlclRlc3RGaWxlcyh0aGlzLmNvbmZpZy50ZXN0c0RpciwgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy50ZXN0TGlzdCA9IHRoaXMuX190b1Rlc3RUcmVlVG9MaXN0KHRoaXMudGVzdFRyZWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9fbGF1bmNoVGVzdHMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZnJvbSBhIGpzb24gZmlsZS5cclxuICAgICAgICAgKiBAcGFyYW0gY29uZlBhdGgge1N0cmluZ30gLSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBjb25maWd1cmF0aW9uIGZpbGUuXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gLSBjb25maWd1cmF0aW9uIG9iamVjdCB7e319XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX3JlYWRDb25mOiBmdW5jdGlvbihjb25mUGF0aCkge1xyXG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge307XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHJlcXVpcmUoY29uZlBhdGgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2NvdmVycyB0ZXN0IGZpbGVzIHJlY3Vyc2l2ZWx5IHN0YXJ0aW5nIGZyb20gYSBwYXRoLiBUaGUgZGlyIGlzIHRoZSByb290IG9mIHRoZSB0ZXN0IGZpbGVzLiBJdCBjYW4gY29udGFpbnNcclxuICAgICAgICAgKiB0ZXN0IGZpbGVzIGFuZCB0ZXN0IHN1YiBkaXJlY3Rvcmllcy4gSXQgd2lsbCBjcmVhdGUgYSB0cmVlIHN0cnVjdHVyZSB3aXRoIHRoZSB0ZXN0IGZpbGVzIGRpc2NvdmVyZWQuXHJcbiAgICAgICAgICogTm90ZXM6IE9ubHkgdGhlIGNvbmZpZy5tYXRjaERpcnMgd2lsbCBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24uIEFsc28sIGJhc2VkIG9uIHRoZSBjb25mIChkb3VibGUtY2hlY2suanNvbilcclxuICAgICAgICAgKiBpdCB3aWxsIGluY2x1ZGUgdGhlIHRlc3QgZmlsZXMgb3Igbm90LlxyXG4gICAgICAgICAqIEBwYXJhbSBkaXIge1N0cmluZ30gLSBwYXRoIHdoZXJlIHRoZSBkaXNjb3ZlcnkgcHJvY2VzcyBzdGFydHNcclxuICAgICAgICAgKiBAcGFyYW0gcGFyZW50Q29uZiB7U3RyaW5nfSAtIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChkb3VibGUtY2hlY2suanNvbikgZnJvbSB0aGUgcGFyZW50IGRpcmVjdG9yeVxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSByb290IG5vZGUgb2JqZWN0IG9mIHRoZSBmaWxlIHN0cnVjdHVyZSB0cmVlLiBFLmcuIHsqfHtfX21ldGEsIGRhdGEsIHJlc3VsdCwgaXRlbXN9fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19kaXNjb3ZlclRlc3RGaWxlczogZnVuY3Rpb24oZGlyLCBwYXJlbnRDb25mKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhkaXIpO1xyXG4gICAgICAgICAgICBpZighc3RhdC5pc0RpcmVjdG9yeSgpKXtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaXIgKyBcIiBpcyBub3QgYSBkaXJlY3RvcnkhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgY3VycmVudENvbmYgPSBwYXJlbnRDb25mO1xyXG5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5fX2dldERlZmF1bHROb2RlU3RydWN0dXJlKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLl9fbWV0YS5wYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGlyKTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUuX19tZXRhLmlzRGlyZWN0b3J5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IGxvb2sgZm9yIGNvbmYgZmlsZVxyXG4gICAgICAgICAgICBpZihmaWxlcy5pbmRleE9mKHRoaXMuY29uZmlnLmNvbmZGaWxlTmFtZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmQgPSBwYXRoLmpvaW4oZGlyLCB0aGlzLmNvbmZpZy5jb25mRmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmYgPSB0aGlzLl9fcmVhZENvbmYoZmQpO1xyXG4gICAgICAgICAgICAgICAgaWYoY29uZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLl9fbWV0YS5jb25mID0gY29uZjtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29uZiA9IGNvbmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmRhdGEubmFtZSA9IHBhdGguYmFzZW5hbWUoZGlyKTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUuZGF0YS5wYXRoID0gZGlyO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5pdGVtcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMCwgbGVuID0gZmlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZmlsZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGZkID0gcGF0aC5qb2luKGRpciwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdCA9IGZzLnN0YXRTeW5jKGZkKTtcclxuICAgICAgICAgICAgICAgIGxldCBpc0RpciA9IHN0YXQuaXNEaXJlY3RvcnkoKTtcclxuICAgICAgICAgICAgICAgIGxldCBpc1Rlc3REaXIgPSB0aGlzLl9faXNUZXN0RGlyKGZkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihpc0RpciAmJiAhaXNUZXN0RGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGlnbm9yZSBkaXJzIHRoYXQgZG9lcyBub3QgZm9sbG93IHRoZSBuYW1pbmcgcnVsZSBmb3IgdGVzdCBkaXJzXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIWlzRGlyICYmIGl0ZW0ubWF0Y2godGhpcy5jb25maWcuY29uZkZpbGVOYW1lKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGFscmVhZHkgcHJvY2Vzc2VkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXhjbHVkZSBmaWxlcyBiYXNlZCBvbiBnbG9iIHBhdHRlcm5zXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Q29uZikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRDb25mWydpZ25vcmUnXSAtIGFycmF5IG9mIHJlZ0V4cFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRDb25mWydpZ25vcmUnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc01hdGNoID0gdGhpcy5fX2lzQW55TWF0Y2goY3VycmVudENvbmZbJ2lnbm9yZSddLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNNYXRjaCkge2NvbnRpbnVlO31cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IHRoaXMuX19nZXREZWZhdWx0Tm9kZVN0cnVjdHVyZSgpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLl9fbWV0YS5jb25mID0ge307XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX19tZXRhLmlzRGlyZWN0b3J5ID0gaXNEaXI7XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX19tZXRhLnBhcmVudCA9IHBhdGguZGlybmFtZShmZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBDaGlsZE5vZGUgPSB0aGlzLl9fZGlzY292ZXJUZXN0RmlsZXMoZmQsIGN1cnJlbnRDb25mKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBPYmplY3QuYXNzaWduKGNoaWxkTm9kZSwgdGVtcENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaXRlbXMucHVzaChjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihwYXRoLmV4dG5hbWUoZmQpID09PSAgdGhpcy5jb25maWcuZmlsZUV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLl9fbWV0YS5jb25mLnJ1bnMgPSBjdXJyZW50Q29uZlsncnVucyddIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLl9fbWV0YS5jb25mLnNpbGVudCA9IGN1cnJlbnRDb25mWydzaWxlbnQnXTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX19tZXRhLmNvbmYudGltZW91dCA9IGN1cnJlbnRDb25mWyd0aW1lb3V0J10gfHwgREVGQVVMVF9USU1FT1VUO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuZGF0YS5uYW1lID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuZGF0YS5wYXRoID0gZmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLml0ZW1zLnB1c2goY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGF1bmNoIGNvbGxlY3RlZCB0ZXN0cy4gSW5pdGlhbGlzZXMgc2Vzc2lvbiB2YXJpYWJsZXMsIHRoYXQgYXJlIHNwZWNpZmljIGZvciB0aGUgY3VycmVudCBsYXVuY2guXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX2xhdW5jaFRlc3RzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2coXCJMYXVuY2hpbmcgdGVzdHMgLi4uXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udGVzdENvdW50ID0gdGhpcy50ZXN0TGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5wcm9jZXNzZWRUZXN0Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ud29ya2Vycy5ydW5uaW5nID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLndvcmtlcnMudGVybWluYXRlZCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnNlc3Npb24udGVzdENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlV29yaygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RvVGVzdFJlcG9ydHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NoZWR1bGVzIHdvcmsgYmFzZWQgb24gdGhlIE1BWCBhdmFpbGFibGUgd29ya2VycywgYW5kIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgcnVucyBvZiBhIHRlc3QuXHJcbiAgICAgICAgICogSWYgYSB0ZXN0IGhhcyBtdWx0aXBsZSBydW5zIGFzIGEgb3B0aW9uLCBpdCB3aWxsIGJlIHN0YXJ0ZWQgaW4gbXVsdGlwbGUgd29ya2Vycy4gT25jZSBhbGwgcnVucyBhcmUgY29tcGxldGVkLFxyXG4gICAgICAgICAqIHRoZSB0ZXN0IGlzIGNvbnNpZGVyZWQgYXMgcHJvY2Vzc2VkLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19zY2hlZHVsZVdvcms6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB3aGlsZSh0aGlzLnNlc3Npb24ud29ya2Vycy5ydW5uaW5nIDwgTUFYX1dPUktFUlMgJiYgdGhpcy5zZXNzaW9uLmN1cnJlbnRUZXN0SW5kZXggPCB0aGlzLnNlc3Npb24udGVzdENvdW50KXtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXN0ID0gdGhpcy50ZXN0TGlzdFt0aGlzLnNlc3Npb24uY3VycmVudFRlc3RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZih0ZXN0LnJlc3VsdC5ydW5zIDwgdGVzdC5fX21ldGEuY29uZi5ydW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQucnVucysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19sYXVuY2hUZXN0KHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY3VycmVudFRlc3RJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMYXVuY2ggYSB0ZXN0IGludG8gYSBzZXBhcmF0ZSB3b3JrZXIgKGNoaWxkIHByb2Nlc3MpLlxyXG4gICAgICAgICAqIEVhY2ggd29ya2VyIGhhcyBoYW5kbGVycyBmb3IgbWVzc2FnZSwgZXhpdCBhbmQgZXJyb3IgZXZlbnRzLiBPbmNlIHRoZSBleGl0IG9yIGVycm9yIGV2ZW50IGlzIGludm9rZWQsXHJcbiAgICAgICAgICogbmV3IHdvcmsgaXMgc2NoZWR1bGVkIGFuZCBzZXNzaW9uIG9iamVjdCBpcyB1cGRhdGVkLlxyXG4gICAgICAgICAqIE5vdGVzOiBPbiBkZWJ1ZyBtb2RlLCB0aGUgd29ya2VycyB3aWxsIHJlY2VpdmUgYSBkZWJ1ZyBwb3J0LCB0aGF0IGlzIGluY3JlYXNlZCBpbmNyZW1lbnRhbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB0ZXN0IHtPYmplY3R9IC0gdGVzdCBvYmplY3RcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fbGF1bmNoVGVzdDogZnVuY3Rpb24odGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ud29ya2Vycy5ydW5uaW5nKys7XHJcblxyXG4gICAgICAgICAgICB0ZXN0LnJlc3VsdC5zdGF0ZSA9IFRFU1RfU1RBVEVTLlJVTk5JTkc7XHJcbiAgICAgICAgICAgIHRlc3QucmVzdWx0LnBhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB0ZXN0LnJlc3VsdC5hc3NlcnRzW3Rlc3QucmVzdWx0LnJ1bnNdID0gW107XHJcbiAgICAgICAgICAgIHRlc3QucmVzdWx0Lm1lc3NhZ2VzW3Rlc3QucmVzdWx0LnJ1bnNdID0gW107XHJcblxyXG4gICAgICAgICAgICBsZXQgZW52ID0gcHJvY2Vzcy5lbnY7XHJcblxyXG4gICAgICAgICAgICBsZXQgZXhlY0FyZ3YgPSBbXTtcclxuICAgICAgICAgICAgaWYoREVCVUcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnUG9ydCA9ICsrZGVmYXVsdFNlc3Npb24uZGVidWdQb3J0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVidWdGbGFnID0gJy0tZGVidWc9JyArIGRlYnVnUG9ydDtcclxuICAgICAgICAgICAgICAgIGV4ZWNBcmd2LnB1c2goZGVidWdGbGFnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgY3dkID0gdGVzdC5fX21ldGEucGFyZW50O1xyXG5cclxuICAgICAgICAgICAgbGV0IHdvcmtlciA9IGZvcmtlci5mb3JrKHRlc3QuZGF0YS5wYXRoLCBbXSwgeydjd2QnOiBjd2QsICdlbnYnOiBlbnYsICdleGVjQXJndic6IGV4ZWNBcmd2LCBzdGRpbzogWyAnaW5oZXJpdCcsIFwicGlwZVwiLCAnaW5oZXJpdCcsICdpcGMnIF0sIHNpbGVudDpmYWxzZSB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19kZWJ1Z0luZm8oYExhdW5jaGluZyB0ZXN0ICR7dGVzdC5kYXRhLm5hbWV9LCBydW5bJHt0ZXN0LnJlc3VsdC5ydW5zfV0sIG9uIHdvcmtlciBwaWRbJHt3b3JrZXIucGlkfV0gYCtuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcblxyXG4gICAgICAgICAgICB3b3JrZXIub24oXCJtZXNzYWdlXCIsIG9uTWVzc2FnZUV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkpO1xyXG4gICAgICAgICAgICB3b3JrZXIub24oXCJleGl0XCIsIG9uRXhpdEV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkpO1xyXG4gICAgICAgICAgICB3b3JrZXIub24oXCJlcnJvclwiLCBvbkVycm9yRXZlbnRIYW5kbGVyV3JhcHBlcih0ZXN0KSk7XHJcblxyXG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgd29ya2VyLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBuZXcgQnVmZmVyKGNodW5rKS50b1N0cmluZygndXRmOCcpOyAvL1RPRE86IHJlcGxhY2Ugd2l0aCBQU0tCVUZGRVJcclxuICAgICAgICAgICAgICAgIGlmKHRlc3QuX19tZXRhLmNvbmYuc2lsZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2coY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTWVzc2FnZUV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJ1biA9IHRlc3QucmVzdWx0LnJ1bnM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obG9nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobG9nLnR5cGUgPT09ICdhc3NlcnQnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobG9nLm1lc3NhZ2UuaW5jbHVkZXMoXCJbRmFpbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQucGFzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0LmFzc2VydHNbY3VycmVudFJ1bl0ucHVzaChsb2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0Lm1lc3NhZ2VzW2N1cnJlbnRSdW5dLnB1c2gobG9nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkV4aXRFdmVudEhhbmRsZXJXcmFwcGVyKHRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb2RlLCBzaWduYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod29ya2VyLnRpbWVyVmFyKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fZGVidWdJbmZvKGBXb3JrZXIgJHt3b3JrZXIucGlkfSAtIGV4aXQgZXZlbnQuIENvZGUgJHtjb2RlfSwgc2lnbmFsICR7c2lnbmFsfSBgK25ldyBEYXRlKCkuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXN0LnJlc3VsdC5zdGF0ZSA9IFRFU1RfU1RBVEVTLkZJTklTSEVEO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvZGUgIT09IG51bGwgJiYgY29kZSE9PTAgLyomJiB0eXBlb2YgdGVzdC5yZXN1bHQucGFzcyA9PT0gJ3VuZGVmaW5lZCcqLyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0LnBhc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQubWVzc2FnZXNbdGVzdC5yZXN1bHQucnVuc10ucHVzaCgge21lc3NhZ2U6IFwiUHJvY2VzcyBmaW5pc2hlZCB3aXRoIGVycm9ycyFcIiwgXCJFeGl0IGNvZGVcIjpjb2RlLCBcIlNpZ25hbFwiOnNpZ25hbH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXNzaW9uLndvcmtlcnMucnVubmluZy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vzc2lvbi53b3JrZXJzLnRlcm1pbmF0ZWQrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fX3NjaGVkdWxlV29yaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX19jaGVja1dvcmtlcnNTdGF0dXMoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaGFuZGxlciBjYW4gYmUgdHJpZ2dlcmVkIHdoZW46XHJcbiAgICAgICAgICAgIC8vIDEuIFRoZSBwcm9jZXNzIGNvdWxkIG5vdCBiZSBzcGF3bmVkLCBvclxyXG4gICAgICAgICAgICAvLyAyLiBUaGUgcHJvY2VzcyBjb3VsZCBub3QgYmUga2lsbGVkLCBvclxyXG4gICAgICAgICAgICAvLyAzLiBTZW5kaW5nIGEgbWVzc2FnZSB0byB0aGUgY2hpbGQgcHJvY2VzcyBmYWlsZWQuXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogVGhlICdleGl0JyBldmVudCBtYXkgb3IgbWF5IG5vdCBmaXJlIGFmdGVyIGFuIGVycm9yIGhhcyBvY2N1cnJlZCFcclxuICAgICAgICAgICAgZnVuY3Rpb24gb25FcnJvckV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2RlYnVnSW5mbyhgV29ya2VyICR7d29ya2VyLnBpZH0gLSBlcnJvciBldmVudC5gLCB0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fZGVidWdFcnJvcihlcnJvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vzc2lvbi53b3JrZXJzLnJ1bm5pbmctLTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlc3Npb24ud29ya2Vycy50ZXJtaW5hdGVkKys7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RlOiBvbiBkZWJ1ZywgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgZXhpdCBldmVudCBpcyBjYWxsZWRcclxuICAgICAgICAgICAgLy8gd2hlbiBraWxsIGlzIGNhbGxlZCwgdGhlIGV4aXQgZXZlbnQgaXMgcmFpc2VkXHJcbiAgICAgICAgICAgIHdvcmtlci50aW1lclZhciA9IHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgICAgIGlmKCF3b3JrZXIudGVybWluYXRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2coYHdvcmtlciBwaWQgWyR7d29ya2VyLnBpZH1dIC0gdGltZW91dCBldmVudGAsbmV3IERhdGUoKS5nZXRUaW1lKCksICB0ZXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGVzdC5yZXN1bHQuc3RhdGUgIT09IFRFU1RfU1RBVEVTLkZJTklTSEVEKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQucGFzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0LnN0YXRlID0gVEVTVF9TVEFURVMuVElNRU9VVDtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR290IHNvbWV0aGluZywgYnV0IGRvbid0IGtub3cgd2hhdC4uLlwiLCB0ZXN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGVzdC5fX21ldGEuY29uZi50aW1lb3V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLl9fZGVidWdJbmZvKGBXb3JrZXIgJHt3b3JrZXIucGlkfSAtIHNldCB0aW1lb3V0IGV2ZW50IGF0IGArbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIiBmb3IgXCIrdGVzdC5fX21ldGEuY29uZi50aW1lb3V0KTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgYWxsIHdvcmtlcnMgY29tcGxldGVkIHRoZWlyIGpvYiAoZmluaXNoZWQgb3IgaGF2ZSBiZWVuIHRlcm1pbmF0ZWQpLlxyXG4gICAgICAgICAqIElmIHRydWUsIHRoZW4gdGhlIHJlcG9ydGluZyBzdGVwcyBjYW4gYmUgc3RhcnRlZC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fY2hlY2tXb3JrZXJzU3RhdHVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zZXNzaW9uLndvcmtlcnMucnVubmluZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RvVGVzdFJlcG9ydHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0ZXN0IHJlcG9ydHMgb2JqZWN0IChKU09OKSB0aGF0IHdpbGwgYmUgc2F2ZWQgaW4gdGhlIHRlc3QgcmVwb3J0LlxyXG4gICAgICAgICAqIEZpbGVuYW1lIG9mIHRoZSByZXBvcnQgaXMgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXR0ZXJuOiB7cHJlZml4fS17dGltZXN0YW1wfXtleHR9XHJcbiAgICAgICAgICogVGhlIGZpbGUgd2lsbCBiZSBzYXZlZCBpbiBjb25maWcucmVwb3J0cy5iYXNlUGF0aC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fZG9UZXN0UmVwb3J0czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKFwiRG9pbmcgcmVwb3J0cyAuLi5cIik7XHJcbiAgICAgICAgICAgIHJlcG9ydEZpbGVTdHJ1Y3R1cmUuY291bnQgPSB0aGlzLnRlc3RMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIHBhc3MvZmFpbGVkIHRlc3RzXHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDAsIGxlbiA9IHRoaXMudGVzdExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXN0ID0gdGhpcy50ZXN0TGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdGVzdFBhdGggPSB0aGlzLl9fdG9SZWxhdGl2ZVBhdGgodGVzdC5kYXRhLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7cGF0aDogdGVzdFBhdGh9O1xyXG4gICAgICAgICAgICAgICAgaWYodGVzdC5yZXN1bHQucGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVhc29uID0gdGhpcy5fX2dldEZpcnN0RmFpbFJlYXNvblBlclJ1bih0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLnBhc3NlZC5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlYXNvbiA9IHRoaXMuX19nZXRGaXJzdEZhaWxSZWFzb25QZXJSdW4odGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0RmlsZVN0cnVjdHVyZS5mYWlsZWQuaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLnBhc3NlZC5jb3VudCA9IHJlcG9ydEZpbGVTdHJ1Y3R1cmUucGFzc2VkLml0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgICAgcmVwb3J0RmlsZVN0cnVjdHVyZS5mYWlsZWQuY291bnQgPSByZXBvcnRGaWxlU3RydWN0dXJlLmZhaWxlZC5pdGVtcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBzdWl0ZXMgKGZpcnN0IGxldmVsIG9mIGRpcmVjdG9yaWVzKVxyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnRlc3RUcmVlLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMudGVzdFRyZWUuaXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZihpdGVtLl9fbWV0YS5pc0RpcmVjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWl0ZVBhdGggPSB0aGlzLl9fdG9SZWxhdGl2ZVBhdGgoaXRlbS5kYXRhLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydEZpbGVTdHJ1Y3R1cmUuc3VpdGVzLml0ZW1zLnB1c2goc3VpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLnN1aXRlcy5jb3VudCA9IHJlcG9ydEZpbGVTdHJ1Y3R1cmUuc3VpdGVzLml0ZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGxldCBudW1iZXJPZlJlcG9ydHMgPSAyO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbmlzaFJlcG9ydHMgPSAoZXJyLCByZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmKG51bWJlck9mUmVwb3J0cyA+IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mUmVwb3J0cyAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHJlcG9ydEZpbGVTdHJ1Y3R1cmUuZmFpbGVkLmNvdW50ID09PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29uc29sZUxvZyhcIlxcbkV2ZXJ5dGhpbmcgd2VudCB3ZWxsISBObyBmYWlsZWQgdGVzdHMuXFxuXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2coXCJcXG5Tb21lIHRlc3RzIGZhaWxlZC4gQ2hlY2sgcmVwb3J0IGZpbGVzIVxcblxcblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVyciwgXCJEb25lXCIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKHRoaXMuY29uZmlnLnJlcG9ydHMucHJlZml4KTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBgJHt0aGlzLmNvbmZpZy5yZXBvcnRzLnByZWZpeH1sYXRlc3Qke3RoaXMuY29uZmlnLnJlcG9ydHMuZXh0fWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLnJlcG9ydHMuYmFzZVBhdGgsIGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fX3NhdmVSZXBvcnRUb0ZpbGUocmVwb3J0RmlsZVN0cnVjdHVyZSwgZmlsZVBhdGgsIGZpbmlzaFJlcG9ydHMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgaHRtbEZpbGVOYW1lID0gYCR7dGhpcy5jb25maWcucmVwb3J0cy5wcmVmaXh9bGF0ZXN0Lmh0bWxgO1xyXG4gICAgICAgICAgICBjb25zdCBodG1sRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5jb25maWcucmVwb3J0cy5iYXNlUGF0aCwgaHRtbEZpbGVOYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fX3NhdmVIdG1sUmVwb3J0VG9GaWxlKHJlcG9ydEZpbGVTdHJ1Y3R1cmUsIGh0bWxGaWxlUGF0aCwgdGltZXN0YW1wLCBmaW5pc2hSZXBvcnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmVzIHRlc3QgcmVwb3J0cyBvYmplY3QgKEpTT04pIGluIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAgICAgKiBAcGFyYW0gcmVwb3J0RmlsZVN0cnVjdHVyZSB7T2JqZWN0fSAtIHRlc3QgcmVwb3J0cyBvYmplY3QgKEpTT04pXHJcbiAgICAgICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIHtTdHJpbmd9IC0gcGF0aCBvZiB0aGUgZmlsZSByZXBvcnQgKHRoZSBiYXNlIHBhdGggTVVTVCBleGlzdClcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fc2F2ZVJlcG9ydFRvRmlsZTogZnVuY3Rpb24ocmVwb3J0RmlsZVN0cnVjdHVyZSwgZGVzdGluYXRpb24sIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHJlcG9ydEZpbGVTdHJ1Y3R1cmUsIG51bGwsIDQpO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGUoZGVzdGluYXRpb24sIGNvbnRlbnQsICd1dGY4JywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHdyaXRpbmcgdGhlIHJlcG9ydCBmaWxlLCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3I6IFwiICsgSlNPTi5zdHJpbmdpZnkoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVidWdJbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZpbmlzaGVkIHdyaXRpbmcgcmVwb3J0IHRvICR7ZGVzdGluYXRpb259YDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29uc29sZUxvZyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlcyB0ZXN0IHJlcG9ydHMgYXMgSFRNTCBpbiB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAgICAgICAgICogQHBhcmFtIHJlcG9ydEZpbGVTdHJ1Y3R1cmUge09iamVjdH0gLSB0ZXN0IHJlcG9ydHMgb2JqZWN0IChKU09OKVxyXG4gICAgICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiB7U3RyaW5nfSAtIHBhdGggb2YgdGhlIGZpbGUgcmVwb3J0ICh0aGUgYmFzZSBwYXRoIE1VU1QgZXhpc3QpXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVzdGFtcCB7U3RyaW5nfSAtIHRpbWVzdGFtcCB0byBiZSBpbmplY3RlZCBpbiBodG1sIHRlbXBsYXRlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX3NhdmVIdG1sUmVwb3J0VG9GaWxlOiBmdW5jdGlvbiAocmVwb3J0RmlsZVN0cnVjdHVyZSwgZGVzdGluYXRpb24sIHRpbWVzdGFtcCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGZvbGRlck5hbWUgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lKTtcclxuICAgICAgICAgICAgZnMucmVhZEZpbGUocGF0aC5qb2luKGZvbGRlck5hbWUsJy91dGlscy9yZXBvcnRUZW1wbGF0ZS5odG1sJyksICd1dGY4JywgKGVyciwgcmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZWFkaW5nIHRoZSBodG1sIHJlcG9ydCB0ZW1wbGF0ZSBmaWxlLCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWJ1Z0luZm8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZShkZXN0aW5hdGlvbiwgcmVzICsgYDxzY3JpcHQ+aW5pdCgke0pTT04uc3RyaW5naWZ5KHJlcG9ydEZpbGVTdHJ1Y3R1cmUpfSwgJHt0aW1lc3RhbXB9KTs8L3NjcmlwdD5gLCAndXRmOCcsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgd3JpdGluZyB0aGUgaHRtbCByZXBvcnQgZmlsZSwgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlYnVnSW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBGaW5pc2hlZCB3cml0aW5nIHJlcG9ydCB0byAke2Rlc3RpbmF0aW9ufWA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2cobWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhYnNvbHV0ZSBmaWxlIHBhdGggdG8gcmVsYXRpdmUgcGF0aC5cclxuICAgICAgICAgKiBAcGFyYW0gYWJzb2x1dGVQYXRoIHtTdHJpbmd9IC0gYWJzb2x1dGUgcGF0aFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB2b2lkIHwgKn0gLSByZWxhdGl2ZSBwYXRoXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX3RvUmVsYXRpdmVQYXRoOiBmdW5jdGlvbihhYnNvbHV0ZVBhdGgpIHtcclxuICAgICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBwYXRoLmpvaW4odGhpcy5jb25maWcudGVzdHNEaXIsIFwiL1wiKTtcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gYWJzb2x1dGVQYXRoLnJlcGxhY2UoYmFzZVBhdGgsIFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgZGlyZWN0b3J5IGlzIGEgdGVzdCBkaXIsIGJ5IG1hdGNoaW5nIGl0cyBuYW1lIGFnYWluc3QgY29uZmlnLm1hdGNoRGlycyBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0gZGlyIHtTdHJpbmd9IC0gZGlyZWN0b3J5IG5hbWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSBtYXRjaCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19pc1Rlc3REaXI6IGZ1bmN0aW9uKGRpcikge1xyXG4gICAgICAgICAgICBpZighdGhpcy5jb25maWcgfHwgIXRoaXMuY29uZmlnLm1hdGNoRGlycyApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGBtYXRjaERpcnMgaXMgbm90IGRlZmluZWQgb24gY29uZmlnICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpfSBkb2VzIG5vdCBleGlzdCFgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaXNUZXN0RGlyID0gdGhpcy5jb25maWcubWF0Y2hEaXJzLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGl0ZW0udG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlzVGVzdERpcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvciBhIGZhaWxlZCB0ZXN0LCBpdCByZXR1cm5zIG9ubHkgdGhlIGZpcnN0IGZhaWwgcmVhc29uIHBlciBlYWNoIHJ1bi5cclxuICAgICAgICAgKiBAcGFyYW0gdGVzdCB7T2JqZWN0fSAtIHRlc3Qgb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSAtIGFuIGFycmF5IG9mIHJlYXNvbnMgcGVyIGVhY2ggdGVzdCBydW4uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX2dldEZpcnN0RmFpbFJlYXNvblBlclJ1bjogZnVuY3Rpb24odGVzdCkge1xyXG4gICAgICAgICAgICBjb25zdCByZWFzb24gPSBbXTtcclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8PSB0ZXN0LnJlc3VsdC5ydW5zOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKHRlc3QucmVzdWx0LmFzc2VydHNbaV0gJiYgdGVzdC5yZXN1bHQuYXNzZXJ0c1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVhc29uKGksIHRlc3QucmVzdWx0LmFzc2VydHNbaV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRlc3QucmVzdWx0Lm1lc3NhZ2VzW2ldICYmIHRlc3QucmVzdWx0Lm1lc3NhZ2VzW2ldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRSZWFzb24oaSwgdGVzdC5yZXN1bHQubWVzc2FnZXNbaV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlYXNvbihydW4sIGxvZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogcnVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2c6IGxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbi5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVhc29uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzY3JpYmVkIGRlZmF1bHQgdHJlZSBub2RlIHN0cnVjdHVyZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7e19fbWV0YToge2NvbmY6IG51bGwsIHBhcmVudDogbnVsbCwgaXNEaXJlY3Rvcnk6IGJvb2xlYW59LCBkYXRhOiB7bmFtZTogbnVsbCwgcGF0aDogbnVsbH0sIHJlc3VsdDoge3N0YXRlOiBzdHJpbmcsIHBhc3M6IG51bGwsIGV4ZWN1dGlvblRpbWU6IG51bWJlciwgcnVuczogbnVtYmVyLCBhc3NlcnRzOiB7fSwgbWVzc2FnZXM6IHt9fSwgaXRlbXM6IG51bGx9fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19nZXREZWZhdWx0Tm9kZVN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAge1xyXG4gICAgICAgICAgICAgICAgX19tZXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogVEVTVF9TVEFURVMuUkVBRFksIC8vIHJlYWR5IHwgcnVubmluZyB8IHRlcm1pbmF0ZWQgfCB0aW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgcGFzczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25UaW1lOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bnM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0czoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHt9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hdGNoIGEgdGVzdCBmaWxlIHBhdGggdG8gYSBVTklYIGdsb2IgZXhwcmVzc2lvbiBhcnJheS4gSWYgaXRzIGFueSBtYXRjaCByZXR1cm5zIHRydWUsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBnbG9iRXhwQXJyYXkge0FycmF5fSAtIGFuIGFycmF5IHdpdGggZ2xvYiBleHByZXNzaW9uIChVTklYIHN0eWxlKVxyXG4gICAgICAgICAqIEBwYXJhbSBzdHIge1N0cmluZ30gLSB0aGUgc3RyaW5nIHRvIGJlIG1hdGNoZWRcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW55IG1hdGNoIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX2lzQW55TWF0Y2g6IGZ1bmN0aW9uKGdsb2JFeHBBcnJheSwgc3RyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoID0gZnVuY3Rpb24oZ2xvYkV4cCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBnbG9iVG9SZWdFeHAoZ2xvYkV4cCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdChzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JFeHBBcnJheS5zb21lKGhhc01hdGNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgdHJlZSBzdHJ1Y3R1cmUgaW50byBhbiBhcnJheSBsaXN0IG9mIHRlc3Qgbm9kZXMuIFRoZSB0cmVlIHRyYXZlcnNhbCBpcyBERlMgKERlZXAtRmlyc3QtU2VhcmNoKS5cclxuICAgICAgICAgKiBAcGFyYW0gcm9vdE5vZGUge09iamVjdH0gLSByb290IG5vZGUgb2YgdGhlIHRlc3QgdHJlZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gTGlzdCBvZiB0ZXN0IG5vZGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX190b1Rlc3RUcmVlVG9MaXN0OiBmdW5jdGlvbihyb290Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVzdExpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHJvb3ROb2RlKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCFub2RlLl9fbWV0YS5pc0RpcmVjdG9yeSB8fCAhbm9kZS5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBub2RlLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG5vZGUuaXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX21ldGEuaXNEaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExpc3QucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ZXN0TGlzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZ2dpbmcgdG8gY29uc29sZSB3cmFwcGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBsb2cge1N0cmluZ3xPYmplY3R8TnVtYmVyfSAtIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX2NvbnNvbGVMb2c6IGZ1bmN0aW9uKGxvZykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhUQUcsIGxvZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dnaW5nIGRlYnVnZ2luZyBpbmZvIG1lc3NhZ2VzIHdyYXBwZXIuXHJcbiAgICAgICAgICogTG9nZ2VyOiBjb25zb2xlLmluZm9cclxuICAgICAgICAgKiBAcGFyYW0gbG9nIHtTdHJpbmd8T2JqZWN0fE51bWJlcn0gLSBsb2cgbWVzc2FnZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19kZWJ1Z0luZm86IGZ1bmN0aW9uKGxvZykge1xyXG4gICAgICAgICAgICB0aGlzLl9fZGVidWcoY29uc29sZS5pbmZvLCBsb2cpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9nZ2luZyBkZWJ1Z2dpbmcgZXJyb3IgbWVzc2FnZXMgd3JhcHBlci5cclxuICAgICAgICAgKiBMb2dnZXI6IGNvbnNvbGUuZXJyb3JcclxuICAgICAgICAgKiBAcGFyYW0gbG9nIHtTdHJpbmd8T2JqZWN0fE51bWJlcn0gLSBsb2cgbWVzc2FnZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX19kZWJ1Z0Vycm9yOiBmdW5jdGlvbihsb2cpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2RlYnVnKGNvbnNvbGUuZXJyb3IsIGxvZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgTG9nZ2luZyBkZWJ1Z2dpbmcgbWVzc2FnZXMgd3JhcHBlci4gT25lIGRlYnVnIG1vZGUsIHRoZSBsb2dnaW5nIGlzIHNpbGVudC5cclxuICAgICAgICAgKiBAcGFyYW0gbG9nZ2VyIHtGdW5jdGlvbn0gLSBoYW5kbGVyIGZvciBsb2dnaW5nXHJcbiAgICAgICAgICogQHBhcmFtIGxvZyB7U3RyaW5nfE9iamVjdHxOdW1iZXJ9IC0gbG9nIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9fZGVidWc6IGZ1bmN0aW9uKGxvZ2dlciwgbG9nKSB7XHJcbiAgICAgICAgICAgIGlmKCFERUJVRykge3JldHVybjt9XHJcblxyXG4gICAgICAgICAgICAvLyBsZXQgcHJldHR5TG9nID0gSlNPTi5zdHJpbmdpZnkobG9nLCBudWxsLCAyKTtcclxuICAgICAgICAgICAgbG9nZ2VyKFwiREVCVUdcIiwgbG9nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZXAgZXh0ZW5kIG9uZSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIElmIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gYm90aCBvYmplY3RzIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBmaXJzdCBvYmplY3QgaXMgb3ZlcnJpZGRlbi5cclxuICAgICAgICAgKiBAcGFyYW0gZmlyc3Qge09iamVjdH0gLSB0aGUgZmlyc3Qgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHNlY29uZCB7T2JqZWN0fSAtIHRoZSBzZWNvbmQgb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gLSBhbiBvYmplY3Qgd2l0aCBib3RoIHByb3BlcnRpZXMgZnJvbSB0aGUgZmlyc3QgYW5kIHNlY29uZCBvYmplY3QuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfX2V4dGVuZDogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2Vjb25kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFtrZXldID0gc2Vjb25kW2tleV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzZWNvbmRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZmlyc3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5fX2V4dGVuZChmaXJzdFtrZXldLCBzZWNvbmRba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuIiwiXHJcbi8vIGdsb2JUb1JlZ0V4cCB0dXJucyBhIFVOSVggZ2xvYiBleHByZXNzaW9uIGludG8gYSBSZWdFeCBleHByZXNzaW9uLlxyXG4vLyAgU3VwcG9ydHMgYWxsIHNpbXBsZSBnbG9iIHBhdHRlcm5zLiBFeGFtcGxlczogKi5leHQsIC9mb28vKiwgLi4vLi4vcGF0aCwgXmZvby4qXHJcbi8vIC0gc2luZ2xlIGNoYXJhY3RlciBtYXRjaGluZywgbWF0Y2hpbmcgcmFuZ2VzIG9mIGNoYXJhY3RlcnMgZXRjLiBncm91cCBtYXRjaGluZyBhcmUgbm8gc3VwcG9ydGVkXHJcbi8vIC0gZmxhZ3MgYXJlIG5vdCBzdXBwb3J0ZWRcclxudmFyIGdsb2JUb1JlZ0V4cCA9IGZ1bmN0aW9uIChnbG9iRXhwKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JFeHAgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2xvYiBFeHByZXNzaW9uIG11c3QgYmUgYSBzdHJpbmchJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ0V4cCA9IFwiXCI7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGdsb2JFeHAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IGdsb2JFeHBbaV07XHJcblxyXG4gICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiIVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwifFwiOlxyXG4gICAgICAgICAgICAgICAgcmVnRXhwICs9IFwiXFxcXFwiICsgYztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcIipcIjpcclxuICAgICAgICAgICAgICAgIC8vIHRyZWF0IGFueSBudW1iZXIgb2YgXCIqXCIgYXMgb25lXHJcbiAgICAgICAgICAgICAgICB3aGlsZShnbG9iRXhwW2kgKyAxXSA9PT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWdFeHAgKz0gXCIuKlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmVnRXhwICs9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB0aGUgcmVndWxhciBleHByZXNzaW9uIHdpdGggXiAmICRcclxuICAgIHJlZ0V4cCA9IFwiXlwiICsgcmVnRXhwICsgXCIkXCI7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnRXhwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2xvYlRvUmVnRXhwOyIsImNvbnN0IHV0aWxzID0gcmVxdWlyZShcInN3YXJtdXRpbHNcIik7XHJcbmNvbnN0IE93TSA9IHV0aWxzLk93TTtcclxudmFyIGJlZXNIZWFsZXIgPSB1dGlscy5iZWVzSGVhbGVyO1xyXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG5cclxuLy9UT0RPOiBwcmV2ZW50IGEgY2xhc3Mgb2YgcmFjZSBjb25kaXRpb24gdHlwZSBvZiBlcnJvcnMgYnkgc2lnbmFsaW5nIHdpdGggZmlsZXMgbWV0YWRhdGEgdG8gdGhlIHdhdGNoZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGNvbnN1bWVcclxuXHJcbmZ1bmN0aW9uIEZvbGRlck1RKGZvbGRlciwgY2FsbGJhY2sgPSAoKSA9PiB7fSl7XHJcblxyXG5cdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XHJcblx0fVxyXG5cclxuXHRmb2xkZXIgPSBwYXRoLm5vcm1hbGl6ZShmb2xkZXIpO1xyXG5cclxuXHRmcy5ta2Rpcihmb2xkZXIsIHtyZWN1cnNpdmU6IHRydWV9LCBmdW5jdGlvbihlcnIsIHJlcyl7XHJcblx0XHRmcy5leGlzdHMoZm9sZGVyLCBmdW5jdGlvbihleGlzdHMpIHtcclxuXHRcdFx0aWYgKGV4aXN0cykge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBmb2xkZXIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHJcblx0ZnVuY3Rpb24gbWtGaWxlTmFtZShzd2FybVJhdyl7XHJcblx0XHRsZXQgbWV0YSA9IE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc3dhcm1SYXcpO1xyXG5cdFx0bGV0IG5hbWUgPSBgJHtmb2xkZXJ9JHtwYXRoLnNlcH0ke21ldGEuc3dhcm1JZH0uJHttZXRhLnN3YXJtVHlwZU5hbWV9YDtcclxuXHRcdGNvbnN0IHVuaXF1ZSA9IG1ldGEucGhhc2VJZCB8fCAkJC51aWRHZW5lcmF0b3Iuc2FmZV91dWlkKCk7XHJcblxyXG5cdFx0bmFtZSA9IG5hbWUrYC4ke3VuaXF1ZX1gO1xyXG5cdFx0cmV0dXJuIHBhdGgubm9ybWFsaXplKG5hbWUpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5nZXRIYW5kbGVyID0gZnVuY3Rpb24oKXtcclxuXHRcdGlmKHByb2R1Y2VyKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgY29uc3VtZXIgaXMgYWxsb3dlZCFcIik7XHJcblx0XHR9XHJcblx0XHRwcm9kdWNlciA9IHRydWU7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzZW5kU3dhcm1TZXJpYWxpemF0aW9uOiBmdW5jdGlvbihzZXJpYWxpemF0aW9uLCBjYWxsYmFjayl7XHJcblx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0d3JpdGVGaWxlKG1rRmlsZU5hbWUoSlNPTi5wYXJzZShzZXJpYWxpemF0aW9uKSksIHNlcmlhbGl6YXRpb24sIGNhbGxiYWNrKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YWRkU3RyZWFtIDogZnVuY3Rpb24oc3RyZWFtLCBjYWxsYmFjayl7XHJcblx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKCFzdHJlYW0gfHwgIXN0cmVhbS5waXBlIHx8IHR5cGVvZiBzdHJlYW0ucGlwZSAhPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJTb21ldGhpbmcgd3JvbmcgaGFwcGVuZWRcIikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IHN3YXJtID0gXCJcIjtcclxuXHRcdFx0XHRzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+e1xyXG5cdFx0XHRcdFx0c3dhcm0gKz0gY2h1bms7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHR3cml0ZUZpbGUobWtGaWxlTmFtZShKU09OLnBhcnNlKHN3YXJtKSksIHN3YXJtLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHN0cmVhbS5vbihcImVycm9yXCIsIChlcnIpID0+e1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YWRkU3dhcm0gOiBmdW5jdGlvbihzd2FybSwgY2FsbGJhY2spe1xyXG5cdFx0XHRcdGlmKCFjYWxsYmFjayl7XHJcblx0XHRcdFx0XHRjYWxsYmFjayA9ICQkLmRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb247XHJcblx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJlZXNIZWFsZXIuYXNKU09OKHN3YXJtLG51bGwsIG51bGwsIGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHdyaXRlRmlsZShta0ZpbGVOYW1lKHJlcyksIEoocmVzKSwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZW5kU3dhcm1Gb3JFeGVjdXRpb246IGZ1bmN0aW9uKHN3YXJtLCBjYWxsYmFjayl7XHJcblx0XHRcdFx0aWYoIWNhbGxiYWNrKXtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gJCQuZGVmYXVsdEVycm9ySGFuZGxpbmdJbXBsZW1lbnRhdGlvbjtcclxuXHRcdFx0XHR9ZWxzZSBpZih0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIil7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmVlc0hlYWxlci5hc0pTT04oc3dhcm0sIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc3dhcm0sIFwicGhhc2VOYW1lXCIpLCBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHN3YXJtLCBcImFyZ3NcIiksIGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBmaWxlID0gbWtGaWxlTmFtZShyZXMpO1xyXG5cdFx0XHRcdFx0dmFyIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXMpO1xyXG5cclxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgRkQncyBmb3IgZmlsZXMgdG8gYmUgd3JpdHRlbiB3ZSByZXRyeS5cclxuXHRcdFx0XHRcdGZ1bmN0aW9uIHdyYXBwZXIoZXJyb3IsIHJlc3VsdCl7XHJcblx0XHRcdFx0XHRcdGlmKGVycm9yKXtcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgQ2F1Z2h0IGFuIHdyaXRlIGVycm9yLiBSZXRyeSB0byB3cml0ZSBmaWxlIFske2ZpbGV9XWApO1xyXG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoKCk9PntcclxuXHRcdFx0XHRcdFx0XHRcdHdyaXRlRmlsZShmaWxlLCBjb250ZW50LCB3cmFwcGVyKTtcclxuXHRcdFx0XHRcdFx0XHR9LCAxMCk7XHJcblx0XHRcdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHdyaXRlRmlsZShmaWxlLCBjb250ZW50LCB3cmFwcGVyKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcmVjaXBpZW50O1xyXG5cdHRoaXMuc2V0SVBDQ2hhbm5lbCA9IGZ1bmN0aW9uKHByb2Nlc3NDaGFubmVsKXtcclxuXHRcdGlmKHByb2Nlc3NDaGFubmVsICYmICFwcm9jZXNzQ2hhbm5lbC5zZW5kIHx8ICh0eXBlb2YgcHJvY2Vzc0NoYW5uZWwuc2VuZCkgIT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUmVjaXBpZW50IGlzIG5vdCBpbnN0YW5jZSBvZiBwcm9jZXNzL2NoaWxkX3Byb2Nlc3Mgb3IgaXQgd2FzIG5vdCBzcGF3bmVkIHdpdGggSVBDIGNoYW5uZWwhXCIpO1xyXG5cdFx0fVxyXG5cdFx0cmVjaXBpZW50ID0gcHJvY2Vzc0NoYW5uZWw7XHJcblx0XHRpZihjb25zdW1lcil7XHJcblx0XHRcdGNvbnNvbGUubG9nKGBDaGFubmVsIHVwZGF0ZWRgKTtcclxuXHRcdFx0KHJlY2lwaWVudCB8fCBwcm9jZXNzKS5vbihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUVudmVsb3BlKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIGNvbnN1bWVkTWVzc2FnZXMgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gY2hlY2tJZkNvbnN1bW1lZChuYW1lLCBtZXNzYWdlKXtcclxuXHRcdGNvbnN0IHNob3J0TmFtZSA9IHBhdGguYmFzZW5hbWUobmFtZSk7XHJcblx0XHRjb25zdCBwcmV2aW91c1NhdmVkID0gY29uc3VtZWRNZXNzYWdlc1tzaG9ydE5hbWVdO1xyXG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xyXG5cdFx0aWYocHJldmlvdXNTYXZlZCAmJiAhcHJldmlvdXNTYXZlZC5sb2NhbGVDb21wYXJlKG1lc3NhZ2UpKXtcclxuXHRcdFx0cmVzdWx0ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzYXZlMkhpc3RvcnkoZW52ZWxvcGUpe1xyXG5cdFx0Y29uc3VtZWRNZXNzYWdlc1twYXRoLmJhc2VuYW1lKGVudmVsb3BlLm5hbWUpXSA9IGVudmVsb3BlLm1lc3NhZ2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBidWlsZEVudmVsb3BlQ29uZmlybWF0aW9uKGVudmVsb3BlLCBzYXZlSGlzdG9yeSl7XHJcblx0XHRpZihzYXZlSGlzdG9yeSl7XHJcblx0XHRcdHNhdmUySGlzdG9yeShlbnZlbG9wZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYENvbmZpcm0gZW52ZWxvcGUgJHtlbnZlbG9wZS50aW1lc3RhbXB9IHNlbnQgdG8gJHtlbnZlbG9wZS5kZXN0fWA7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBidWlsZEVudmVsb3BlKG5hbWUsIG1lc3NhZ2Upe1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0ZGVzdDogZm9sZGVyLFxyXG5cdFx0XHRzcmM6IHByb2Nlc3MucGlkLFxyXG5cdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG5cdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxyXG5cdFx0XHRuYW1lOiBuYW1lXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVjZWl2ZUVudmVsb3BlKGVudmVsb3BlKXtcclxuXHRcdGlmKCFlbnZlbG9wZSB8fCB0eXBlb2YgZW52ZWxvcGUgIT09IFwib2JqZWN0XCIpe1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHQvL2NvbnNvbGUubG9nKFwicmVjZWl2ZWQgZW52ZWxvcGVcIiwgZW52ZWxvcGUsIGZvbGRlcik7XHJcblxyXG5cdFx0aWYoZW52ZWxvcGUuZGVzdCAhPT0gZm9sZGVyICYmIGZvbGRlci5pbmRleE9mKGVudmVsb3BlLmRlc3QpIT09IC0xICYmIGZvbGRlci5sZW5ndGggPT09IGVudmVsb3BlLmRlc3QrMSl7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiVGhpcyBlbnZlbG9wZSBpcyBub3QgZm9yIG1lIVwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBtZXNzYWdlID0gZW52ZWxvcGUubWVzc2FnZTtcclxuXHJcblx0XHRpZihjYWxsYmFjayl7XHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJTZW5kaW5nIGNvbmZpcm1hdGlvblwiLCBwcm9jZXNzLnBpZCk7XHJcblx0XHRcdHJlY2lwaWVudC5zZW5kKGJ1aWxkRW52ZWxvcGVDb25maXJtYXRpb24oZW52ZWxvcGUsIHRydWUpKTtcclxuXHRcdFx0Y29uc3VtZXIobnVsbCwgSlNPTi5wYXJzZShtZXNzYWdlKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0aGlzLnJlZ2lzdGVyQXNJUENDb25zdW1lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xyXG5cdFx0fVxyXG5cdFx0cmVnaXN0ZXJlZEFzSVBDQ29uc3VtZXIgPSB0cnVlO1xyXG5cdFx0Ly93aWxsIHJlZ2lzdGVyIGFzIG5vcm1hbCBjb25zdW1lciBpbiBvcmRlciB0byBjb25zdW1lIGFsbCBleGlzdGluZyBtZXNzYWdlcyBidXQgd2l0aG91dCBzZXR0aW5nIHRoZSB3YXRjaGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQ29uc3VtZXIoY2FsbGJhY2ssIHRydWUsICh3YXRjaGVyKSA9PiAhd2F0Y2hlcik7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIlJlZ2lzdGVyZWQgYXMgSVBDIENvbnN1bW1lclwiLCApO1xyXG5cdFx0KHJlY2lwaWVudCB8fCBwcm9jZXNzKS5vbihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUVudmVsb3BlKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlZ2lzdGVyQ29uc3VtZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNob3VsZERlbGV0ZUFmdGVyUmVhZCA9IHRydWUsIHNob3VsZFdhaXRGb3JNb3JlID0gKHdhdGNoZXIpID0+IHRydWUpIHtcclxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnN1bWVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGNvbnN1bWVyIGlzIGFsbG93ZWQhIFwiICsgZm9sZGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdW1lciA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdGZzLm1rZGlyKGZvbGRlciwge3JlY3Vyc2l2ZTogdHJ1ZX0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xyXG5cdFx0XHRpZiAoZXJyICYmIChlcnIuY29kZSAhPT0gJ0VFWElTVCcpKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZXJyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdW1lQWxsRXhpc3Rpbmcoc2hvdWxkRGVsZXRlQWZ0ZXJSZWFkLCBzaG91bGRXYWl0Rm9yTW9yZSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLndyaXRlTWVzc2FnZSA9IHdyaXRlRmlsZTtcclxuXHJcblx0dGhpcy51bmxpbmtDb250ZW50ID0gZnVuY3Rpb24gKG1lc3NhZ2VJZCwgY2FsbGJhY2spIHtcclxuXHRcdGNvbnN0IG1lc3NhZ2VQYXRoID0gcGF0aC5qb2luKGZvbGRlciwgbWVzc2FnZUlkKTtcclxuXHJcblx0XHRmcy51bmxpbmsobWVzc2FnZVBhdGgsIChlcnIpID0+IHtcclxuXHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKGZvcmNlKXtcclxuXHRcdGlmKHR5cGVvZiBmb2xkZXIgIT0gXCJ1bmRlZmluZWRcIil7XHJcblx0XHRcdHZhciBmaWxlcztcclxuXHRcdFx0dHJ5e1xyXG5cdFx0XHRcdGZpbGVzID0gZnMucmVhZGRpclN5bmMoZm9sZGVyKTtcclxuXHRcdFx0fWNhdGNoKGVycm9yKXtcclxuXHRcdFx0XHQvLy4uXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGZpbGVzICYmIGZpbGVzLmxlbmd0aCA+IDAgJiYgIWZvcmNlKXtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRpc3Bvc2luZyBhIGNoYW5uZWwgdGhhdCBzdGlsbCBoYXMgbWVzc2FnZXMhIERpciB3aWxsIG5vdCBiZSByZW1vdmVkIVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdHRyeXtcclxuXHRcdFx0XHRcdGZzLnJtZGlyU3luYyhmb2xkZXIpO1xyXG5cdFx0XHRcdH1jYXRjaChlcnIpe1xyXG5cdFx0XHRcdFx0Ly8uLlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9sZGVyID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZihwcm9kdWNlcil7XHJcblx0XHRcdC8vbm8gbmVlZCB0byBkbyBhbnl0aGluZyBlbHNlXHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIGNvbnN1bWVyICE9IFwidW5kZWZpbmVkXCIpe1xyXG5cdFx0XHRjb25zdW1lciA9ICgpID0+IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHdhdGNoZXIpe1xyXG5cdFx0XHR3YXRjaGVyLmNsb3NlKCk7XHJcblx0XHRcdHdhdGNoZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tIHByb3RlY3RlZCAgZnVuY3Rpb25zICovXHJcblx0dmFyIGNvbnN1bWVyID0gbnVsbDtcclxuXHR2YXIgcmVnaXN0ZXJlZEFzSVBDQ29uc3VtZXIgPSBmYWxzZTtcclxuXHR2YXIgcHJvZHVjZXIgPSBudWxsO1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZFBhdGhGb3JGaWxlKGZpbGVuYW1lKXtcclxuXHRcdHJldHVybiBwYXRoLm5vcm1hbGl6ZShwYXRoLmpvaW4oZm9sZGVyLCBmaWxlbmFtZSkpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29uc3VtZU1lc3NhZ2UoZmlsZW5hbWUsIHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBmdWxsUGF0aCA9IGJ1aWxkUGF0aEZvckZpbGUoZmlsZW5hbWUpO1xyXG5cclxuXHRcdGZzLnJlYWRGaWxlKGZ1bGxQYXRoLCBcInV0ZjhcIiwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xyXG5cdFx0XHRpZiAoIWVycikge1xyXG5cdFx0XHRcdGlmIChkYXRhICE9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlBhcnNpbmcgZXJyb3JcIiwgZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRlcnIgPSBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZihjaGVja0lmQ29uc3VtbWVkKGZ1bGxQYXRoLCBkYXRhKSl7XHJcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coYG1lc3NhZ2UgYWxyZWFkeSBjb25zdW1lZCBbJHtmaWxlbmFtZX1dYCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHNob3VsZERlbGV0ZUFmdGVyUmVhZCkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZnMudW5saW5rKGZ1bGxQYXRoLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZXJyKSB7dGhyb3cgZXJyO307XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIsIG1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkNvbnN1bWUgZXJyb3JcIiwgZXJyKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjb25zdW1lQWxsRXhpc3Rpbmcoc2hvdWxkRGVsZXRlQWZ0ZXJSZWFkLCBzaG91bGRXYWl0Rm9yTW9yZSkge1xyXG5cclxuXHRcdGxldCBjdXJyZW50RmlsZXMgPSBbXTtcclxuXHJcblx0XHRmcy5yZWFkZGlyKGZvbGRlciwgJ3V0ZjgnLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xyXG5cdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0JCQuZXJyb3JIYW5kbGVyLmVycm9yKGVycik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnRGaWxlcyA9IGZpbGVzO1xyXG5cdFx0XHRpdGVyYXRlQW5kQ29uc3VtZShmaWxlcyk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3RhcnRXYXRjaGluZygpe1xyXG5cdFx0XHRpZiAoc2hvdWxkV2FpdEZvck1vcmUodHJ1ZSkpIHtcclxuXHRcdFx0XHR3YXRjaEZvbGRlcihzaG91bGREZWxldGVBZnRlclJlYWQsIHNob3VsZFdhaXRGb3JNb3JlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGl0ZXJhdGVBbmRDb25zdW1lKGZpbGVzLCBjdXJyZW50SW5kZXggPSAwKSB7XHJcblx0XHRcdGlmIChjdXJyZW50SW5kZXggPT09IGZpbGVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJzdGFydCB3YXRjaGluZ1wiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcblx0XHRcdFx0c3RhcnRXYXRjaGluZygpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHBhdGguZXh0bmFtZShmaWxlc1tjdXJyZW50SW5kZXhdKSAhPT0gaW5fcHJvZ3Jlc3MpIHtcclxuXHRcdFx0XHRjb25zdW1lTWVzc2FnZShmaWxlc1tjdXJyZW50SW5kZXhdLCBzaG91bGREZWxldGVBZnRlclJlYWQsIChlcnIsIGRhdGEpID0+IHtcclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0aXRlcmF0ZUFuZENvbnN1bWUoZmlsZXMsICsrY3VycmVudEluZGV4KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y29uc3VtZXIobnVsbCwgZGF0YSwgcGF0aC5iYXNlbmFtZShmaWxlc1tjdXJyZW50SW5kZXhdKSk7XHJcblx0XHRcdFx0XHRpZiAoc2hvdWxkV2FpdEZvck1vcmUoKSkge1xyXG5cdFx0XHRcdFx0XHRpdGVyYXRlQW5kQ29uc3VtZShmaWxlcywgKytjdXJyZW50SW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGl0ZXJhdGVBbmRDb25zdW1lKGZpbGVzLCArK2N1cnJlbnRJbmRleCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHdyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudCwgY2FsbGJhY2spe1xyXG5cdFx0aWYocmVjaXBpZW50KXtcclxuXHRcdFx0dmFyIGVudmVsb3BlID0gYnVpbGRFbnZlbG9wZShmaWxlbmFtZSwgY29udGVudCk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJTZW5kaW5nIHRvXCIsIHJlY2lwaWVudC5waWQsIHJlY2lwaWVudC5wcGlkLCBcImVudmVsb3BlXCIsIGVudmVsb3BlKTtcclxuXHRcdFx0cmVjaXBpZW50LnNlbmQoZW52ZWxvcGUpO1xyXG5cdFx0XHR2YXIgY29uZmlybWF0aW9uUmVjZWl2ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHJlY2VpdmVDb25maXJtYXRpb24obWVzc2FnZSl7XHJcblx0XHRcdFx0aWYobWVzc2FnZSA9PT0gYnVpbGRFbnZlbG9wZUNvbmZpcm1hdGlvbihlbnZlbG9wZSkpe1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlJlY2VpdmVkIGNvbmZpcm1hdGlvblwiLCByZWNpcGllbnQucGlkKTtcclxuXHRcdFx0XHRcdGNvbmZpcm1hdGlvblJlY2VpdmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHRyeXtcclxuXHRcdFx0XHRcdFx0cmVjaXBpZW50Lm9mZihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUNvbmZpcm1hdGlvbik7XHJcblx0XHRcdFx0XHR9Y2F0Y2goZXJyKXtcclxuXHRcdFx0XHRcdFx0Ly8uLi5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZWNpcGllbnQub24oXCJtZXNzYWdlXCIsIHJlY2VpdmVDb25maXJtYXRpb24pO1xyXG5cclxuXHRcdFx0c2V0VGltZW91dCgoKT0+e1xyXG5cdFx0XHRcdGlmKCFjb25maXJtYXRpb25SZWNlaXZlZCl7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm8gY29uZmlybWF0aW9uLi4uXCIsIHByb2Nlc3MucGlkKTtcclxuXHRcdFx0XHRcdGhpZGRlbl93cml0ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnQsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMjAwKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRoaWRkZW5fd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50LCBjYWxsYmFjayk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjb25zdCBpbl9wcm9ncmVzcyA9IFwiLmluX3Byb2dyZXNzXCI7XHJcblx0ZnVuY3Rpb24gaGlkZGVuX3dyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudCwgY2FsbGJhY2spe1xyXG5cdFx0dmFyIHRtcEZpbGVuYW1lID0gZmlsZW5hbWUraW5fcHJvZ3Jlc3M7XHJcblx0XHR0cnl7XHJcblx0XHRcdGlmKGZzLmV4aXN0c1N5bmModG1wRmlsZW5hbWUpIHx8IGZzLmV4aXN0c1N5bmMoZmlsZW5hbWUpKXtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhuZXcgRXJyb3IoYE92ZXJ3cml0aW5nIGZpbGUgJHtmaWxlbmFtZX1gKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZnMud3JpdGVGaWxlU3luYyh0bXBGaWxlbmFtZSwgY29udGVudCk7XHJcblx0XHRcdGZzLnJlbmFtZVN5bmModG1wRmlsZW5hbWUsIGZpbGVuYW1lKTtcclxuXHRcdH1jYXRjaChlcnIpe1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdH1cclxuXHRcdGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFscmVhZHlLbm93bkNoYW5nZXMgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gYWxyZWFkeUZpcmVkQ2hhbmdlcyhmaWxlbmFtZSwgY2hhbmdlKXtcclxuXHRcdHZhciByZXMgPSBmYWxzZTtcclxuXHRcdGlmKGFscmVhZHlLbm93bkNoYW5nZXNbZmlsZW5hbWVdKXtcclxuXHRcdFx0cmVzID0gdHJ1ZTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRhbHJlYWR5S25vd25DaGFuZ2VzW2ZpbGVuYW1lXSA9IGNoYW5nZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gd2F0Y2hGb2xkZXIoc2hvdWxkRGVsZXRlQWZ0ZXJSZWFkLCBzaG91bGRXYWl0Rm9yTW9yZSl7XHJcblxyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRmcy5yZWFkZGlyKGZvbGRlciwgJ3V0ZjgnLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdCQkLmVycm9ySGFuZGxlci5lcnJvcihlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yKHZhciBpPTA7IGk8ZmlsZXMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdFx0d2F0Y2hGaWxlc0hhbmRsZXIoXCJjaGFuZ2VcIiwgZmlsZXNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9LCAxMDAwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3YXRjaEZpbGVzSGFuZGxlcihldmVudFR5cGUsIGZpbGVuYW1lKXtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhgR290ICR7ZXZlbnRUeXBlfSBvbiAke2ZpbGVuYW1lfWApO1xyXG5cclxuXHRcdFx0aWYoIWZpbGVuYW1lIHx8IHBhdGguZXh0bmFtZShmaWxlbmFtZSkgPT09IGluX3Byb2dyZXNzKXtcclxuXHRcdFx0XHQvL2NhdWdodCBhIGRlbGV0ZSBldmVudCBvZiBhIGZpbGVcclxuXHRcdFx0XHQvL29yXHJcblx0XHRcdFx0Ly9maWxlIG5vdCByZWFkeSB0byBiZSBjb25zdW1lZCAoaW4gcHJvZ3Jlc3MpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZiA9IGJ1aWxkUGF0aEZvckZpbGUoZmlsZW5hbWUpO1xyXG5cdFx0XHRpZighZnMuZXhpc3RzU3luYyhmKSl7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkZpbGUgbm90IGZvdW5kXCIsIGYpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhgUHJlcGFyaW5nIHRvIGNvbnN1bWUgJHtmaWxlbmFtZX1gKTtcclxuXHRcdFx0aWYoIWFscmVhZHlGaXJlZENoYW5nZXMoZmlsZW5hbWUsIGV2ZW50VHlwZSkpe1xyXG5cdFx0XHRcdGNvbnN1bWVNZXNzYWdlKGZpbGVuYW1lLCBzaG91bGREZWxldGVBZnRlclJlYWQsIChlcnIsIGRhdGEpID0+IHtcclxuXHRcdFx0XHRcdC8vYWxsb3cgYSByZWFkIGEgdGhlIGZpbGVcclxuXHRcdFx0XHRcdGFscmVhZHlLbm93bkNoYW5nZXNbZmlsZW5hbWVdID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0Ly8gPz9cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJcXG5DYXVnaHQgYW4gZXJyb3JcIiwgZXJyKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN1bWVyKG51bGwsIGRhdGEsIGZpbGVuYW1lKTtcclxuXHJcblxyXG5cdFx0XHRcdFx0aWYgKCFzaG91bGRXYWl0Rm9yTW9yZSgpKSB7XHJcblx0XHRcdFx0XHRcdHdhdGNoZXIuY2xvc2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJTb21ldGhpbmcgaGFwcGVucy4uLlwiLCBmaWxlbmFtZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Y29uc3Qgd2F0Y2hlciA9IGZzLndhdGNoKGZvbGRlciwgd2F0Y2hGaWxlc0hhbmRsZXIpO1xyXG5cclxuXHRcdGNvbnN0IGludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xyXG5cdFx0XHRmcy5yZWFkZGlyKGZvbGRlciwgJ3V0ZjgnLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdCQkLmVycm9ySGFuZGxlci5lcnJvcihlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoZmlsZXMubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgXFxuXFxuRm91bmQgJHtmaWxlcy5sZW5ndGh9IGZpbGVzIG5vdCBjb25zdW1lZCB5ZXQgaW4gJHtmb2xkZXJ9YCwgbmV3IERhdGUoKS5nZXRUaW1lKCksXCJcXG5cXG5cIik7XHJcblx0XHRcdFx0XHQvL2Zha2luZyBhIHJlbmFtZSBldmVudCB0cmlnZ2VyXHJcblx0XHRcdFx0XHR3YXRjaEZpbGVzSGFuZGxlcihcInJlbmFtZVwiLCBmaWxlc1swXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDUwMDApO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0cy5nZXRGb2xkZXJRdWV1ZSA9IGZ1bmN0aW9uKGZvbGRlciwgY2FsbGJhY2spe1xyXG5cdHJldHVybiBuZXcgRm9sZGVyTVEoZm9sZGVyLCBjYWxsYmFjayk7XHJcbn07XHJcbiIsImZ1bmN0aW9uIFBTS0J1ZmZlcigpIHt9XHJcblxyXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlckludGVyZmFjZSAoKSB7XHJcbiAgICBpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gU2hhcmVkQXJyYXlCdWZmZXI7XHJcbiAgICB9XHJcbn1cclxuXHJcblBTS0J1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgY29uc3QgQXJyYXlCdWZmZXJJbnRlcmZhY2UgPSBnZXRBcnJheUJ1ZmZlckludGVyZmFjZSgpO1xyXG5cclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlckludGVyZmFjZShzb3VyY2UubGVuZ3RoKSk7XHJcbiAgICBidWZmZXIuc2V0KHNvdXJjZSwgMCk7XHJcblxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufTtcclxuXHJcblBTS0J1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAoWyAuLi5wYXJhbXMgXSwgdG90YWxMZW5ndGgpIHtcclxuICAgIGNvbnN0IEFycmF5QnVmZmVySW50ZXJmYWNlID0gZ2V0QXJyYXlCdWZmZXJJbnRlcmZhY2UoKTtcclxuXHJcbiAgICBpZiAoIXRvdGFsTGVuZ3RoICYmIHRvdGFsTGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHBhcmFtcykge1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXJJbnRlcmZhY2UodG90YWxMZW5ndGgpKTtcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG5cclxuICAgIGZvciAoY29uc3QgYnVmIG9mIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XHJcblxyXG4gICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBvZmZzZXQgKyBsZW47XHJcbiAgICAgICAgaWYgKG5leHRPZmZzZXQgPiB0b3RhbExlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRvdGFsTGVuZ3RoIC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmluZ1NwYWNlOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGJ1ZltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoYnVmLCBvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59O1xyXG5cclxuUFNLQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKHBza0J1ZmZlcikge1xyXG4gICAgcmV0dXJuICEhQXJyYXlCdWZmZXIuaXNWaWV3KHBza0J1ZmZlcik7XHJcbn07XHJcblxyXG5QU0tCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbihzaXplKSB7XHJcbiAgICBjb25zdCBBcnJheUJ1ZmZlckludGVyZmFjZSA9IGdldEFycmF5QnVmZmVySW50ZXJmYWNlKCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlckludGVyZmFjZShzaXplKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBTS0J1ZmZlcjsiLCJjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgS2V5RW5jb2RlciA9IHJlcXVpcmUoJy4va2V5RW5jb2RlcicpO1xyXG5cclxuZnVuY3Rpb24gRUNEU0EoY3VydmVOYW1lKXtcclxuICAgIHRoaXMuY3VydmUgPSBjdXJ2ZU5hbWUgfHwgJ3NlY3AyNTZrMSc7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmdlbmVyYXRlS2V5UGFpciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCAgICAgPSB7fTtcclxuICAgICAgICBjb25zdCBlYyAgICAgICAgID0gY3J5cHRvLmNyZWF0ZUVDREgoc2VsZi5jdXJ2ZSk7XHJcbiAgICAgICAgcmVzdWx0LnB1YmxpYyAgPSBlYy5nZW5lcmF0ZUtleXMoJ2hleCcpO1xyXG4gICAgICAgIHJlc3VsdC5wcml2YXRlID0gZWMuZ2V0UHJpdmF0ZUtleSgnaGV4Jyk7XHJcbiAgICAgICAgcmV0dXJuIGtleXNUb1BFTShyZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBrZXlzVG9QRU0oa2V5cyl7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ICAgICAgICAgICAgICAgICAgPSB7fTtcclxuICAgICAgICBjb25zdCBFQ1ByaXZhdGVLZXlBU04gICAgICAgICA9IEtleUVuY29kZXIuRUNQcml2YXRlS2V5QVNOO1xyXG4gICAgICAgIGNvbnN0IFN1YmplY3RQdWJsaWNLZXlJbmZvQVNOID0gS2V5RW5jb2Rlci5TdWJqZWN0UHVibGljS2V5SW5mb0FTTjtcclxuICAgICAgICBjb25zdCBrZXlFbmNvZGVyICAgICAgICAgICAgICA9IG5ldyBLZXlFbmNvZGVyKHNlbGYuY3VydmUpO1xyXG5cclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5T2JqZWN0ICAgICAgICA9IGtleUVuY29kZXIucHJpdmF0ZUtleU9iamVjdChrZXlzLnByaXZhdGUsa2V5cy5wdWJsaWMpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleU9iamVjdCAgICAgICAgID0ga2V5RW5jb2Rlci5wdWJsaWNLZXlPYmplY3Qoa2V5cy5wdWJsaWMpO1xyXG5cclxuICAgICAgICByZXN1bHQucHJpdmF0ZSAgICAgICAgICAgICAgPSBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHByaXZhdGVLZXlPYmplY3QsICdwZW0nLCBwcml2YXRlS2V5T2JqZWN0LnBlbU9wdGlvbnMpO1xyXG4gICAgICAgIHJlc3VsdC5wdWJsaWMgICAgICAgICAgICAgICA9IFN1YmplY3RQdWJsaWNLZXlJbmZvQVNOLmVuY29kZShwdWJsaWNLZXlPYmplY3QsICdwZW0nLCBwdWJsaWNLZXlPYmplY3QucGVtT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2lnbiA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LGRpZ2VzdCkge1xyXG4gICAgICAgIGNvbnN0IHNpZ24gPSBjcnlwdG8uY3JlYXRlU2lnbihcInNoYTI1NlwiKTtcclxuICAgICAgICBzaWduLnVwZGF0ZShkaWdlc3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gc2lnbi5zaWduKHByaXZhdGVLZXksJ2hleCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksc2lnbmF0dXJlLGRpZ2VzdCkge1xyXG4gICAgICAgIGNvbnN0IHZlcmlmeSA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ3NoYTI1NicpO1xyXG4gICAgICAgIHZlcmlmeS51cGRhdGUoZGlnZXN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlcmlmeS52ZXJpZnkocHVibGljS2V5LHNpZ25hdHVyZSwnaGV4Jyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuY3JlYXRlRUNEU0EgPSBmdW5jdGlvbiAoY3VydmUpe1xyXG4gICAgcmV0dXJuIG5ldyBFQ0RTQShjdXJ2ZSk7XHJcbn07IiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG5cclxuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy9jcnlwdG9VdGlsc1wiKTtcclxuXHJcbmNvbnN0IFBhc3NUaHJvdWdoU3RyZWFtID0gcmVxdWlyZSgnLi91dGlscy9QYXNzVGhyb3VnaFN0cmVhbScpO1xyXG5cclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcbmNvbnN0IHRlbXBGb2xkZXIgPSBvcy50bXBkaXIoKTtcclxuXHJcbmZ1bmN0aW9uIFBza0NyeXB0bygpIHtcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgICB0aGlzLm9uID0gZXZlbnQub247XHJcbiAgICB0aGlzLm9mZiA9IGV2ZW50LnJlbW92ZUxpc3RlbmVyO1xyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBldmVudC5yZW1vdmVBbGxMaXN0ZW5lcnM7XHJcbiAgICB0aGlzLmVtaXQgPSBldmVudC5lbWl0O1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVDRFNBIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgY29uc3QgZWNkc2EgPSByZXF1aXJlKFwiLi9FQ0RTQVwiKS5jcmVhdGVFQ0RTQSgpO1xyXG4gICAgdGhpcy5nZW5lcmF0ZUVDRFNBS2V5UGFpciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZWNkc2EuZ2VuZXJhdGVLZXlQYWlyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2lnbiA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBkaWdlc3QpIHtcclxuICAgICAgICByZXR1cm4gZWNkc2Euc2lnbihwcml2YXRlS2V5LCBkaWdlc3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNpZ25hdHVyZSwgZGlnZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVjZHNhLnZlcmlmeShwdWJsaWNLZXksIHNpZ25hdHVyZSwgZGlnZXN0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FbmNyeXB0aW9uIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICB0aGlzLmVuY3J5cHRTdHJlYW0gPSBmdW5jdGlvbiAoaW5wdXRQYXRoLCBkZXN0aW5hdGlvblBhdGgsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IFBza0FyY2hpdmVyID0gcmVxdWlyZShcIi4vcHNrLWFyY2hpdmVyXCIpO1xyXG4gICAgICAgIGNvbnN0IGFyY2hpdmVyID0gbmV3IFBza0FyY2hpdmVyKCk7XHJcblxyXG4gICAgICAgIGFyY2hpdmVyLm9uKCdwcm9ncmVzcycsIChwcm9ncmVzcykgPT4ge1xyXG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgcHJvZ3Jlc3MpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmcy5vcGVuKGRlc3RpbmF0aW9uUGF0aCwgXCJ3eFwiLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdGluYXRpb25QYXRoLCB7YXV0b0Nsb3NlOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwga2V5U2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWFkU2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhYWQgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgYWFkU2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FsdCA9IEJ1ZmZlci5jb25jYXQoW2tleVNhbHQsIGFhZFNhbHRdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl2ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIHV0aWxzLml0ZXJhdGlvbnNfbnVtYmVyLCAxMiwgJ3NoYTUxMicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdih1dGlscy5hbGdvcml0aG0sIGtleSwgaXYpO1xyXG4gICAgICAgICAgICAgICAgY2lwaGVyLnNldEFBRChhYWQpO1xyXG4gICAgICAgICAgICAgICAgYXJjaGl2ZXIuemlwU3RyZWFtKGlucHV0UGF0aCwgY2lwaGVyLCBmdW5jdGlvbiAoZXJyLCBjaXBoZXJTdHJlYW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNpcGhlclN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdzLndyaXRlKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVRvQXBwZW5kID0gQnVmZmVyLmNvbmNhdChbc2FsdCwgdGFnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdzLmVuZChkYXRhVG9BcHBlbmQsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlY3J5cHRTdHJlYW0gPSBmdW5jdGlvbiAoZW5jcnlwdGVkSW5wdXRQYXRoLCBvdXRwdXRGb2xkZXIsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IFBza0FyY2hpdmVyID0gcmVxdWlyZShcIi4vcHNrLWFyY2hpdmVyXCIpO1xyXG4gICAgICAgIGNvbnN0IGFyY2hpdmVyID0gbmV3IFBza0FyY2hpdmVyKCk7XHJcblxyXG4gICAgICAgIGRlY3J5cHRGaWxlKGVuY3J5cHRlZElucHV0UGF0aCwgdGVtcEZvbGRlciwgcGFzc3dvcmQsIGZ1bmN0aW9uIChlcnIsIHRlbXBBcmNoaXZlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXJjaGl2ZXIub24oJ3Byb2dyZXNzJywgKHByb2dyZXNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgMTAgKyAwLjkgKiBwcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGFyY2hpdmVyLnVuemlwU3RyZWFtKHRlbXBBcmNoaXZlUGF0aCwgb3V0cHV0Rm9sZGVyLCBmdW5jdGlvbiAoZXJyLCB1bnppcHBlZEZpbGVOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGV0ZVJlY3Vyc2l2ZWx5KHRlbXBBcmNoaXZlUGF0aCwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHVuemlwcGVkRmlsZU5hbWVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lbmNyeXB0T2JqZWN0ID0gZnVuY3Rpb24gKGlucHV0T2JqLCBkc2VlZCwgZGVwdGgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgUHNrQXJjaGl2ZXIgPSByZXF1aXJlKFwiLi9wc2stYXJjaGl2ZXJcIik7XHJcbiAgICAgICAgY29uc3QgYXJjaGl2ZXIgPSBuZXcgUHNrQXJjaGl2ZXIoKTtcclxuXHJcbiAgICAgICAgYXJjaGl2ZXIuemlwSW5NZW1vcnkoaW5wdXRPYmosIGRlcHRoLCBmdW5jdGlvbiAoZXJyLCB6aXBwZWRPYmopIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2lwaGVyVGV4dCA9IHV0aWxzLmVuY3J5cHQoemlwcGVkT2JqLCBkc2VlZCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNpcGhlclRleHQpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVjcnlwdE9iamVjdCA9IGZ1bmN0aW9uIChlbmNyeXB0ZWREYXRhLCBkc2VlZCwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBQc2tBcmNoaXZlciA9IHJlcXVpcmUoXCIuL3Bzay1hcmNoaXZlclwiKTtcclxuICAgICAgICBjb25zdCBhcmNoaXZlciA9IG5ldyBQc2tBcmNoaXZlcigpO1xyXG5cclxuICAgICAgICBjb25zdCB6aXBwZWRPYmplY3QgPSB1dGlscy5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIGRzZWVkKTtcclxuICAgICAgICBhcmNoaXZlci51bnppcEluTWVtb3J5KHppcHBlZE9iamVjdCwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG9iaik7XHJcbiAgICAgICAgfSlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wc2tIYXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVQc2tIYXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY3JlYXRlUHNrSGFzaChKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVQc2tIYXNoKGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnBza0hhc2hTdHJlYW0gPSBmdW5jdGlvbiAocmVhZFN0cmVhbSwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBwc2tIYXNoID0gbmV3IHV0aWxzLlBza0hhc2goKTtcclxuXHJcbiAgICAgICAgcmVhZFN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICBwc2tIYXNoLnVwZGF0ZShjaHVuayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICByZWFkU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBza0hhc2guZGlnZXN0KCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB0aGlzLnNhdmVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHBhc3N3b3JkLCBwYXRoLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB0aGlzLmRlcml2ZUtleShwYXNzd29yZCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgaXYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpO1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdignYWVzLTI1Ni1jZmInLCBlbmNyeXB0aW9uS2V5LCBpdik7XHJcbiAgICAgICAgbGV0IGVuY3J5cHRlZERTZWVkID0gY2lwaGVyLnVwZGF0ZShkYXRhLCAnYmluYXJ5Jyk7XHJcbiAgICAgICAgY29uc3QgZmluYWwgPSBCdWZmZXIuZnJvbShjaXBoZXIuZmluYWwoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XHJcbiAgICAgICAgZW5jcnlwdGVkRFNlZWQgPSBCdWZmZXIuY29uY2F0KFtpdiwgZW5jcnlwdGVkRFNlZWQsIGZpbmFsXSk7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlKHBhdGgsIGVuY3J5cHRlZERTZWVkLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB0aGlzLmxvYWREYXRhID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBwYXRoLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICBmcy5yZWFkRmlsZShwYXRoLCBudWxsLCAoZXJyLCBlbmNyeXB0ZWREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdiA9IGVuY3J5cHRlZERhdGEuc2xpY2UoMCwgMTYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkRHNlZWQgPSBlbmNyeXB0ZWREYXRhLnNsaWNlKDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB0aGlzLmRlcml2ZUtleShwYXNzd29yZCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWNmYicsIGVuY3J5cHRpb25LZXksIGl2KTtcclxuICAgICAgICAgICAgICAgIGxldCBkc2VlZCA9IEJ1ZmZlci5mcm9tKGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWREc2VlZCwgJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbCA9IEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmZpbmFsKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xyXG4gICAgICAgICAgICAgICAgZHNlZWQgPSBCdWZmZXIuY29uY2F0KFtkc2VlZCwgZmluYWxdKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRzZWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdGhpcy5nZW5lcmF0ZVNhZmVVaWQgPSBmdW5jdGlvbiAocGFzc3dvcmQsIGFkZGl0aW9uYWxEYXRhKSB7XHJcbiAgICAgICAgcGFzc3dvcmQgPSBwYXNzd29yZCB8fCBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICAgICAgaWYgKCFhZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsRGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGFkZGl0aW9uYWxEYXRhKSkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsRGF0YSA9IEJ1ZmZlci5mcm9tKGFkZGl0aW9uYWxEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wc2tIYXNoKEJ1ZmZlci5jb25jYXQoW3Bhc3N3b3JkLCBhZGRpdGlvbmFsRGF0YV0pKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVyaXZlS2V5ID0gZnVuY3Rpb24gZGVyaXZlS2V5KHBhc3N3b3JkLCBpdGVyYXRpb25zLCBka0xlbikge1xyXG4gICAgICAgIGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDEwMDA7XHJcbiAgICAgICAgZGtMZW4gPSBka0xlbiB8fCAzMjtcclxuICAgICAgICBjb25zdCBzYWx0ID0gdXRpbHMuZ2VuZXJhdGVTYWx0KHBhc3N3b3JkLCAzMik7XHJcbiAgICAgICAgY29uc3QgZGsgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgZGtMZW4sICdzaGE1MTInKTtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGspO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJhbmRvbUJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzO1xyXG4gICAgdGhpcy5Qc2tIYXNoID0gdXRpbHMuUHNrSGFzaDtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gZGVjcnlwdEZpbGUoZW5jcnlwdGVkSW5wdXRQYXRoLCB0ZW1wRm9sZGVyLCBwYXNzd29yZCwgY2FsbGJhY2spIHtcclxuICAgICAgICBmcy5zdGF0KGVuY3J5cHRlZElucHV0UGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVTaXplSW5CeXRlcyA9IHN0YXRzLnNpemU7XHJcblxyXG4gICAgICAgICAgICBmcy5vcGVuKGVuY3J5cHRlZElucHV0UGF0aCwgXCJyXCIsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkQXV0aERhdGEgPSBCdWZmZXIuYWxsb2MoODApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmcy5yZWFkKGZkLCBlbmNyeXB0ZWRBdXRoRGF0YSwgMCwgODAsIGZpbGVTaXplSW5CeXRlcyAtIDgwLCBmdW5jdGlvbiAoZXJyLCBieXRlc1JlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FsdCA9IGVuY3J5cHRlZEF1dGhEYXRhLnNsaWNlKDAsIDY0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U2FsdCA9IHNhbHQuc2xpY2UoMCwgMzIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhYWRTYWx0ID0gc2FsdC5zbGljZSgtMzIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXYgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDEyLCAnc2hhNTEyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBrZXlTYWx0LCB1dGlscy5pdGVyYXRpb25zX251bWJlciwgMzIsICdzaGE1MTInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWFkID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIGFhZFNhbHQsIHV0aWxzLml0ZXJhdGlvbnNfbnVtYmVyLCAzMiwgJ3NoYTUxMicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBlbmNyeXB0ZWRBdXRoRGF0YS5zbGljZSgtMTYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdih1dGlscy5hbGdvcml0aG0sIGtleSwgaXYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaXBoZXIuc2V0QUFEKGFhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGVuY3J5cHRlZElucHV0UGF0aCwge3N0YXJ0OiAwLCBlbmQ6IGZpbGVTaXplSW5CeXRlcyAtIDgxfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLm1rZGlyKHRlbXBGb2xkZXIsIHtyZWN1cnNpdmU6IHRydWV9LCBmdW5jdGlvbiAoZXJyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEFyY2hpdmVQYXRoID0gcGF0aC5qb2luKHRlbXBGb2xkZXIsIHBhdGguYmFzZW5hbWUoZW5jcnlwdGVkSW5wdXRQYXRoKSArIFwiLnppcFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5vcGVuKHRlbXBBcmNoaXZlUGF0aCwgXCJ3XCIsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVycikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cyA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRlbXBBcmNoaXZlUGF0aCwge2F1dG9DbG9zZTogZmFsc2V9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3Mub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGVtcEFyY2hpdmVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUT0RPIHJldmlldyB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIGJyb3dzZXIsIHBpcGluZyB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIGFuZCB0aGUgc3RhY2sgcXVldWUgaXMgbm90IGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NMZW5ndGggPiAzMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFByb2dyZXNzKGZpbGVTaXplSW5CeXRlcywgdG90YWxMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnMucGlwZShkZWNpcGhlcikucGlwZShwdFN0cmVhbSkucGlwZSh3cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRQcm9ncmVzcyh0b3RhbCwgcHJvY2Vzc2VkKSB7XHJcblxyXG5cclxuICAgICAgICBpZiAocHJvY2Vzc2VkID4gdG90YWwpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkID0gdG90YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9ICgxMDAgKiBwcm9jZXNzZWQpIC8gdG90YWw7XHJcbiAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHBhcnNlSW50KHByb2dyZXNzKSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBQc2tDcnlwdG8oKTtcclxuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKTtcclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG5cclxudmFyIGFwaSA9IGV4cG9ydHM7XHJcblxyXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcclxuICByZXR1cm4gbmV3IEVudGl0eShuYW1lLCBib2R5KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEVudGl0eShuYW1lLCBib2R5KSB7XHJcbiAgdGhpcy5uYW1lID0gbmFtZTtcclxuICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cclxuICB0aGlzLmRlY29kZXJzID0ge307XHJcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xyXG59O1xyXG5cclxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XHJcbiAgdmFyIG5hbWVkO1xyXG4gIHRyeSB7XHJcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcclxuICAgICAgJyhmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJyhlbnRpdHkpIHtcXG4nICtcclxuICAgICAgJyAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSk7XFxuJyArXHJcbiAgICAgICd9KSdcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgaW5oZXJpdHMobmFtZWQsIGJhc2UpO1xyXG4gIG5hbWVkLnByb3RvdHlwZS5faW5pdE5hbWVkID0gZnVuY3Rpb24gaW5pdG5hbWVkKGVudGl0eSkge1xyXG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcclxufTtcclxuXHJcbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcclxuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcclxuICBpZiAoIXRoaXMuZGVjb2RlcnMuaGFzT3duUHJvcGVydHkoZW5jKSlcclxuICAgIHRoaXMuZGVjb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZGVjb2RlcnNbZW5jXSk7XHJcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcclxufTtcclxuXHJcbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xyXG4gIHJldHVybiB0aGlzLl9nZXREZWNvZGVyKGVuYykuZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuRW50aXR5LnByb3RvdHlwZS5fZ2V0RW5jb2RlciA9IGZ1bmN0aW9uIF9nZXRFbmNvZGVyKGVuYykge1xyXG4gIC8vIExhemlseSBjcmVhdGUgZW5jb2RlclxyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxyXG4gICAgdGhpcy5lbmNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5lbmNvZGVyc1tlbmNdKTtcclxuICByZXR1cm4gdGhpcy5lbmNvZGVyc1tlbmNdO1xyXG59O1xyXG5cclxuRW50aXR5LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgZW5jLCAvKiBpbnRlcm5hbCAqLyByZXBvcnRlcikge1xyXG4gIHJldHVybiB0aGlzLl9nZXRFbmNvZGVyKGVuYykuZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcclxufTtcclxuIiwidmFyIGFzbjEgPSBleHBvcnRzO1xyXG5cclxuYXNuMS5iaWdudW0gPSByZXF1aXJlKCcuL2JpZ251bS9ibicpO1xyXG5cclxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FwaScpLmRlZmluZTtcclxuYXNuMS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlL2luZGV4Jyk7XHJcbmFzbjEuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvaW5kZXgnKTtcclxuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vZGVjb2RlcnMvaW5kZXgnKTtcclxuYXNuMS5lbmNvZGVycyA9IHJlcXVpcmUoJy4vZW5jb2RlcnMvaW5kZXgnKTtcclxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcclxuICBSZXBvcnRlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJhc2UpKSB7XHJcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aGlzLmJhc2UgPSBiYXNlO1xyXG4gIHRoaXMub2Zmc2V0ID0gMDtcclxuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xyXG59XHJcbmluaGVyaXRzKERlY29kZXJCdWZmZXIsIFJlcG9ydGVyKTtcclxuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcclxuXHJcbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XHJcbn07XHJcblxyXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XHJcbiAgLy8gUmV0dXJuIHNraXBwZWQgZGF0YVxyXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xyXG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcclxuICByZXMubGVuZ3RoID0gdGhpcy5vZmZzZXQ7XHJcblxyXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XHJcbiAgUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUuY2FsbCh0aGlzLCBzYXZlLnJlcG9ydGVyKTtcclxuXHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xyXG4gIHJldHVybiB0aGlzLm9mZnNldCA9PT0gdGhpcy5sZW5ndGg7XHJcbn07XHJcblxyXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgoZmFpbCkge1xyXG4gIGlmICh0aGlzLm9mZnNldCArIDEgPD0gdGhpcy5sZW5ndGgpXHJcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcclxufVxyXG5cclxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoYnl0ZXMsIGZhaWwpIHtcclxuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcclxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xyXG5cclxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcclxuXHJcbiAgLy8gU2hhcmUgcmVwb3J0ZXIgc3RhdGVcclxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xyXG5cclxuICByZXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XHJcbiAgdGhpcy5vZmZzZXQgKz0gYnl0ZXM7XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gcmF3KHNhdmUpIHtcclxuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEVuY29kZXJCdWZmZXIpKVxyXG4gICAgICAgIGl0ZW0gPSBuZXcgRW5jb2RlckJ1ZmZlcihpdGVtLCByZXBvcnRlcik7XHJcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gaXRlbTtcclxuICAgIH0sIHRoaXMpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgaWYgKCEoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAweGZmKSlcclxuICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdub24tYnl0ZSBFbmNvZGVyQnVmZmVyIHZhbHVlJyk7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDE7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xyXG5cclxuRW5jb2RlckJ1ZmZlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ob3V0LCBvZmZzZXQpIHtcclxuICBpZiAoIW91dClcclxuICAgIG91dCA9IG5ldyBCdWZmZXIodGhpcy5sZW5ndGgpO1xyXG4gIGlmICghb2Zmc2V0KVxyXG4gICAgb2Zmc2V0ID0gMDtcclxuXHJcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxyXG4gICAgcmV0dXJuIG91dDtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcclxuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgIGl0ZW0uam9pbihvdXQsIG9mZnNldCk7XHJcbiAgICAgIG9mZnNldCArPSBpdGVtLmxlbmd0aDtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKVxyXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgIG91dC53cml0ZSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xyXG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxyXG4gICAgICB0aGlzLnZhbHVlLmNvcHkob3V0LCBvZmZzZXQpO1xyXG4gICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG91dDtcclxufTtcclxuIiwidmFyIGJhc2UgPSBleHBvcnRzO1xyXG5cclxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcclxuYmFzZS5EZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKS5EZWNvZGVyQnVmZmVyO1xyXG5iYXNlLkVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkVuY29kZXJCdWZmZXI7XHJcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xyXG4iLCJ2YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XHJcbnZhciBFbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkVuY29kZXJCdWZmZXI7XHJcbi8vdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2RvdWJsZS1jaGVjaycpLmFzc2VydDtcclxuXHJcbi8vIFN1cHBvcnRlZCB0YWdzXHJcbnZhciB0YWdzID0gW1xyXG4gICdzZXEnLCAnc2Vxb2YnLCAnc2V0JywgJ3NldG9mJywgJ29jdHN0cicsICdiaXRzdHInLCAnb2JqaWQnLCAnYm9vbCcsXHJcbiAgJ2dlbnRpbWUnLCAndXRjdGltZScsICdudWxsXycsICdlbnVtJywgJ2ludCcsICdpYTVzdHInLCAndXRmOHN0cidcclxuXTtcclxuXHJcbi8vIFB1YmxpYyBtZXRob2RzIGxpc3RcclxudmFyIG1ldGhvZHMgPSBbXHJcbiAgJ2tleScsICdvYmonLCAndXNlJywgJ29wdGlvbmFsJywgJ2V4cGxpY2l0JywgJ2ltcGxpY2l0JywgJ2RlZicsICdjaG9pY2UnLFxyXG4gICdhbnknXHJcbl0uY29uY2F0KHRhZ3MpO1xyXG5cclxuLy8gT3ZlcnJpZGVkIG1ldGhvZHMgbGlzdFxyXG52YXIgb3ZlcnJpZGVkID0gW1xyXG4gICdfcGVla1RhZycsICdfZGVjb2RlVGFnJywgJ191c2UnLFxyXG4gICdfZGVjb2RlU3RyJywgJ19kZWNvZGVPYmppZCcsICdfZGVjb2RlVGltZScsXHJcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxyXG5cclxuICAnX2VuY29kZUNvbXBvc2l0ZScsICdfZW5jb2RlU3RyJywgJ19lbmNvZGVPYmppZCcsICdfZW5jb2RlVGltZScsXHJcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXHJcbl07XHJcblxyXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XHJcbiAgdmFyIHN0YXRlID0ge307XHJcbiAgdGhpcy5fYmFzZVN0YXRlID0gc3RhdGU7XHJcblxyXG4gIHN0YXRlLmVuYyA9IGVuYztcclxuXHJcbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XHJcbiAgc3RhdGUuY2hpbGRyZW4gPSBudWxsO1xyXG5cclxuICAvLyBTdGF0ZVxyXG4gIHN0YXRlLnRhZyA9IG51bGw7XHJcbiAgc3RhdGUuYXJncyA9IG51bGw7XHJcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xyXG4gIHN0YXRlLmNob2ljZSA9IG51bGw7XHJcbiAgc3RhdGUub3B0aW9uYWwgPSBmYWxzZTtcclxuICBzdGF0ZS5hbnkgPSBmYWxzZTtcclxuICBzdGF0ZS5vYmogPSBmYWxzZTtcclxuICBzdGF0ZS51c2UgPSBudWxsO1xyXG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xyXG4gIHN0YXRlLmtleSA9IG51bGw7XHJcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IG51bGw7XHJcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xyXG4gIHN0YXRlLmltcGxpY2l0ID0gbnVsbDtcclxuXHJcbiAgLy8gU2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb24gZWFjaCBtZXRob2RcclxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xyXG4gICAgc3RhdGUuY2hpbGRyZW4gPSBbXTtcclxuICAgIHRoaXMuX3dyYXAoKTtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxudmFyIHN0YXRlUHJvcHMgPSBbXHJcbiAgJ2VuYycsICdwYXJlbnQnLCAnY2hpbGRyZW4nLCAndGFnJywgJ2FyZ3MnLCAncmV2ZXJzZUFyZ3MnLCAnY2hvaWNlJyxcclxuICAnb3B0aW9uYWwnLCAnYW55JywgJ29iaicsICd1c2UnLCAnYWx0ZXJlZFVzZScsICdrZXknLCAnZGVmYXVsdCcsICdleHBsaWNpdCcsXHJcbiAgJ2ltcGxpY2l0J1xyXG5dO1xyXG5cclxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcbiAgdmFyIGNzdGF0ZSA9IHt9O1xyXG4gIHN0YXRlUHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcbiAgICBjc3RhdGVbcHJvcF0gPSBzdGF0ZVtwcm9wXTtcclxuICB9KTtcclxuICB2YXIgcmVzID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY3N0YXRlLnBhcmVudCk7XHJcbiAgcmVzLl9iYXNlU3RhdGUgPSBjc3RhdGU7XHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gd3JhcCgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gX3dyYXBwZWRNZXRob2QoKSB7XHJcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNsb25lKTtcclxuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0sIHRoaXMpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGJvZHkpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcblxyXG4gIC8vYXNzZXJ0LmVxdWFsKHN0YXRlLnBhcmVudCxudWxsLCdzdGF0ZS5wYXJlbnQgc2hvdWxkIGJlIG51bGwnKTtcclxuICBib2R5LmNhbGwodGhpcyk7XHJcblxyXG4gIC8vIEZpbHRlciBjaGlsZHJlblxyXG4gIHN0YXRlLmNoaWxkcmVuID0gc3RhdGUuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICByZXR1cm4gY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IHRoaXM7XHJcbiAgfSwgdGhpcyk7XHJcbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmNoaWxkcmVuLmxlbmd0aCwgMSwgJ1Jvb3Qgbm9kZSBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZCcpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX3VzZUFyZ3MgPSBmdW5jdGlvbiB1c2VBcmdzKGFyZ3MpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcblxyXG4gIC8vIEZpbHRlciBjaGlsZHJlbiBhbmQgYXJnc1xyXG4gIHZhciBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I7XHJcbiAgfSwgdGhpcyk7XHJcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuICEoYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcclxuICAgIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbiwgbnVsbCwgJ3N0YXRlLmNoaWxkcmVuIHNob3VsZCBiZSBudWxsJyk7XHJcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG5cclxuICAgIC8vIFJlcGxhY2UgcGFyZW50IHRvIG1haW50YWluIGJhY2t3YXJkIGxpbmtcclxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgfVxyXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmFyZ3MsIG51bGwsICdzdGF0ZS5hcmdzIHNob3VsZCBiZSBudWxsJyk7XHJcbiAgICBzdGF0ZS5hcmdzID0gYXJncztcclxuICAgIHN0YXRlLnJldmVyc2VBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcclxuICAgICAgICByZXR1cm4gYXJnO1xyXG5cclxuICAgICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PSAoa2V5IHwgMCkpXHJcbiAgICAgICAgICBrZXkgfD0gMDtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcmdba2V5XTtcclxuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vXHJcbi8vIE92ZXJyaWRlZCBtZXRob2RzXHJcbi8vXHJcblxyXG5vdmVycmlkZWQuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcclxuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcclxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIG5vdCBpbXBsZW1lbnRlZCBmb3IgZW5jb2Rpbmc6ICcgKyBzdGF0ZS5lbmMpO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLy9cclxuLy8gUHVibGljIG1ldGhvZHNcclxuLy9cclxuXHJcbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcclxuICBOb2RlLnByb3RvdHlwZVt0YWddID0gZnVuY3Rpb24gX3RhZ01ldGhvZCgpIHtcclxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHJcbiAgICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUudGFnLCBudWxsLCAnc3RhdGUudGFnIHNob3VsZCBiZSBudWxsJyk7XHJcbiAgICBzdGF0ZS50YWcgPSB0YWc7XHJcblxyXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG59KTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShpdGVtKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUudXNlLCBudWxsLCAnc3RhdGUudXNlIHNob3VsZCBiZSBudWxsJyk7XHJcbiAgc3RhdGUudXNlID0gaXRlbTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5vcHRpb25hbCA9IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuXHJcbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmRlZiA9IGZ1bmN0aW9uIGRlZih2YWwpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcblxyXG4gIC8vIGFzc2VydC5lcXVhbChzdGF0ZVsnZGVmYXVsdCddLCBudWxsLCBcInN0YXRlWydkZWZhdWx0J10gc2hvdWxkIGJlIG51bGxcIik7XHJcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IHZhbDtcclxuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZXhwbGljaXQgPSBmdW5jdGlvbiBleHBsaWNpdChudW0pIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcblxyXG4gIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5leHBsaWNpdCxudWxsLCAnc3RhdGUuZXhwbGljaXQgc2hvdWxkIGJlIG51bGwnKTtcclxuICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUuaW1wbGljaXQsbnVsbCwgJ3N0YXRlLmltcGxpY2l0IHNob3VsZCBiZSBudWxsJyk7XHJcblxyXG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVtO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICAgIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5leHBsaWNpdCxudWxsLCAnc3RhdGUuZXhwbGljaXQgc2hvdWxkIGJlIG51bGwnKTtcclxuICAgIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5pbXBsaWNpdCxudWxsLCAnc3RhdGUuaW1wbGljaXQgc2hvdWxkIGJlIG51bGwnKTtcclxuXHJcbiAgICBzdGF0ZS5pbXBsaWNpdCA9IG51bTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5vYmogPSBmdW5jdGlvbiBvYmooKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHJcbiAgc3RhdGUub2JqID0gdHJ1ZTtcclxuXHJcbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKVxyXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiBrZXkobmV3S2V5KSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUua2V5LCBudWxsLCAnc3RhdGUua2V5IHNob3VsZCBiZSBudWxsJyk7XHJcbiAgc3RhdGUua2V5ID0gbmV3S2V5O1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcblxyXG4gIHN0YXRlLmFueSA9IHRydWU7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuXHJcbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmNob2ljZSwgbnVsbCwnc3RhdGUuY2hvaWNlIHNob3VsZCBiZSBudWxsJyk7XHJcbiAgc3RhdGUuY2hvaWNlID0gb2JqO1xyXG4gIHRoaXMuX3VzZUFyZ3MoT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgfSkpO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vXHJcbi8vIERlY29kaW5nXHJcbi8vXHJcblxyXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICAvLyBEZWNvZGUgcm9vdCBub2RlXHJcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcclxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQpKTtcclxuXHJcbiAgdmFyIHJlc3VsdCA9IHN0YXRlWydkZWZhdWx0J107XHJcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xyXG5cclxuICB2YXIgcHJldktleTtcclxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsKVxyXG4gICAgcHJldktleSA9IGlucHV0LmVudGVyS2V5KHN0YXRlLmtleSk7XHJcblxyXG4gIC8vIENoZWNrIGlmIHRhZyBpcyB0aGVyZVxyXG4gIGlmIChzdGF0ZS5vcHRpb25hbCkge1xyXG4gICAgdmFyIHRhZyA9IG51bGw7XHJcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXHJcbiAgICAgIHRhZyA9IHN0YXRlLmV4cGxpY2l0O1xyXG4gICAgZWxzZSBpZiAoc3RhdGUuaW1wbGljaXQgIT09IG51bGwpXHJcbiAgICAgIHRhZyA9IHN0YXRlLmltcGxpY2l0O1xyXG4gICAgZWxzZSBpZiAoc3RhdGUudGFnICE9PSBudWxsKVxyXG4gICAgICB0YWcgPSBzdGF0ZS50YWc7XHJcblxyXG4gICAgaWYgKHRhZyA9PT0gbnVsbCAmJiAhc3RhdGUuYW55KSB7XHJcbiAgICAgIC8vIFRyaWFsIGFuZCBFcnJvclxyXG4gICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxyXG4gICAgICAgICAgdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQpO1xyXG4gICAgICAgIHByZXNlbnQgPSB0cnVlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcmVzZW50ID0gdGhpcy5fcGVla1RhZyhpbnB1dCwgdGFnLCBzdGF0ZS5hbnkpO1xyXG5cclxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXHJcbiAgICAgICAgcmV0dXJuIHByZXNlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdXNoIG9iamVjdCBvbiBzdGFja1xyXG4gIHZhciBwcmV2T2JqO1xyXG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcclxuICAgIHByZXZPYmogPSBpbnB1dC5lbnRlck9iamVjdCgpO1xyXG5cclxuICBpZiAocHJlc2VudCkge1xyXG4gICAgLy8gVW53cmFwIGV4cGxpY2l0IHZhbHVlc1xyXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XHJcbiAgICAgIHZhciBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xyXG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihleHBsaWNpdCkpXHJcbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0O1xyXG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVud3JhcCBpbXBsaWNpdCBhbmQgbm9ybWFsIHZhbHVlc1xyXG4gICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcclxuICAgICAgaWYgKHN0YXRlLmFueSlcclxuICAgICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcclxuICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kZWNvZGVUYWcoXHJcbiAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZyxcclxuICAgICAgICBzdGF0ZS5hbnlcclxuICAgICAgKTtcclxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoYm9keSkpXHJcbiAgICAgICAgcmV0dXJuIGJvZHk7XHJcblxyXG4gICAgICBpZiAoc3RhdGUuYW55KVxyXG4gICAgICAgIHJlc3VsdCA9IGlucHV0LnJhdyhzYXZlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGlucHV0ID0gYm9keTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXHJcbiAgICBpZiAoc3RhdGUuYW55KVxyXG4gICAgICByZXN1bHQgPSByZXN1bHQ7XHJcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCk7XHJcblxyXG4gICAgaWYgKGlucHV0LmlzRXJyb3IocmVzdWx0KSlcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAvLyBEZWNvZGUgY2hpbGRyZW5cclxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xyXG4gICAgICB2YXIgZmFpbCA9IHN0YXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gZGVjb2RlQ2hpbGRyZW4oY2hpbGQpIHtcclxuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgaWdub3JpbmcgZXJyb3JzIGhlcmUsIHRvIGxldCBwYXJzZXIgY29udGludWUgd2l0aCBvdGhlclxyXG4gICAgICAgIC8vIHBhcnRzIG9mIGVuY29kZWQgZGF0YVxyXG4gICAgICAgIGNoaWxkLl9kZWNvZGUoaW5wdXQpO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGZhaWwpXHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFBvcCBvYmplY3RcclxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXHJcbiAgICByZXN1bHQgPSBpbnB1dC5sZWF2ZU9iamVjdChwcmV2T2JqKTtcclxuXHJcbiAgLy8gU2V0IGtleVxyXG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCBwcmVzZW50ID09PSB0cnVlKSlcclxuICAgIGlucHV0LmxlYXZlS2V5KHByZXZLZXksIHN0YXRlLmtleSwgcmVzdWx0KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLl9kZWNvZGVHZW5lcmljID0gZnVuY3Rpb24gZGVjb2RlR2VuZXJpYyh0YWcsIGlucHV0KSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICBpZiAodGFnID09PSAnc2VxJyB8fCB0YWcgPT09ICdzZXQnKVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJyB8fCB0YWcgPT09ICdzZXRvZicpXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTGlzdChpbnB1dCwgdGFnLCBzdGF0ZS5hcmdzWzBdKTtcclxuICBlbHNlIGlmICh0YWcgPT09ICdvY3RzdHInIHx8IHRhZyA9PT0gJ2JpdHN0cicpXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcpO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2lhNXN0cicgfHwgdGFnID09PSAndXRmOHN0cicpXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcpO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBzdGF0ZS5hcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcclxuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwpO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVRpbWUoaW5wdXQsIHRhZyk7XHJcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU51bGwoaW5wdXQpO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQpO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlSW50KGlucHV0LCBzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3NbMF0pO1xyXG4gIGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbClcclxuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopLl9kZWNvZGUoaW5wdXQpO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBpbnB1dC5lcnJvcigndW5rbm93biB0YWc6ICcgKyB0YWcpO1xyXG5cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLl9nZXRVc2UgPSBmdW5jdGlvbiBfZ2V0VXNlKGVudGl0eSwgb2JqKSB7XHJcblxyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuICAvLyBDcmVhdGUgYWx0ZXJlZCB1c2UgZGVjb2RlciBpZiBpbXBsaWNpdCBpcyBzZXRcclxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcclxuICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLnBhcmVudCwgbnVsbCwgJ3N0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgc2hvdWxkIGJlIG51bGwnKTtcclxuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xyXG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XHJcbiAgICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5jbG9uZSgpO1xyXG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZS51c2VEZWNvZGVyO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUNob2ljZSA9IGZ1bmN0aW9uIGRlY29kZUNob2ljZShpbnB1dCkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICB2YXIgbWF0Y2ggPSBmYWxzZTtcclxuXHJcbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XHJcbiAgICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIHZhbHVlID0gbm9kZS5fZGVjb2RlKGlucHV0KTtcclxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IodmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIHJlc3VsdCA9IHsgdHlwZToga2V5LCB2YWx1ZTogdmFsdWUgfTtcclxuICAgICAgbWF0Y2ggPSB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgaWYgKCFtYXRjaClcclxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vL1xyXG4vLyBFbmNvZGluZ1xyXG4vL1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IEVuY29kZXJCdWZmZXIoZGF0YSwgdGhpcy5yZXBvcnRlcik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XHJcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcclxuICAgIHJldHVybjtcclxuXHJcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xyXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybjtcclxuXHJcbiAgaWYgKHRoaXMuX3NraXBEZWZhdWx0KHJlc3VsdCwgcmVwb3J0ZXIsIHBhcmVudCkpXHJcbiAgICByZXR1cm47XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuXHJcbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxyXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXHJcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XHJcblxyXG4gIHZhciByZXN1bHQgPSBudWxsO1xyXG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcclxuXHJcbiAgLy8gU2V0IHJlcG9ydGVyIHRvIHNoYXJlIGl0IHdpdGggYSBjaGlsZCBjbGFzc1xyXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcclxuXHJcbiAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB0aGVyZVxyXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsKVxyXG4gICAgICBkYXRhID0gc3RhdGVbJ2RlZmF1bHQnXVxyXG4gICAgZWxzZVxyXG4gICAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nXHJcbiAgdmFyIHByZXZLZXk7XHJcblxyXG4gIC8vIEVuY29kZSBjaGlsZHJlbiBmaXJzdFxyXG4gIHZhciBjb250ZW50ID0gbnVsbDtcclxuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XHJcbiAgaWYgKHN0YXRlLmFueSkge1xyXG4gICAgLy8gQW55dGhpbmcgdGhhdCB3YXMgZ2l2ZW4gaXMgdHJhbnNsYXRlZCB0byBidWZmZXJcclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaG9pY2UpIHtcclxuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcik7XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xyXG4gICAgY29udGVudCA9IHN0YXRlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS50YWcgPT09ICdudWxsXycpXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xyXG5cclxuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUua2V5ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcclxuICAgICAgdmFyIHByZXZLZXkgPSByZXBvcnRlci5lbnRlcktleShjaGlsZC5fYmFzZVN0YXRlLmtleSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxyXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgZXhwZWN0ZWQsIGJ1dCBpbnB1dCBpcyBub3Qgb2JqZWN0Jyk7XHJcblxyXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xyXG4gICAgICByZXBvcnRlci5sZWF2ZUtleShwcmV2S2V5KTtcclxuXHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoY29udGVudCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChzdGF0ZS50YWcgPT09ICdzZXFvZicgfHwgc3RhdGUudGFnID09PSAnc2V0b2YnKSB7XHJcbiAgICAgIC8vIFRPRE8oaW5kdXRueSk6IHRoaXMgc2hvdWxkIGJlIHRocm93biBvbiBEU0wgbGV2ZWxcclxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXHJcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdUb28gbWFueSBhcmdzIGZvciA6ICcgKyBzdGF0ZS50YWcpO1xyXG5cclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignc2Vxb2Yvc2V0b2YsIGJ1dCBkYXRhIGlzIG5vdCBBcnJheScpO1xyXG5cclxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLmltcGxpY2l0ID0gbnVsbDtcclxuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS5hcmdzWzBdLCBkYXRhKS5fZW5jb2RlKGl0ZW0sIHJlcG9ydGVyKTtcclxuICAgICAgfSwgY2hpbGQpKTtcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUudXNlICE9PSBudWxsKSB7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZW50ID0gdGhpcy5fZW5jb2RlUHJpbWl0aXZlKHN0YXRlLnRhZywgZGF0YSk7XHJcbiAgICAgIHByaW1pdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcclxuICB2YXIgcmVzdWx0O1xyXG4gIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xyXG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XHJcbiAgICB2YXIgY2xzID0gc3RhdGUuaW1wbGljaXQgPT09IG51bGwgPyAndW5pdmVyc2FsJyA6ICdjb250ZXh0JztcclxuXHJcbiAgICBpZiAodGFnID09PSBudWxsKSB7XHJcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXHJcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbW1pdGVkIG9ubHkgZm9yIC51c2UoKScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcclxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBXcmFwIGluIGV4cGxpY2l0XHJcbiAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxyXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX2VuY29kZUNob2ljZSA9IGZ1bmN0aW9uIGVuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcikge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuXHJcbiAgdmFyIG5vZGUgPSBzdGF0ZS5jaG9pY2VbZGF0YS50eXBlXTtcclxuICAvLyBpZiAoIW5vZGUpIHtcclxuICAvLyAgIGFzc2VydChcclxuICAvLyAgICAgICBmYWxzZSxcclxuICAvLyAgICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcclxuICAvLyAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xyXG4gIC8vIH1cclxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xyXG5cclxuICBpZiAodGFnID09PSAnb2N0c3RyJyB8fCB0YWcgPT09ICdiaXRzdHInIHx8IHRhZyA9PT0gJ2lhNXN0cicpXHJcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XHJcbiAgZWxzZSBpZiAodGFnID09PSAndXRmOHN0cicpXHJcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XHJcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXHJcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgc3RhdGUucmV2ZXJzZUFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0pO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcclxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcclxuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcclxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVUaW1lKGRhdGEsIHRhZyk7XHJcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxyXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU51bGwoKTtcclxuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxyXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcclxuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcclxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVCb29sKGRhdGEpO1xyXG4gIGVsc2VcclxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdGFnOiAnICsgdGFnKTtcclxufTtcclxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG5cclxuZnVuY3Rpb24gUmVwb3J0ZXIob3B0aW9ucykge1xyXG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XHJcbiAgICBvYmo6IG51bGwsXHJcbiAgICBwYXRoOiBbXSxcclxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXHJcbiAgICBlcnJvcnM6IFtdXHJcbiAgfTtcclxufVxyXG5leHBvcnRzLlJlcG9ydGVyID0gUmVwb3J0ZXI7XHJcblxyXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XHJcbn07XHJcblxyXG5SZXBvcnRlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcclxuXHJcbiAgcmV0dXJuIHsgb2JqOiBzdGF0ZS5vYmosIHBhdGhMZW46IHN0YXRlLnBhdGgubGVuZ3RoIH07XHJcbn07XHJcblxyXG5SZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZGF0YSkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XHJcblxyXG4gIHN0YXRlLm9iaiA9IGRhdGEub2JqO1xyXG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XHJcbn07XHJcblxyXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcclxuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLnB1c2goa2V5KTtcclxufTtcclxuXHJcblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZUtleSA9IGZ1bmN0aW9uIGxlYXZlS2V5KGluZGV4LCBrZXksIHZhbHVlKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcclxuXHJcbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgaW5kZXggLSAxKTtcclxuICBpZiAoc3RhdGUub2JqICE9PSBudWxsKVxyXG4gICAgc3RhdGUub2JqW2tleV0gPSB2YWx1ZTtcclxufTtcclxuXHJcblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlck9iamVjdCA9IGZ1bmN0aW9uIGVudGVyT2JqZWN0KCkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XHJcblxyXG4gIHZhciBwcmV2ID0gc3RhdGUub2JqO1xyXG4gIHN0YXRlLm9iaiA9IHt9O1xyXG4gIHJldHVybiBwcmV2O1xyXG59O1xyXG5cclxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlT2JqZWN0ID0gZnVuY3Rpb24gbGVhdmVPYmplY3QocHJldikge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XHJcblxyXG4gIHZhciBub3cgPSBzdGF0ZS5vYmo7XHJcbiAgc3RhdGUub2JqID0gcHJldjtcclxuICByZXR1cm4gbm93O1xyXG59O1xyXG5cclxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XHJcbiAgdmFyIGVycjtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xyXG5cclxuICB2YXIgaW5oZXJpdGVkID0gbXNnIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcclxuICBpZiAoaW5oZXJpdGVkKSB7XHJcbiAgICBlcnIgPSBtc2c7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVyciA9IG5ldyBSZXBvcnRlckVycm9yKHN0YXRlLnBhdGgubWFwKGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xyXG4gICAgfSkuam9pbignJyksIG1zZy5tZXNzYWdlIHx8IG1zZywgbXNnLnN0YWNrKTtcclxuICB9XHJcblxyXG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxyXG4gICAgdGhyb3cgZXJyO1xyXG5cclxuICBpZiAoIWluaGVyaXRlZClcclxuICAgIHN0YXRlLmVycm9ycy5wdXNoKGVycik7XHJcblxyXG4gIHJldHVybiBlcnI7XHJcbn07XHJcblxyXG5SZXBvcnRlci5wcm90b3R5cGUud3JhcFJlc3VsdCA9IGZ1bmN0aW9uIHdyYXBSZXN1bHQocmVzdWx0KSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcclxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcclxuICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZXN1bHQ6IHRoaXMuaXNFcnJvcihyZXN1bHQpID8gbnVsbCA6IHJlc3VsdCxcclxuICAgIGVycm9yczogc3RhdGUuZXJyb3JzXHJcbiAgfTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XHJcbiAgdGhpcy5wYXRoID0gcGF0aDtcclxuICB0aGlzLnJldGhyb3cobXNnKTtcclxufTtcclxuaW5oZXJpdHMoUmVwb3J0ZXJFcnJvciwgRXJyb3IpO1xyXG5cclxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XHJcbiAgdGhpcy5tZXNzYWdlID0gbXNnICsgJyBhdDogJyArICh0aGlzLnBhdGggfHwgJyhzaGFsbG93KScpO1xyXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcG9ydGVyRXJyb3IpO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFV0aWxzXHJcblxyXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcclxuICBpZiAoIXZhbClcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcclxufVxyXG5cclxuLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcclxuLy8gYXJjaGl0ZWN0dXJlIHlldC5cclxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XHJcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XHJcbiAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XHJcbiAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcclxuICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xyXG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcclxufVxyXG5cclxuLy8gQk5cclxuXHJcbmZ1bmN0aW9uIEJOKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XHJcbiAgLy8gTWF5IGJlIGBuZXcgQk4oYm4pYCA/XHJcbiAgaWYgKG51bWJlciAhPT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICBBcnJheS5pc0FycmF5KG51bWJlci53b3JkcykpIHtcclxuICAgIHJldHVybiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICB0aGlzLnNpZ24gPSBmYWxzZTtcclxuICB0aGlzLndvcmRzID0gbnVsbDtcclxuICB0aGlzLmxlbmd0aCA9IDA7XHJcblxyXG4gIC8vIFJlZHVjdGlvbiBjb250ZXh0XHJcbiAgdGhpcy5yZWQgPSBudWxsO1xyXG5cclxuICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XHJcbiAgICBlbmRpYW4gPSBiYXNlO1xyXG4gICAgYmFzZSA9IDEwO1xyXG4gIH1cclxuXHJcbiAgaWYgKG51bWJlciAhPT0gbnVsbClcclxuICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcclxufVxyXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcclxuZWxzZVxyXG4gIGV4cG9ydHMuQk4gPSBCTjtcclxuXHJcbkJOLkJOID0gQk47XHJcbkJOLndvcmRTaXplID0gMjY7XHJcblxyXG5CTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XHJcbiAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XHJcbiAgfVxyXG4gIGlmIChiYXNlID09PSAnaGV4JylcclxuICAgIGJhc2UgPSAxNjtcclxuICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XHJcblxyXG4gIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xyXG4gIHZhciBzdGFydCA9IDA7XHJcbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxyXG4gICAgc3RhcnQrKztcclxuXHJcbiAgaWYgKGJhc2UgPT09IDE2KVxyXG4gICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XHJcbiAgZWxzZVxyXG4gICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xyXG5cclxuICBpZiAobnVtYmVyWzBdID09PSAnLScpXHJcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xyXG5cclxuICB0aGlzLnN0cmlwKCk7XHJcblxyXG4gIGlmIChlbmRpYW4gIT09ICdsZScpXHJcbiAgICByZXR1cm47XHJcblxyXG4gIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XHJcbiAgaWYgKG51bWJlciA8IDApIHtcclxuICAgIHRoaXMuc2lnbiA9IHRydWU7XHJcbiAgICBudW1iZXIgPSAtbnVtYmVyO1xyXG4gIH1cclxuICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XHJcbiAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcclxuICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcclxuICAgIHRoaXMud29yZHMgPSBbXHJcbiAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcclxuICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcclxuICAgIF07XHJcbiAgICB0aGlzLmxlbmd0aCA9IDI7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXHJcbiAgICB0aGlzLndvcmRzID0gW1xyXG4gICAgICBudW1iZXIgJiAweDNmZmZmZmYsXHJcbiAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxyXG4gICAgICAxXHJcbiAgICBdO1xyXG4gICAgdGhpcy5sZW5ndGggPSAzO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZGlhbiAhPT0gJ2xlJylcclxuICAgIHJldHVybjtcclxuXHJcbiAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcclxuICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcclxuICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxyXG4gIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xyXG4gIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcclxuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcclxuICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xyXG4gIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xyXG5cclxuICB2YXIgb2ZmID0gMDtcclxuICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XHJcbiAgICBmb3IgKHZhciBpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xyXG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xyXG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XHJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xyXG4gICAgICBvZmYgKz0gMjQ7XHJcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcclxuICAgICAgICBvZmYgLT0gMjY7XHJcbiAgICAgICAgaisrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xyXG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XHJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xyXG4gICAgICBvZmYgKz0gMjQ7XHJcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcclxuICAgICAgICBvZmYgLT0gMjY7XHJcbiAgICAgICAgaisrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZUhleChzdHIsIHN0YXJ0LCBlbmQpIHtcclxuICB2YXIgciA9IDA7XHJcbiAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcclxuXHJcbiAgICByIDw8PSA0O1xyXG5cclxuICAgIC8vICdhJyAtICdmJ1xyXG4gICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NClcclxuICAgICAgciB8PSBjIC0gNDkgKyAweGE7XHJcblxyXG4gICAgLy8gJ0EnIC0gJ0YnXHJcbiAgICBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpXHJcbiAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xyXG5cclxuICAgIC8vICcwJyAtICc5J1xyXG4gICAgZWxzZVxyXG4gICAgICByIHw9IGMgJiAweGY7XHJcbiAgfVxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5CTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpIHtcclxuICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxyXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XHJcbiAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgdGhpcy53b3Jkc1tpXSA9IDA7XHJcblxyXG4gIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxyXG4gIHZhciBvZmYgPSAwO1xyXG4gIGZvciAodmFyIGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xyXG4gICAgdmFyIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcclxuICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcclxuICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcclxuICAgIG9mZiArPSAyNDtcclxuICAgIGlmIChvZmYgPj0gMjYpIHtcclxuICAgICAgb2ZmIC09IDI2O1xyXG4gICAgICBqKys7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcclxuICAgIHZhciB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xyXG4gICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xyXG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xyXG4gIH1cclxuICB0aGlzLnN0cmlwKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZUJhc2Uoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcclxuICB2YXIgciA9IDA7XHJcbiAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcclxuXHJcbiAgICByICo9IG11bDtcclxuXHJcbiAgICAvLyAnYSdcclxuICAgIGlmIChjID49IDQ5KVxyXG4gICAgICByICs9IGMgLSA0OSArIDB4YTtcclxuXHJcbiAgICAvLyAnQSdcclxuICAgIGVsc2UgaWYgKGMgPj0gMTcpXHJcbiAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xyXG5cclxuICAgIC8vICcwJyAtICc5J1xyXG4gICAgZWxzZVxyXG4gICAgICByICs9IGM7XHJcbiAgfVxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5CTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCkge1xyXG4gIC8vIEluaXRpYWxpemUgYXMgemVyb1xyXG4gIHRoaXMud29yZHMgPSBbIDAgXTtcclxuICB0aGlzLmxlbmd0aCA9IDE7XHJcblxyXG4gIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxyXG4gIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSlcclxuICAgIGxpbWJMZW4rKztcclxuICBsaW1iTGVuLS07XHJcbiAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xyXG5cclxuICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XHJcbiAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcclxuICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xyXG5cclxuICB2YXIgd29yZCA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcclxuICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XHJcblxyXG4gICAgdGhpcy5pbXVsbihsaW1iUG93KTtcclxuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcclxuICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcclxuICB9XHJcblxyXG4gIGlmIChtb2QgIT09IDApIHtcclxuICAgIHZhciBwb3cgPSAxO1xyXG4gICAgdmFyIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZDsgaSsrKVxyXG4gICAgICBwb3cgKj0gYmFzZTtcclxuICAgIHRoaXMuaW11bG4ocG93KTtcclxuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcclxuICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcclxuICB9XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkoZGVzdCkge1xyXG4gIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xyXG4gIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XHJcbiAgZGVzdC5zaWduID0gdGhpcy5zaWduO1xyXG4gIGRlc3QucmVkID0gdGhpcy5yZWQ7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICB2YXIgciA9IG5ldyBCTihudWxsKTtcclxuICB0aGlzLmNvcHkocik7XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG4vLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcclxuQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAoKSB7XHJcbiAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApXHJcbiAgICB0aGlzLmxlbmd0aC0tO1xyXG4gIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbigpIHtcclxuICAvLyAtMCA9IDBcclxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMClcclxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xyXG4gIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xyXG59O1xyXG5cclxuLypcclxuXHJcbnZhciB6ZXJvcyA9IFtdO1xyXG52YXIgZ3JvdXBTaXplcyA9IFtdO1xyXG52YXIgZ3JvdXBCYXNlcyA9IFtdO1xyXG5cclxudmFyIHMgPSAnJztcclxudmFyIGkgPSAtMTtcclxud2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XHJcbiAgemVyb3NbaV0gPSBzO1xyXG4gIHMgKz0gJzAnO1xyXG59XHJcbmdyb3VwU2l6ZXNbMF0gPSAwO1xyXG5ncm91cFNpemVzWzFdID0gMDtcclxuZ3JvdXBCYXNlc1swXSA9IDA7XHJcbmdyb3VwQmFzZXNbMV0gPSAwO1xyXG52YXIgYmFzZSA9IDIgLSAxO1xyXG53aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XHJcbiAgdmFyIGdyb3VwU2l6ZSA9IDA7XHJcbiAgdmFyIGdyb3VwQmFzZSA9IDE7XHJcbiAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcclxuICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xyXG4gICAgZ3JvdXBTaXplICs9IDE7XHJcbiAgfVxyXG4gIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XHJcbiAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcclxufVxyXG5cclxuKi9cclxuXHJcbnZhciB6ZXJvcyA9IFtcclxuICAnJyxcclxuICAnMCcsXHJcbiAgJzAwJyxcclxuICAnMDAwJyxcclxuICAnMDAwMCcsXHJcbiAgJzAwMDAwJyxcclxuICAnMDAwMDAwJyxcclxuICAnMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXHJcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcclxuXTtcclxuXHJcbnZhciBncm91cFNpemVzID0gW1xyXG4gIDAsIDAsXHJcbiAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxyXG4gIDgsIDcsIDcsIDcsIDcsIDYsIDYsXHJcbiAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcclxuICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxyXG4gIDUsIDUsIDUsIDUsIDUsIDUsIDVcclxuXTtcclxuXHJcbnZhciBncm91cEJhc2VzID0gW1xyXG4gIDAsIDAsXHJcbiAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXHJcbiAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcclxuICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXHJcbiAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXHJcbiAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcclxuXTtcclxuXHJcbkJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGJhc2UsIHBhZGRpbmcpIHtcclxuICBiYXNlID0gYmFzZSB8fCAxMDtcclxuICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcclxuICAgIHZhciBvdXQgPSAnJztcclxuICAgIHZhciBvZmYgPSAwO1xyXG4gICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xyXG4gICAgdmFyIGNhcnJ5ID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XHJcbiAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcclxuICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSlcclxuICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XHJcbiAgICAgIG9mZiArPSAyO1xyXG4gICAgICBpZiAob2ZmID49IDI2KSB7XHJcbiAgICAgICAgb2ZmIC09IDI2O1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNhcnJ5ICE9PSAwKVxyXG4gICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XHJcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApXHJcbiAgICAgIG91dCA9ICcwJyArIG91dDtcclxuICAgIGlmICh0aGlzLnNpZ24pXHJcbiAgICAgIG91dCA9ICctJyArIG91dDtcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfSBlbHNlIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XHJcbiAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xyXG4gICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XHJcbiAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcclxuICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xyXG4gICAgdmFyIG91dCA9ICcnO1xyXG4gICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XHJcbiAgICBjLnNpZ24gPSBmYWxzZTtcclxuICAgIHdoaWxlIChjLmNtcG4oMCkgIT09IDApIHtcclxuICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcclxuICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcclxuXHJcbiAgICAgIGlmIChjLmNtcG4oMCkgIT09IDApXHJcbiAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dCA9IHIgKyBvdXQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jbXBuKDApID09PSAwKVxyXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XHJcbiAgICBpZiAodGhpcy5zaWduKVxyXG4gICAgICBvdXQgPSAnLScgKyBvdXQ7XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoZW5kaWFuKSB7XHJcbiAgdGhpcy5zdHJpcCgpO1xyXG4gIHZhciByZXMgPSBuZXcgQXJyYXkodGhpcy5ieXRlTGVuZ3RoKCkpO1xyXG4gIHJlc1swXSA9IDA7XHJcblxyXG4gIHZhciBxID0gdGhpcy5jbG9uZSgpO1xyXG4gIGlmIChlbmRpYW4gIT09ICdsZScpIHtcclxuICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgcS5jbXBuKDApICE9PSAwOyBpKyspIHtcclxuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xyXG4gICAgICBxLmlzaHJuKDgpO1xyXG5cclxuICAgICAgcmVzW3Jlcy5sZW5ndGggLSBpIC0gMV0gPSBiO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBBc3N1bWUgbGl0dGxlLWVuZGlhblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IHEuY21wbigwKSAhPT0gMDsgaSsrKSB7XHJcbiAgICAgIHZhciBiID0gcS5hbmRsbigweGZmKTtcclxuICAgICAgcS5pc2hybig4KTtcclxuXHJcbiAgICAgIHJlc1tpXSA9IGI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuaWYgKE1hdGguY2x6MzIpIHtcclxuICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHModykge1xyXG4gICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcclxuICB9O1xyXG59IGVsc2Uge1xyXG4gIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyh3KSB7XHJcbiAgICB2YXIgdCA9IHc7XHJcbiAgICB2YXIgciA9IDA7XHJcbiAgICBpZiAodCA+PSAweDEwMDApIHtcclxuICAgICAgciArPSAxMztcclxuICAgICAgdCA+Pj49IDEzO1xyXG4gICAgfVxyXG4gICAgaWYgKHQgPj0gMHg0MCkge1xyXG4gICAgICByICs9IDc7XHJcbiAgICAgIHQgPj4+PSA3O1xyXG4gICAgfVxyXG4gICAgaWYgKHQgPj0gMHg4KSB7XHJcbiAgICAgIHIgKz0gNDtcclxuICAgICAgdCA+Pj49IDQ7XHJcbiAgICB9XHJcbiAgICBpZiAodCA+PSAweDAyKSB7XHJcbiAgICAgIHIgKz0gMjtcclxuICAgICAgdCA+Pj49IDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gciArIHQ7XHJcbiAgfTtcclxufVxyXG5cclxuQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyh3KSB7XHJcbiAgLy8gU2hvcnQtY3V0XHJcbiAgaWYgKHcgPT09IDApXHJcbiAgICByZXR1cm4gMjY7XHJcblxyXG4gIHZhciB0ID0gdztcclxuICB2YXIgciA9IDA7XHJcbiAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xyXG4gICAgciArPSAxMztcclxuICAgIHQgPj4+PSAxMztcclxuICB9XHJcbiAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcclxuICAgIHIgKz0gNztcclxuICAgIHQgPj4+PSA3O1xyXG4gIH1cclxuICBpZiAoKHQgJiAweGYpID09PSAwKSB7XHJcbiAgICByICs9IDQ7XHJcbiAgICB0ID4+Pj0gNDtcclxuICB9XHJcbiAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xyXG4gICAgciArPSAyO1xyXG4gICAgdCA+Pj49IDI7XHJcbiAgfVxyXG4gIGlmICgodCAmIDB4MSkgPT09IDApXHJcbiAgICByKys7XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG4vLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXHJcbkJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGgoKSB7XHJcbiAgdmFyIGhpID0gMDtcclxuICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcclxuICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XHJcbiAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcclxufTtcclxuXHJcbi8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcclxuQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMoKSB7XHJcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcclxuICAgIHJldHVybiAwO1xyXG5cclxuICB2YXIgciA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xyXG4gICAgciArPSBiO1xyXG4gICAgaWYgKGIgIT09IDI2KVxyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoKSB7XHJcbiAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XHJcbn07XHJcblxyXG4vLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXHJcbkJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XHJcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcblxyXG4gIHZhciByID0gdGhpcy5jbG9uZSgpO1xyXG4gIHIuc2lnbiA9ICF0aGlzLnNpZ247XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5cclxuLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcclxuQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvcihudW0pIHtcclxuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gfHwgbnVtLnNpZ247XHJcblxyXG4gIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpXHJcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspXHJcbiAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcclxuXHJcbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcclxufTtcclxuXHJcblxyXG4vLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxyXG5CTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihudW0pIHtcclxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxyXG5CTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQobnVtKSB7XHJcbiAgdGhpcy5zaWduID0gdGhpcy5zaWduICYmIG51bS5zaWduO1xyXG5cclxuICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXHJcbiAgdmFyIGI7XHJcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcclxuICAgIGIgPSBudW07XHJcbiAgZWxzZVxyXG4gICAgYiA9IHRoaXM7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKylcclxuICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xyXG5cclxuICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xyXG5cclxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xyXG59O1xyXG5cclxuXHJcbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxyXG5CTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG51bSkge1xyXG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcclxuQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yKG51bSkge1xyXG4gIHRoaXMuc2lnbiA9IHRoaXMuc2lnbiB8fCBudW0uc2lnbjtcclxuXHJcbiAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxyXG4gIHZhciBhO1xyXG4gIHZhciBiO1xyXG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcclxuICAgIGEgPSB0aGlzO1xyXG4gICAgYiA9IG51bTtcclxuICB9IGVsc2Uge1xyXG4gICAgYSA9IG51bTtcclxuICAgIGIgPSB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKVxyXG4gICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xyXG5cclxuICBpZiAodGhpcyAhPT0gYSlcclxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XHJcblxyXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XHJcblxyXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XHJcbn07XHJcblxyXG5cclxuLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXHJcbkJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IobnVtKSB7XHJcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8vIFNldCBgYml0YCBvZiBgdGhpc2BcclxuQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuKGJpdCwgdmFsKSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcclxuXHJcbiAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xyXG4gIHZhciB3Yml0ID0gYml0ICUgMjY7XHJcblxyXG4gIHdoaWxlICh0aGlzLmxlbmd0aCA8PSBvZmYpXHJcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcclxuXHJcbiAgaWYgKHZhbClcclxuICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xyXG4gIGVsc2VcclxuICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcclxuXHJcbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcclxufTtcclxuXHJcblxyXG4vLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXHJcbkJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChudW0pIHtcclxuICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXHJcbiAgaWYgKHRoaXMuc2lnbiAmJiAhbnVtLnNpZ24pIHtcclxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gICAgdmFyIHIgPSB0aGlzLmlzdWIobnVtKTtcclxuICAgIHRoaXMuc2lnbiA9ICF0aGlzLnNpZ247XHJcbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcclxuXHJcbiAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxyXG4gIH0gZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBudW0uc2lnbikge1xyXG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcclxuICAgIHZhciByID0gdGhpcy5pc3ViKG51bSk7XHJcbiAgICBudW0uc2lnbiA9IHRydWU7XHJcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcclxuICB9XHJcblxyXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcclxuICB2YXIgYTtcclxuICB2YXIgYjtcclxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XHJcbiAgICBhID0gdGhpcztcclxuICAgIGIgPSBudW07XHJcbiAgfSBlbHNlIHtcclxuICAgIGEgPSBudW07XHJcbiAgICBiID0gdGhpcztcclxuICB9XHJcblxyXG4gIHZhciBjYXJyeSA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgciA9IGEud29yZHNbaV0gKyBiLndvcmRzW2ldICsgY2Fycnk7XHJcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcclxuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XHJcbiAgfVxyXG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHIgPSBhLndvcmRzW2ldICsgY2Fycnk7XHJcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcclxuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XHJcbiAgfVxyXG5cclxuICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xyXG4gIGlmIChjYXJyeSAhPT0gMCkge1xyXG4gICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcclxuICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcclxuICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcclxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEFkZCBgbnVtYCB0byBgdGhpc2BcclxuQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChudW0pIHtcclxuICBpZiAobnVtLnNpZ24gJiYgIXRoaXMuc2lnbikge1xyXG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcclxuICAgIHZhciByZXMgPSB0aGlzLnN1YihudW0pO1xyXG4gICAgbnVtLnNpZ24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9IGVsc2UgaWYgKCFudW0uc2lnbiAmJiB0aGlzLnNpZ24pIHtcclxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gICAgdmFyIHJlcyA9IG51bS5zdWIodGhpcyk7XHJcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcclxufTtcclxuXHJcbi8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXHJcbkJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihudW0pIHtcclxuICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxyXG4gIGlmIChudW0uc2lnbikge1xyXG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcclxuICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XHJcbiAgICBudW0uc2lnbiA9IHRydWU7XHJcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcclxuXHJcbiAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXHJcbiAgfSBlbHNlIGlmICh0aGlzLnNpZ24pIHtcclxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5pYWRkKG51bSk7XHJcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XHJcbiAgfVxyXG5cclxuICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcclxuICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcclxuXHJcbiAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxyXG4gIGlmIChjbXAgPT09IDApIHtcclxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIGEgPiBiXHJcbiAgdmFyIGE7XHJcbiAgdmFyIGI7XHJcbiAgaWYgKGNtcCA+IDApIHtcclxuICAgIGEgPSB0aGlzO1xyXG4gICAgYiA9IG51bTtcclxuICB9IGVsc2Uge1xyXG4gICAgYSA9IG51bTtcclxuICAgIGIgPSB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNhcnJ5ID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciByID0gYS53b3Jkc1tpXSAtIGIud29yZHNbaV0gKyBjYXJyeTtcclxuICAgIGNhcnJ5ID0gciA+PiAyNjtcclxuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xyXG4gIH1cclxuICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciByID0gYS53b3Jkc1tpXSArIGNhcnJ5O1xyXG4gICAgY2FycnkgPSByID4+IDI2O1xyXG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XHJcbiAgfVxyXG5cclxuICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXHJcbiAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKVxyXG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcclxuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcclxuXHJcbiAgaWYgKGEgIT09IHRoaXMpXHJcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xyXG59O1xyXG5cclxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcclxuQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihudW0pIHtcclxuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcclxufTtcclxuXHJcbi8qXHJcbi8vIE5PVEU6IFRoaXMgY291bGQgYmUgcG90ZW50aW9uYWxseSB1c2VkIHRvIGdlbmVyYXRlIGxvb3AtbGVzcyBtdWx0aXBsaWNhdGlvbnNcclxuZnVuY3Rpb24gX2dlbkNvbWJNdWxUbyhhbGVuLCBibGVuKSB7XHJcbiAgdmFyIGxlbiA9IGFsZW4gKyBibGVuIC0gMTtcclxuICB2YXIgc3JjID0gW1xyXG4gICAgJ3ZhciBhID0gdGhpcy53b3JkcywgYiA9IG51bS53b3JkcywgbyA9IG91dC53b3JkcywgYyA9IDAsIHcsICcgK1xyXG4gICAgICAgICdtYXNrID0gMHgzZmZmZmZmLCBzaGlmdCA9IDB4NDAwMDAwMDsnLFxyXG4gICAgJ291dC5sZW5ndGggPSAnICsgbGVuICsgJzsnXHJcbiAgXTtcclxuICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XHJcbiAgICB2YXIgbWluSiA9IE1hdGgubWF4KDAsIGsgLSBhbGVuICsgMSk7XHJcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIGJsZW4gLSAxKTtcclxuXHJcbiAgICBmb3IgKHZhciBqID0gbWluSjsgaiA8PSBtYXhKOyBqKyspIHtcclxuICAgICAgdmFyIGkgPSBrIC0gajtcclxuICAgICAgdmFyIG11bCA9ICdhWycgKyBpICsgJ10gKiBiWycgKyBqICsgJ10nO1xyXG5cclxuICAgICAgaWYgKGogPT09IG1pbkopIHtcclxuICAgICAgICBzcmMucHVzaCgndyA9ICcgKyBtdWwgKyAnICsgYzsnKTtcclxuICAgICAgICBzcmMucHVzaCgnYyA9ICh3IC8gc2hpZnQpIHwgMDsnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzcmMucHVzaCgndyArPSAnICsgbXVsICsgJzsnKTtcclxuICAgICAgICBzcmMucHVzaCgnYyArPSAodyAvIHNoaWZ0KSB8IDA7Jyk7XHJcbiAgICAgIH1cclxuICAgICAgc3JjLnB1c2goJ3cgJj0gbWFzazsnKTtcclxuICAgIH1cclxuICAgIHNyYy5wdXNoKCdvWycgKyBrICsgJ10gPSB3OycpO1xyXG4gIH1cclxuICBzcmMucHVzaCgnaWYgKGMgIT09IDApIHsnLFxyXG4gICAgICAgICAgICcgIG9bJyArIGsgKyAnXSA9IGM7JyxcclxuICAgICAgICAgICAnICBvdXQubGVuZ3RoKys7JyxcclxuICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgJ3JldHVybiBvdXQ7Jyk7XHJcblxyXG4gIHJldHVybiBzcmMuam9pbignXFxuJyk7XHJcbn1cclxuKi9cclxuXHJcbkJOLnByb3RvdHlwZS5fc21hbGxNdWxUbyA9IGZ1bmN0aW9uIF9zbWFsbE11bFRvKG51bSwgb3V0KSB7XHJcbiAgb3V0LnNpZ24gPSBudW0uc2lnbiAhPT0gdGhpcy5zaWduO1xyXG4gIG91dC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XHJcblxyXG4gIHZhciBjYXJyeSA9IDA7XHJcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXHJcbiAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxyXG4gICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcclxuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xyXG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XHJcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHRoaXMubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XHJcbiAgICAgIHZhciBpID0gayAtIGo7XHJcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XHJcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcclxuICAgICAgdmFyIHIgPSBhICogYjtcclxuXHJcbiAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XHJcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcclxuICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xyXG4gICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xyXG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcclxuICAgIH1cclxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xyXG4gICAgY2FycnkgPSBuY2Fycnk7XHJcbiAgfVxyXG4gIGlmIChjYXJyeSAhPT0gMCkge1xyXG4gICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG91dC5sZW5ndGgtLTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXQuc3RyaXAoKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5fYmlnTXVsVG8gPSBmdW5jdGlvbiBfYmlnTXVsVG8obnVtLCBvdXQpIHtcclxuICBvdXQuc2lnbiA9IG51bS5zaWduICE9PSB0aGlzLnNpZ247XHJcbiAgb3V0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcclxuXHJcbiAgdmFyIGNhcnJ5ID0gMDtcclxuICB2YXIgaG5jYXJyeSA9IDA7XHJcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXHJcbiAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxyXG4gICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XHJcbiAgICBobmNhcnJ5ID0gMDtcclxuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xyXG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XHJcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHRoaXMubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XHJcbiAgICAgIHZhciBpID0gayAtIGo7XHJcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XHJcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcclxuICAgICAgdmFyIHIgPSBhICogYjtcclxuXHJcbiAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XHJcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcclxuICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xyXG4gICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xyXG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcclxuXHJcbiAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcclxuICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcclxuICAgIH1cclxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xyXG4gICAgY2FycnkgPSBuY2Fycnk7XHJcbiAgICBuY2FycnkgPSBobmNhcnJ5O1xyXG4gIH1cclxuICBpZiAoY2FycnkgIT09IDApIHtcclxuICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvdXQubGVuZ3RoLS07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0LnN0cmlwKCk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyhudW0sIG91dCkge1xyXG4gIHZhciByZXM7XHJcbiAgaWYgKHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCA8IDYzKVxyXG4gICAgcmVzID0gdGhpcy5fc21hbGxNdWxUbyhudW0sIG91dCk7XHJcbiAgZWxzZVxyXG4gICAgcmVzID0gdGhpcy5fYmlnTXVsVG8obnVtLCBvdXQpO1xyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcclxuQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChudW0pIHtcclxuICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xyXG4gIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xyXG4gIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcclxufTtcclxuXHJcbi8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXHJcbkJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChudW0pIHtcclxuICBpZiAodGhpcy5jbXBuKDApID09PSAwIHx8IG51bS5jbXBuKDApID09PSAwKSB7XHJcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcclxuICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRsZW4gPSB0aGlzLmxlbmd0aDtcclxuICB2YXIgbmxlbiA9IG51bS5sZW5ndGg7XHJcblxyXG4gIHRoaXMuc2lnbiA9IG51bS5zaWduICE9PSB0aGlzLnNpZ247XHJcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XHJcbiAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID0gMDtcclxuXHJcbiAgZm9yICh2YXIgayA9IHRoaXMubGVuZ3RoIC0gMjsgayA+PSAwOyBrLS0pIHtcclxuICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgY2FycnlgLFxyXG4gICAgLy8gbm90ZSB0aGF0IGNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxyXG4gICAgdmFyIGNhcnJ5ID0gMDtcclxuICAgIHZhciByd29yZCA9IDA7XHJcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG5sZW4gLSAxKTtcclxuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gdGxlbiArIDEpOyBqIDw9IG1heEo7IGorKykge1xyXG4gICAgICB2YXIgaSA9IGsgLSBqO1xyXG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV07XHJcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdO1xyXG4gICAgICB2YXIgciA9IGEgKiBiO1xyXG5cclxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcclxuICAgICAgY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcclxuICAgICAgbG8gKz0gcndvcmQ7XHJcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XHJcbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcclxuICAgIH1cclxuICAgIHRoaXMud29yZHNba10gPSByd29yZDtcclxuICAgIHRoaXMud29yZHNbayArIDFdICs9IGNhcnJ5O1xyXG4gICAgY2FycnkgPSAwO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJvcGFnYXRlIG92ZXJmbG93c1xyXG4gIHZhciBjYXJyeSA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKyBjYXJyeTtcclxuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xyXG4gICAgY2FycnkgPSB3ID4+PiAyNjtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbihudW0pIHtcclxuICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xyXG5cclxuICAvLyBDYXJyeVxyXG4gIHZhciBjYXJyeSA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKiBudW07XHJcbiAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xyXG4gICAgY2FycnkgPj49IDI2O1xyXG4gICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcclxuICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cclxuICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcclxuICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcclxuICB9XHJcblxyXG4gIGlmIChjYXJyeSAhPT0gMCkge1xyXG4gICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xyXG4gICAgdGhpcy5sZW5ndGgrKztcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuKG51bSkge1xyXG4gIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcclxufTtcclxuXHJcbi8vIGB0aGlzYCAqIGB0aGlzYFxyXG5CTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyKCkge1xyXG4gIHJldHVybiB0aGlzLm11bCh0aGlzKTtcclxufTtcclxuXHJcbi8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxyXG5CTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoKSB7XHJcbiAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xyXG59O1xyXG5cclxuLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxyXG5CTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbihiaXRzKSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xyXG4gIHZhciByID0gYml0cyAlIDI2O1xyXG4gIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xyXG4gIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XHJcblxyXG4gIGlmIChyICE9PSAwKSB7XHJcbiAgICB2YXIgY2FycnkgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XHJcbiAgICAgIHZhciBjID0gKHRoaXMud29yZHNbaV0gLSBuZXdDYXJyeSkgPDwgcjtcclxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcclxuICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XHJcbiAgICB9XHJcbiAgICBpZiAoY2FycnkpIHtcclxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xyXG4gICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHMgIT09IDApIHtcclxuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKylcclxuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XHJcbiAgICB0aGlzLmxlbmd0aCArPSBzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcclxufTtcclxuXHJcbi8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXHJcbi8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xyXG4vLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXHJcbkJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xyXG4gIHZhciBoO1xyXG4gIGlmIChoaW50KVxyXG4gICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XHJcbiAgZWxzZVxyXG4gICAgaCA9IDA7XHJcblxyXG4gIHZhciByID0gYml0cyAlIDI2O1xyXG4gIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XHJcbiAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XHJcbiAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XHJcblxyXG4gIGggLT0gcztcclxuICBoID0gTWF0aC5tYXgoMCwgaCk7XHJcblxyXG4gIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcclxuICBpZiAobWFza2VkV29yZHMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKVxyXG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XHJcbiAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHMgPT09IDApIHtcclxuICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXHJcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcclxuICAgIHRoaXMubGVuZ3RoIC09IHM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDE7XHJcbiAgfVxyXG5cclxuICB2YXIgY2FycnkgPSAwO1xyXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XHJcbiAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV07XHJcbiAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcclxuICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XHJcbiAgfVxyXG5cclxuICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcclxuICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApXHJcbiAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcclxuXHJcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcclxuICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICB9XHJcblxyXG4gIHRoaXMuc3RyaXAoKTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBTaGlmdC1sZWZ0XHJcbkJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbihiaXRzKSB7XHJcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcclxufTtcclxuXHJcbi8vIFNoaWZ0LXJpZ2h0XHJcbkJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybihiaXRzKSB7XHJcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcclxufTtcclxuXHJcbi8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XHJcbkJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuKGJpdCkge1xyXG4gIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XHJcbiAgdmFyIHIgPSBiaXQgJSAyNjtcclxuICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xyXG4gIHZhciBxID0gMSA8PCByO1xyXG5cclxuICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xyXG4gIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxyXG4gIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcclxuXHJcbiAgcmV0dXJuICEhKHcgJiBxKTtcclxufTtcclxuXHJcbi8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXHJcbkJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24oYml0cykge1xyXG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcclxuICB2YXIgciA9IGJpdHMgJSAyNjtcclxuICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcclxuXHJcbiAgYXNzZXJ0KCF0aGlzLnNpZ24sICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcclxuXHJcbiAgaWYgKHIgIT09IDApXHJcbiAgICBzKys7XHJcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XHJcblxyXG4gIGlmIChyICE9PSAwKSB7XHJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcclxuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcclxufTtcclxuXHJcbi8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxyXG5CTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbihiaXRzKSB7XHJcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XHJcbn07XHJcblxyXG4vLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxyXG5CTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbihudW0pIHtcclxuICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xyXG4gIGlmIChudW0gPCAwKVxyXG4gICAgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XHJcblxyXG4gIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXHJcbiAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCBudW0pIHtcclxuICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtIHRoaXMud29yZHNbMF07XHJcbiAgICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcclxuICAgIHRoaXMuaXN1Ym4obnVtKTtcclxuICAgIHRoaXMuc2lnbiA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xyXG4gIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbihudW0pIHtcclxuICB0aGlzLndvcmRzWzBdICs9IG51bTtcclxuXHJcbiAgLy8gQ2FycnlcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcclxuICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xyXG4gICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSlcclxuICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xyXG4gIH1cclxuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXHJcbkJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuKG51bSkge1xyXG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XHJcbiAgaWYgKG51bSA8IDApXHJcbiAgICByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcclxuXHJcbiAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgdGhpcy5zaWduID0gZmFsc2U7XHJcbiAgICB0aGlzLmlhZGRuKG51bSk7XHJcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB0aGlzLndvcmRzWzBdIC09IG51bTtcclxuXHJcbiAgLy8gQ2FycnlcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcclxuICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xyXG4gICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4obnVtKSB7XHJcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuKG51bSkge1xyXG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicygpIHtcclxuICB0aGlzLnNpZ24gPSBmYWxzZTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzKCkge1xyXG4gIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bChudW0sIG11bCwgc2hpZnQpIHtcclxuICAvLyBCaWdnZXIgc3RvcmFnZSBpcyBuZWVkZWRcclxuICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xyXG4gIHZhciBpO1xyXG4gIGlmICh0aGlzLndvcmRzLmxlbmd0aCA8IGxlbikge1xyXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkobGVuKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgdFtpXSA9IHRoaXMud29yZHNbaV07XHJcbiAgICB0aGlzLndvcmRzID0gdDtcclxuICB9IGVsc2Uge1xyXG4gICAgaSA9IHRoaXMubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gWmVyb2lmeSByZXN0XHJcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgbGVuKTtcclxuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcclxuXHJcbiAgdmFyIGNhcnJ5ID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2kgKyBzaGlmdF0gKyBjYXJyeTtcclxuICAgIHZhciByaWdodCA9IG51bS53b3Jkc1tpXSAqIG11bDtcclxuICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XHJcbiAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XHJcbiAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xyXG4gIH1cclxuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xyXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2kgKyBzaGlmdF0gKyBjYXJyeTtcclxuICAgIGNhcnJ5ID0gdyA+PiAyNjtcclxuICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FycnkgPT09IDApXHJcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xyXG5cclxuICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xyXG4gIGFzc2VydChjYXJyeSA9PT0gLTEpO1xyXG4gIGNhcnJ5ID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB3ID0gLXRoaXMud29yZHNbaV0gKyBjYXJyeTtcclxuICAgIGNhcnJ5ID0gdyA+PiAyNjtcclxuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xyXG4gIH1cclxuICB0aGlzLnNpZ24gPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYobnVtLCBtb2RlKSB7XHJcbiAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xyXG5cclxuICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcclxuICB2YXIgYiA9IG51bTtcclxuXHJcbiAgLy8gTm9ybWFsaXplXHJcbiAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXTtcclxuICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xyXG4gIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xyXG4gIGlmIChzaGlmdCAhPT0gMCkge1xyXG4gICAgYiA9IGIuc2hsbihzaGlmdCk7XHJcbiAgICBhLmlzaGxuKHNoaWZ0KTtcclxuICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXTtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcXVvdGllbnRcclxuICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XHJcbiAgdmFyIHE7XHJcblxyXG4gIGlmIChtb2RlICE9PSAnbW9kJykge1xyXG4gICAgcSA9IG5ldyBCTihudWxsKTtcclxuICAgIHEubGVuZ3RoID0gbSArIDE7XHJcbiAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKylcclxuICAgICAgcS53b3Jkc1tpXSA9IDA7XHJcbiAgfVxyXG5cclxuICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XHJcbiAgaWYgKCFkaWZmLnNpZ24pIHtcclxuICAgIGEgPSBkaWZmO1xyXG4gICAgaWYgKHEpXHJcbiAgICAgIHEud29yZHNbbV0gPSAxO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgdmFyIHFqID0gYS53b3Jkc1tiLmxlbmd0aCArIGpdICogMHg0MDAwMDAwICsgYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXTtcclxuXHJcbiAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxyXG4gICAgLy8gKDB4N2ZmZmZmZilcclxuICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XHJcblxyXG4gICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xyXG4gICAgd2hpbGUgKGEuc2lnbikge1xyXG4gICAgICBxai0tO1xyXG4gICAgICBhLnNpZ24gPSBmYWxzZTtcclxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XHJcbiAgICAgIGlmIChhLmNtcG4oMCkgIT09IDApXHJcbiAgICAgICAgYS5zaWduID0gIWEuc2lnbjtcclxuICAgIH1cclxuICAgIGlmIChxKVxyXG4gICAgICBxLndvcmRzW2pdID0gcWo7XHJcbiAgfVxyXG4gIGlmIChxKVxyXG4gICAgcS5zdHJpcCgpO1xyXG4gIGEuc3RyaXAoKTtcclxuXHJcbiAgLy8gRGVub3JtYWxpemVcclxuICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApXHJcbiAgICBhLmlzaHJuKHNoaWZ0KTtcclxuICByZXR1cm4geyBkaXY6IHEgPyBxIDogbnVsbCwgbW9kOiBhIH07XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kKG51bSwgbW9kZSkge1xyXG4gIGFzc2VydChudW0uY21wbigwKSAhPT0gMCk7XHJcblxyXG4gIGlmICh0aGlzLnNpZ24gJiYgIW51bS5zaWduKSB7XHJcbiAgICB2YXIgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcclxuICAgIHZhciBkaXY7XHJcbiAgICB2YXIgbW9kO1xyXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKVxyXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xyXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnKVxyXG4gICAgICBtb2QgPSByZXMubW9kLmNtcG4oMCkgPT09IDAgPyByZXMubW9kIDogbnVtLnN1YihyZXMubW9kKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpdjogZGl2LFxyXG4gICAgICBtb2Q6IG1vZFxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKCF0aGlzLnNpZ24gJiYgbnVtLnNpZ24pIHtcclxuICAgIHZhciByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xyXG4gICAgdmFyIGRpdjtcclxuICAgIGlmIChtb2RlICE9PSAnbW9kJylcclxuICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcclxuICAgIHJldHVybiB7IGRpdjogZGl2LCBtb2Q6IHJlcy5tb2QgfTtcclxuICB9IGVsc2UgaWYgKHRoaXMuc2lnbiAmJiBudW0uc2lnbikge1xyXG4gICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XHJcbiAgfVxyXG5cclxuICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcclxuXHJcbiAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXHJcbiAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMClcclxuICAgIHJldHVybiB7IGRpdjogbmV3IEJOKDApLCBtb2Q6IHRoaXMgfTtcclxuXHJcbiAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cclxuICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgaWYgKG1vZGUgPT09ICdkaXYnKVxyXG4gICAgICByZXR1cm4geyBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLCBtb2Q6IG51bGwgfTtcclxuICAgIGVsc2UgaWYgKG1vZGUgPT09ICdtb2QnKVxyXG4gICAgICByZXR1cm4geyBkaXY6IG51bGwsIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKSB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcclxuICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcclxufTtcclxuXHJcbi8vIEZpbmQgYHRoaXNgIC8gYG51bWBcclxuQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdihudW0pIHtcclxuICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JykuZGl2O1xyXG59O1xyXG5cclxuLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxyXG5CTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kKG51bSkge1xyXG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnKS5tb2Q7XHJcbn07XHJcblxyXG4vLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxyXG5CTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZChudW0pIHtcclxuICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xyXG5cclxuICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxyXG4gIGlmIChkbS5tb2QuY21wbigwKSA9PT0gMClcclxuICAgIHJldHVybiBkbS5kaXY7XHJcblxyXG4gIHZhciBtb2QgPSBkbS5kaXYuc2lnbiA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XHJcblxyXG4gIHZhciBoYWxmID0gbnVtLnNocm4oMSk7XHJcbiAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xyXG4gIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xyXG5cclxuICAvLyBSb3VuZCBkb3duXHJcbiAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKVxyXG4gICAgcmV0dXJuIGRtLmRpdjtcclxuXHJcbiAgLy8gUm91bmQgdXBcclxuICByZXR1cm4gZG0uZGl2LnNpZ24gPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4obnVtKSB7XHJcbiAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xyXG4gIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xyXG5cclxuICB2YXIgYWNjID0gMDtcclxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgIGFjYyA9IChwICogYWNjICsgdGhpcy53b3Jkc1tpXSkgJSBudW07XHJcblxyXG4gIHJldHVybiBhY2M7XHJcbn07XHJcblxyXG4vLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcclxuQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4obnVtKSB7XHJcbiAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xyXG5cclxuICB2YXIgY2FycnkgPSAwO1xyXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKyBjYXJyeSAqIDB4NDAwMDAwMDtcclxuICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xyXG4gICAgY2FycnkgPSB3ICUgbnVtO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2bihudW0pIHtcclxuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QocCkge1xyXG4gIGFzc2VydCghcC5zaWduKTtcclxuICBhc3NlcnQocC5jbXBuKDApICE9PSAwKTtcclxuXHJcbiAgdmFyIHggPSB0aGlzO1xyXG4gIHZhciB5ID0gcC5jbG9uZSgpO1xyXG5cclxuICBpZiAoeC5zaWduKVxyXG4gICAgeCA9IHgubW9kKHApO1xyXG4gIGVsc2VcclxuICAgIHggPSB4LmNsb25lKCk7XHJcblxyXG4gIC8vIEEgKiB4ICsgQiAqIHkgPSB4XHJcbiAgdmFyIEEgPSBuZXcgQk4oMSk7XHJcbiAgdmFyIEIgPSBuZXcgQk4oMCk7XHJcblxyXG4gIC8vIEMgKiB4ICsgRCAqIHkgPSB5XHJcbiAgdmFyIEMgPSBuZXcgQk4oMCk7XHJcbiAgdmFyIEQgPSBuZXcgQk4oMSk7XHJcblxyXG4gIHZhciBnID0gMDtcclxuXHJcbiAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xyXG4gICAgeC5pc2hybigxKTtcclxuICAgIHkuaXNocm4oMSk7XHJcbiAgICArK2c7XHJcbiAgfVxyXG5cclxuICB2YXIgeXAgPSB5LmNsb25lKCk7XHJcbiAgdmFyIHhwID0geC5jbG9uZSgpO1xyXG5cclxuICB3aGlsZSAoeC5jbXBuKDApICE9PSAwKSB7XHJcbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSkge1xyXG4gICAgICB4LmlzaHJuKDEpO1xyXG4gICAgICBpZiAoQS5pc0V2ZW4oKSAmJiBCLmlzRXZlbigpKSB7XHJcbiAgICAgICAgQS5pc2hybigxKTtcclxuICAgICAgICBCLmlzaHJuKDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEEuaWFkZCh5cCkuaXNocm4oMSk7XHJcbiAgICAgICAgQi5pc3ViKHhwKS5pc2hybigxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlICh5LmlzRXZlbigpKSB7XHJcbiAgICAgIHkuaXNocm4oMSk7XHJcbiAgICAgIGlmIChDLmlzRXZlbigpICYmIEQuaXNFdmVuKCkpIHtcclxuICAgICAgICBDLmlzaHJuKDEpO1xyXG4gICAgICAgIEQuaXNocm4oMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgQy5pYWRkKHlwKS5pc2hybigxKTtcclxuICAgICAgICBELmlzdWIoeHApLmlzaHJuKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHguY21wKHkpID49IDApIHtcclxuICAgICAgeC5pc3ViKHkpO1xyXG4gICAgICBBLmlzdWIoQyk7XHJcbiAgICAgIEIuaXN1YihEKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHkuaXN1Yih4KTtcclxuICAgICAgQy5pc3ViKEEpO1xyXG4gICAgICBELmlzdWIoQik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYTogQyxcclxuICAgIGI6IEQsXHJcbiAgICBnY2Q6IHkuaXNobG4oZylcclxuICB9O1xyXG59O1xyXG5cclxuLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXHJcbi8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxyXG4vLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxyXG5CTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wKHApIHtcclxuICBhc3NlcnQoIXAuc2lnbik7XHJcbiAgYXNzZXJ0KHAuY21wbigwKSAhPT0gMCk7XHJcblxyXG4gIHZhciBhID0gdGhpcztcclxuICB2YXIgYiA9IHAuY2xvbmUoKTtcclxuXHJcbiAgaWYgKGEuc2lnbilcclxuICAgIGEgPSBhLm1vZChwKTtcclxuICBlbHNlXHJcbiAgICBhID0gYS5jbG9uZSgpO1xyXG5cclxuICB2YXIgeDEgPSBuZXcgQk4oMSk7XHJcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xyXG5cclxuICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XHJcblxyXG4gIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcclxuICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XHJcbiAgICAgIGEuaXNocm4oMSk7XHJcbiAgICAgIGlmICh4MS5pc0V2ZW4oKSlcclxuICAgICAgICB4MS5pc2hybigxKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHgxLmlhZGQoZGVsdGEpLmlzaHJuKDEpO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcclxuICAgICAgYi5pc2hybigxKTtcclxuICAgICAgaWYgKHgyLmlzRXZlbigpKVxyXG4gICAgICAgIHgyLmlzaHJuKDEpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgeDIuaWFkZChkZWx0YSkuaXNocm4oMSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xyXG4gICAgICBhLmlzdWIoYik7XHJcbiAgICAgIHgxLmlzdWIoeDIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYi5pc3ViKGEpO1xyXG4gICAgICB4Mi5pc3ViKHgxKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGEuY21wbigxKSA9PT0gMClcclxuICAgIHJldHVybiB4MTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4geDI7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkKG51bSkge1xyXG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXHJcbiAgICByZXR1cm4gbnVtLmNsb25lKCk7XHJcbiAgaWYgKG51bS5jbXBuKDApID09PSAwKVxyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuXHJcbiAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XHJcbiAgdmFyIGIgPSBudW0uY2xvbmUoKTtcclxuICBhLnNpZ24gPSBmYWxzZTtcclxuICBiLnNpZ24gPSBmYWxzZTtcclxuXHJcbiAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXHJcbiAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcclxuICAgIGEuaXNocm4oMSk7XHJcbiAgICBiLmlzaHJuKDEpO1xyXG4gIH1cclxuXHJcbiAgZG8ge1xyXG4gICAgd2hpbGUgKGEuaXNFdmVuKCkpXHJcbiAgICAgIGEuaXNocm4oMSk7XHJcbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSlcclxuICAgICAgYi5pc2hybigxKTtcclxuXHJcbiAgICB2YXIgciA9IGEuY21wKGIpO1xyXG4gICAgaWYgKHIgPCAwKSB7XHJcbiAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxyXG4gICAgICB2YXIgdCA9IGE7XHJcbiAgICAgIGEgPSBiO1xyXG4gICAgICBiID0gdDtcclxuICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYS5pc3ViKGIpO1xyXG4gIH0gd2hpbGUgKHRydWUpO1xyXG5cclxuICByZXR1cm4gYi5pc2hsbihzaGlmdCk7XHJcbn07XHJcblxyXG4vLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcclxuQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKG51bSkge1xyXG4gIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLm1vZChudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xyXG59O1xyXG5cclxuLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxyXG5CTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbihudW0pIHtcclxuICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcclxufTtcclxuXHJcbi8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcclxuQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24oYml0KSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcclxuICB2YXIgciA9IGJpdCAlIDI2O1xyXG4gIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XHJcbiAgdmFyIHEgPSAxIDw8IHI7XHJcblxyXG4gIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXHJcbiAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcclxuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aDsgaSA8IHMgKyAxOyBpKyspXHJcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xyXG4gICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xyXG4gICAgdGhpcy5sZW5ndGggPSBzICsgMTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcclxuICB2YXIgY2FycnkgPSBxO1xyXG4gIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xyXG4gICAgdyArPSBjYXJyeTtcclxuICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XHJcbiAgICB3ICY9IDB4M2ZmZmZmZjtcclxuICAgIHRoaXMud29yZHNbaV0gPSB3O1xyXG4gIH1cclxuICBpZiAoY2FycnkgIT09IDApIHtcclxuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcclxuICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuKG51bSkge1xyXG4gIHZhciBzaWduID0gbnVtIDwgMDtcclxuICBpZiAoc2lnbilcclxuICAgIG51bSA9IC1udW07XHJcblxyXG4gIGlmICh0aGlzLnNpZ24gJiYgIXNpZ24pXHJcbiAgICByZXR1cm4gLTE7XHJcbiAgZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBzaWduKVxyXG4gICAgcmV0dXJuIDE7XHJcblxyXG4gIG51bSAmPSAweDNmZmZmZmY7XHJcbiAgdGhpcy5zdHJpcCgpO1xyXG5cclxuICB2YXIgcmVzO1xyXG4gIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcclxuICAgIHJlcyA9IDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXTtcclxuICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xyXG4gIH1cclxuICBpZiAodGhpcy5zaWduKVxyXG4gICAgcmVzID0gLXJlcztcclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxyXG4vLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcclxuLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxyXG4vLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXHJcbkJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAobnVtKSB7XHJcbiAgaWYgKHRoaXMuc2lnbiAmJiAhbnVtLnNpZ24pXHJcbiAgICByZXR1cm4gLTE7XHJcbiAgZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBudW0uc2lnbilcclxuICAgIHJldHVybiAxO1xyXG5cclxuICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XHJcbiAgaWYgKHRoaXMuc2lnbilcclxuICAgIHJldHVybiAtcmVzO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vLyBVbnNpZ25lZCBjb21wYXJpc29uXHJcbkJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcChudW0pIHtcclxuICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cclxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxyXG4gICAgcmV0dXJuIDE7XHJcbiAgZWxzZSBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKVxyXG4gICAgcmV0dXJuIC0xO1xyXG5cclxuICB2YXIgcmVzID0gMDtcclxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldO1xyXG4gICAgdmFyIGIgPSBudW0ud29yZHNbaV07XHJcblxyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgaWYgKGEgPCBiKVxyXG4gICAgICByZXMgPSAtMTtcclxuICAgIGVsc2UgaWYgKGEgPiBiKVxyXG4gICAgICByZXMgPSAxO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vL1xyXG4vLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xyXG4vLyBvbiB0aGUgYG1gIGl0c2VsZi5cclxuLy9cclxuQk4ucmVkID0gZnVuY3Rpb24gcmVkKG51bSkge1xyXG4gIHJldHVybiBuZXcgUmVkKG51bSk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZChjdHgpIHtcclxuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xyXG4gIGFzc2VydCghdGhpcy5zaWduLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcclxuICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCgpIHtcclxuICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZChjdHgpIHtcclxuICB0aGlzLnJlZCA9IGN0eDtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkKGN0eCkge1xyXG4gIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XHJcbiAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkKG51bSkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcclxuICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQobnVtKSB7XHJcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcclxuICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YihudW0pIHtcclxuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViKG51bSkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwobnVtKSB7XHJcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xyXG4gIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwobnVtKSB7XHJcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xyXG4gIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsKG51bSkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcclxuICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xyXG4gIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyKCkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcclxuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcclxuICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyKCkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XHJcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XHJcbn07XHJcblxyXG4vLyBTcXVhcmUgcm9vdCBvdmVyIHBcclxuQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0KCkge1xyXG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XHJcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0oKSB7XHJcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcclxuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcclxuICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcclxufTtcclxuXHJcbi8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcclxuQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZygpIHtcclxuICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XHJcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XHJcbiAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcclxufTtcclxuXHJcbkJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cobnVtKSB7XHJcbiAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcclxuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcclxuICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XHJcbn07XHJcblxyXG4vLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxyXG52YXIgcHJpbWVzID0ge1xyXG4gIGsyNTY6IG51bGwsXHJcbiAgcDIyNDogbnVsbCxcclxuICBwMTkyOiBudWxsLFxyXG4gIHAyNTUxOTogbnVsbFxyXG59O1xyXG5cclxuLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXHJcbmZ1bmN0aW9uIE1QcmltZShuYW1lLCBwKSB7XHJcbiAgLy8gUCA9IDIgXiBOIC0gS1xyXG4gIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcclxuICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XHJcbiAgdGhpcy5rID0gbmV3IEJOKDEpLmlzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xyXG5cclxuICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xyXG59XHJcblxyXG5NUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wKCkge1xyXG4gIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XHJcbiAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xyXG4gIHJldHVybiB0bXA7XHJcbn07XHJcblxyXG5NUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlKG51bSkge1xyXG4gIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcclxuICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXHJcbiAgdmFyIHIgPSBudW07XHJcbiAgdmFyIHJsZW47XHJcblxyXG4gIGRvIHtcclxuICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xyXG4gICAgciA9IHRoaXMuaW11bEsocik7XHJcbiAgICByID0gci5pYWRkKHRoaXMudG1wKTtcclxuICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xyXG4gIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xyXG5cclxuICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XHJcbiAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgci53b3Jkc1swXSA9IDA7XHJcbiAgICByLmxlbmd0aCA9IDE7XHJcbiAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICByLmlzdWIodGhpcy5wKTtcclxuICB9IGVsc2Uge1xyXG4gICAgci5zdHJpcCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5NUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dCkge1xyXG4gIGlucHV0LmlzaHJuKHRoaXMubiwgMCwgb3V0KTtcclxufTtcclxuXHJcbk1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcclxuICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEsyNTYoKSB7XHJcbiAgTVByaW1lLmNhbGwoXHJcbiAgICB0aGlzLFxyXG4gICAgJ2syNTYnLFxyXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XHJcbn1cclxuaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcclxuXHJcbksyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dHB1dCkge1xyXG4gIC8vIDI1NiA9IDkgKiAyNiArIDIyXHJcbiAgdmFyIG1hc2sgPSAweDNmZmZmZjtcclxuXHJcbiAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcclxuICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xyXG4gIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XHJcblxyXG4gIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xyXG4gICAgaW5wdXQud29yZHNbMF0gPSAwO1xyXG4gICAgaW5wdXQubGVuZ3RoID0gMTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFNoaWZ0IGJ5IDkgbGltYnNcclxuICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xyXG4gIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XHJcblxyXG4gIGZvciAodmFyIGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldO1xyXG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcclxuICAgIHByZXYgPSBuZXh0O1xyXG4gIH1cclxuICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldiA+Pj4gMjI7XHJcbiAgaW5wdXQubGVuZ3RoIC09IDk7XHJcbn07XHJcblxyXG5LMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLKG51bSkge1xyXG4gIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxyXG4gIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XHJcbiAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XHJcbiAgbnVtLmxlbmd0aCArPSAyO1xyXG5cclxuICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxyXG4gIHZhciBoaTtcclxuICB2YXIgbG8gPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdyA9IG51bS53b3Jkc1tpXTtcclxuICAgIGhpID0gdyAqIDB4NDA7XHJcbiAgICBsbyArPSB3ICogMHgzZDE7XHJcbiAgICBoaSArPSAobG8gLyAweDQwMDAwMDApIHwgMDtcclxuICAgIGxvICY9IDB4M2ZmZmZmZjtcclxuXHJcbiAgICBudW0ud29yZHNbaV0gPSBsbztcclxuXHJcbiAgICBsbyA9IGhpO1xyXG4gIH1cclxuXHJcbiAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXHJcbiAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcclxuICAgIG51bS5sZW5ndGgtLTtcclxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKVxyXG4gICAgICBudW0ubGVuZ3RoLS07XHJcbiAgfVxyXG4gIHJldHVybiBudW07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBQMjI0KCkge1xyXG4gIE1QcmltZS5jYWxsKFxyXG4gICAgdGhpcyxcclxuICAgICdwMjI0JyxcclxuICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xyXG59XHJcbmluaGVyaXRzKFAyMjQsIE1QcmltZSk7XHJcblxyXG5mdW5jdGlvbiBQMTkyKCkge1xyXG4gIE1QcmltZS5jYWxsKFxyXG4gICAgdGhpcyxcclxuICAgICdwMTkyJyxcclxuICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xyXG59XHJcbmluaGVyaXRzKFAxOTIsIE1QcmltZSk7XHJcblxyXG5mdW5jdGlvbiBQMjU1MTkoKSB7XHJcbiAgLy8gMiBeIDI1NSAtIDE5XHJcbiAgTVByaW1lLmNhbGwoXHJcbiAgICB0aGlzLFxyXG4gICAgJzI1NTE5JyxcclxuICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XHJcbn1cclxuaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xyXG5cclxuUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLKG51bSkge1xyXG4gIC8vIEsgPSAweDEzXHJcbiAgdmFyIGNhcnJ5ID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGhpID0gbnVtLndvcmRzW2ldICogMHgxMyArIGNhcnJ5O1xyXG4gICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XHJcbiAgICBoaSA+Pj49IDI2O1xyXG5cclxuICAgIG51bS53b3Jkc1tpXSA9IGxvO1xyXG4gICAgY2FycnkgPSBoaTtcclxuICB9XHJcbiAgaWYgKGNhcnJ5ICE9PSAwKVxyXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcclxuICByZXR1cm4gbnVtO1xyXG59O1xyXG5cclxuLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXHJcbkJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lKG5hbWUpIHtcclxuICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxyXG4gIGlmIChwcmltZXNbbmFtZV0pXHJcbiAgICByZXR1cm4gcHJpbWVzW25hbWVdO1xyXG5cclxuICB2YXIgcHJpbWU7XHJcbiAgaWYgKG5hbWUgPT09ICdrMjU2JylcclxuICAgIHByaW1lID0gbmV3IEsyNTYoKTtcclxuICBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpXHJcbiAgICBwcmltZSA9IG5ldyBQMjI0KCk7XHJcbiAgZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKVxyXG4gICAgcHJpbWUgPSBuZXcgUDE5MigpO1xyXG4gIGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKVxyXG4gICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XHJcbiAgZWxzZVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcclxuICBwcmltZXNbbmFtZV0gPSBwcmltZTtcclxuXHJcbiAgcmV0dXJuIHByaW1lO1xyXG59O1xyXG5cclxuLy9cclxuLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXHJcbi8vXHJcbmZ1bmN0aW9uIFJlZChtKSB7XHJcbiAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xyXG4gICAgdGhpcy5tID0gcHJpbWUucDtcclxuICAgIHRoaXMucHJpbWUgPSBwcmltZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5tID0gbTtcclxuICAgIHRoaXMucHJpbWUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxKGEpIHtcclxuICBhc3NlcnQoIWEuc2lnbiwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XHJcbiAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyKGEsIGIpIHtcclxuICBhc3NlcnQoIWEuc2lnbiAmJiAhYi5zaWduLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcclxuICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxyXG4gICAgICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZChhKSB7XHJcbiAgaWYgKHRoaXMucHJpbWUpXHJcbiAgICByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcclxuICByZXR1cm4gYS5tb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XHJcbn07XHJcblxyXG5SZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhhKSB7XHJcbiAgdmFyIHIgPSBhLmNsb25lKCk7XHJcbiAgci5zaWduID0gIXIuc2lnbjtcclxuICByZXR1cm4gci5pYWRkKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYSwgYikge1xyXG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XHJcblxyXG4gIHZhciByZXMgPSBhLmFkZChiKTtcclxuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXHJcbiAgICByZXMuaXN1Yih0aGlzLm0pO1xyXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChhLCBiKSB7XHJcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcclxuXHJcbiAgdmFyIHJlcyA9IGEuaWFkZChiKTtcclxuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXHJcbiAgICByZXMuaXN1Yih0aGlzLm0pO1xyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5SZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihhLCBiKSB7XHJcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcclxuXHJcbiAgdmFyIHJlcyA9IGEuc3ViKGIpO1xyXG4gIGlmIChyZXMuY21wbigwKSA8IDApXHJcbiAgICByZXMuaWFkZCh0aGlzLm0pO1xyXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihhLCBiKSB7XHJcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcclxuXHJcbiAgdmFyIHJlcyA9IGEuaXN1YihiKTtcclxuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxyXG4gICAgcmVzLmlhZGQodGhpcy5tKTtcclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwoYSwgbnVtKSB7XHJcbiAgdGhpcy5fdmVyaWZ5MShhKTtcclxuICByZXR1cm4gdGhpcy5pbW9kKGEuc2hsbihudW0pKTtcclxufTtcclxuXHJcblJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwoYSwgYikge1xyXG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XHJcbiAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoYSwgYikge1xyXG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XHJcbiAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XHJcbn07XHJcblxyXG5SZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKGEpIHtcclxuICByZXR1cm4gdGhpcy5pbXVsKGEsIGEpO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoYSkge1xyXG4gIHJldHVybiB0aGlzLm11bChhLCBhKTtcclxufTtcclxuXHJcblJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQoYSkge1xyXG4gIGlmIChhLmNtcG4oMCkgPT09IDApXHJcbiAgICByZXR1cm4gYS5jbG9uZSgpO1xyXG5cclxuICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcclxuICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xyXG5cclxuICAvLyBGYXN0IGNhc2VcclxuICBpZiAobW9kMyA9PT0gMykge1xyXG4gICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pc2hybigyKTtcclxuICAgIHZhciByID0gdGhpcy5wb3coYSwgcG93KTtcclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcbiAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxyXG4gIC8vXHJcbiAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcclxuICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xyXG4gIHZhciBzID0gMDtcclxuICB3aGlsZSAocS5jbXBuKDApICE9PSAwICYmIHEuYW5kbG4oMSkgPT09IDApIHtcclxuICAgIHMrKztcclxuICAgIHEuaXNocm4oMSk7XHJcbiAgfVxyXG4gIGFzc2VydChxLmNtcG4oMCkgIT09IDApO1xyXG5cclxuICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xyXG4gIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xyXG5cclxuICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxyXG4gIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxyXG4gIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXNocm4oMSk7XHJcbiAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XHJcbiAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xyXG4gIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApXHJcbiAgICB6LnJlZElBZGQobk9uZSk7XHJcblxyXG4gIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XHJcbiAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXNocm4oMSkpO1xyXG4gIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XHJcbiAgdmFyIG0gPSBzO1xyXG4gIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XHJcbiAgICB2YXIgdG1wID0gdDtcclxuICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKylcclxuICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xyXG4gICAgYXNzZXJ0KGkgPCBtKTtcclxuICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLmlzaGxuKG0gLSBpIC0gMSkpO1xyXG5cclxuICAgIHIgPSByLnJlZE11bChiKTtcclxuICAgIGMgPSBiLnJlZFNxcigpO1xyXG4gICAgdCA9IHQucmVkTXVsKGMpO1xyXG4gICAgbSA9IGk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcjtcclxufTtcclxuXHJcblJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xyXG4gIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xyXG4gIGlmIChpbnYuc2lnbikge1xyXG4gICAgaW52LnNpZ24gPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xyXG4gIH1cclxufTtcclxuXHJcblJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KGEsIG51bSkge1xyXG4gIHZhciB3ID0gW107XHJcblxyXG4gIGlmIChudW0uY21wbigwKSA9PT0gMClcclxuICAgIHJldHVybiBuZXcgQk4oMSk7XHJcblxyXG4gIHZhciBxID0gbnVtLmNsb25lKCk7XHJcblxyXG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDApIHtcclxuICAgIHcucHVzaChxLmFuZGxuKDEpKTtcclxuICAgIHEuaXNocm4oMSk7XHJcbiAgfVxyXG5cclxuICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXHJcbiAgdmFyIHJlcyA9IGE7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSB0aGlzLnNxcihyZXMpKVxyXG4gICAgaWYgKHdbaV0gIT09IDApXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcclxuICAgIGZvciAodmFyIHEgPSB0aGlzLnNxcihyZXMpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHRoaXMuc3FyKHEpKSB7XHJcbiAgICAgIGlmICh3W2ldID09PSAwKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICByZXMgPSB0aGlzLm11bChyZXMsIHEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcblJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKG51bSkge1xyXG4gIHZhciByID0gbnVtLm1vZCh0aGlzLm0pO1xyXG4gIGlmIChyID09PSBudW0pXHJcbiAgICByZXR1cm4gci5jbG9uZSgpO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xyXG4gIHZhciByZXMgPSBudW0uY2xvbmUoKTtcclxuICByZXMucmVkID0gbnVsbDtcclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLy9cclxuLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXHJcbi8vXHJcblxyXG5CTi5tb250ID0gZnVuY3Rpb24gbW9udChudW0pIHtcclxuICByZXR1cm4gbmV3IE1vbnQobnVtKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIE1vbnQobSkge1xyXG4gIFJlZC5jYWxsKHRoaXMsIG0pO1xyXG5cclxuICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xyXG4gIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApXHJcbiAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XHJcbiAgdGhpcy5yID0gbmV3IEJOKDEpLmlzaGxuKHRoaXMuc2hpZnQpO1xyXG4gIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcclxuICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XHJcblxyXG4gIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcclxuICB0aGlzLm1pbnYuc2lnbiA9IHRydWU7XHJcbiAgdGhpcy5taW52ID0gdGhpcy5taW52Lm1vZCh0aGlzLnIpO1xyXG59XHJcbmluaGVyaXRzKE1vbnQsIFJlZCk7XHJcblxyXG5Nb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8obnVtKSB7XHJcbiAgcmV0dXJuIHRoaXMuaW1vZChudW0uc2hsbih0aGlzLnNoaWZ0KSk7XHJcbn07XHJcblxyXG5Nb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xyXG4gIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XHJcbiAgci5yZWQgPSBudWxsO1xyXG4gIHJldHVybiByO1xyXG59O1xyXG5cclxuTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwoYSwgYikge1xyXG4gIGlmIChhLmNtcG4oMCkgPT09IDAgfHwgYi5jbXBuKDApID09PSAwKSB7XHJcbiAgICBhLndvcmRzWzBdID0gMDtcclxuICAgIGEubGVuZ3RoID0gMTtcclxuICAgIHJldHVybiBhO1xyXG4gIH1cclxuXHJcbiAgdmFyIHQgPSBhLmltdWwoYik7XHJcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcclxuICB2YXIgdSA9IHQuaXN1YihjKS5pc2hybih0aGlzLnNoaWZ0KTtcclxuICB2YXIgcmVzID0gdTtcclxuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxyXG4gICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XHJcbiAgZWxzZSBpZiAodS5jbXBuKDApIDwgMClcclxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xyXG5cclxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcclxufTtcclxuXHJcbk1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChhLCBiKSB7XHJcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApXHJcbiAgICByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcclxuXHJcbiAgdmFyIHQgPSBhLm11bChiKTtcclxuICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xyXG4gIHZhciB1ID0gdC5pc3ViKGMpLmlzaHJuKHRoaXMuc2hpZnQpO1xyXG4gIHZhciByZXMgPSB1O1xyXG4gIGlmICh1LmNtcCh0aGlzLm0pID49IDApXHJcbiAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcclxuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxyXG4gICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XHJcblxyXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xyXG59O1xyXG5cclxuTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xyXG4gIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcclxuICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcclxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcclxufTtcclxuXHJcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XHJcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxuXHJcbmV4cG9ydHMudGFnQ2xhc3MgPSB7XHJcbiAgMDogJ3VuaXZlcnNhbCcsXHJcbiAgMTogJ2FwcGxpY2F0aW9uJyxcclxuICAyOiAnY29udGV4dCcsXHJcbiAgMzogJ3ByaXZhdGUnXHJcbn07XHJcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XHJcblxyXG5leHBvcnRzLnRhZyA9IHtcclxuICAweDAwOiAnZW5kJyxcclxuICAweDAxOiAnYm9vbCcsXHJcbiAgMHgwMjogJ2ludCcsXHJcbiAgMHgwMzogJ2JpdHN0cicsXHJcbiAgMHgwNDogJ29jdHN0cicsXHJcbiAgMHgwNTogJ251bGxfJyxcclxuICAweDA2OiAnb2JqaWQnLFxyXG4gIDB4MDc6ICdvYmpEZXNjJyxcclxuICAweDA4OiAnZXh0ZXJuYWwnLFxyXG4gIDB4MDk6ICdyZWFsJyxcclxuICAweDBhOiAnZW51bScsXHJcbiAgMHgwYjogJ2VtYmVkJyxcclxuICAweDBjOiAndXRmOHN0cicsXHJcbiAgMHgwZDogJ3JlbGF0aXZlT2lkJyxcclxuICAweDEwOiAnc2VxJyxcclxuICAweDExOiAnc2V0JyxcclxuICAweDEyOiAnbnVtc3RyJyxcclxuICAweDEzOiAncHJpbnRzdHInLFxyXG4gIDB4MTQ6ICd0NjFzdHInLFxyXG4gIDB4MTU6ICd2aWRlb3N0cicsXHJcbiAgMHgxNjogJ2lhNXN0cicsXHJcbiAgMHgxNzogJ3V0Y3RpbWUnLFxyXG4gIDB4MTg6ICdnZW50aW1lJyxcclxuICAweDE5OiAnZ3JhcGhzdHInLFxyXG4gIDB4MWE6ICdpc282NDZzdHInLFxyXG4gIDB4MWI6ICdnZW5zdHInLFxyXG4gIDB4MWM6ICd1bmlzdHInLFxyXG4gIDB4MWQ6ICdjaGFyc3RyJyxcclxuICAweDFlOiAnYm1wc3RyJ1xyXG59O1xyXG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XHJcbiIsInZhciBjb25zdGFudHMgPSBleHBvcnRzO1xyXG5cclxuLy8gSGVscGVyXHJcbmNvbnN0YW50cy5fcmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobWFwKSB7XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG5cclxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAvLyBDb252ZXJ0IGtleSB0byBpbnRlZ2VyIGlmIGl0IGlzIHN0cmluZ2lmaWVkXHJcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcclxuICAgICAga2V5ID0ga2V5IHwgMDtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcclxuICAgIHJlc1t2YWx1ZV0gPSBrZXk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5jb25zdGFudHMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcclxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG5cclxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XHJcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xyXG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XHJcblxyXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xyXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xyXG5cclxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcclxuICB0aGlzLmVuYyA9ICdkZXInO1xyXG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xyXG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xyXG5cclxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXHJcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcclxuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IERFUkRlY29kZXI7XHJcblxyXG5ERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xyXG4gIGlmICghKGRhdGEgaW5zdGFuY2VvZiBiYXNlLkRlY29kZXJCdWZmZXIpKVxyXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XHJcblxyXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8vIFRyZWUgbWV0aG9kc1xyXG5cclxuZnVuY3Rpb24gREVSTm9kZShwYXJlbnQpIHtcclxuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcclxufVxyXG5pbmhlcml0cyhERVJOb2RlLCBiYXNlLk5vZGUpO1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcclxuICBpZiAoYnVmZmVyLmlzRW1wdHkoKSlcclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcclxuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xyXG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcclxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xyXG5cclxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XHJcblxyXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHwgYW55O1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRhZyA9IGZ1bmN0aW9uIGRlY29kZVRhZyhidWZmZXIsIHRhZywgYW55KSB7XHJcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZGVjb2RlIHRhZyBvZiBcIicgKyB0YWcgKyAnXCInKTtcclxuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXHJcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcclxuXHJcbiAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkVGFnLnByaW1pdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGxlbmd0aCBvZiBcIicgKyB0YWcgKyAnXCInKTtcclxuXHJcbiAgLy8gRmFpbHVyZVxyXG4gIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxyXG4gICAgcmV0dXJuIGxlbjtcclxuXHJcbiAgaWYgKCFhbnkgJiZcclxuICAgICAgZGVjb2RlZFRhZy50YWcgIT09IHRhZyAmJlxyXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciAhPT0gdGFnICYmXHJcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICsgJ29mJyAhPT0gdGFnKSB7XHJcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdGYWlsZWQgdG8gbWF0Y2ggdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcclxuICB9XHJcblxyXG4gIGlmIChkZWNvZGVkVGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXHJcbiAgICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xyXG5cclxuICAvLyBJbmRlZmluaXRlIGxlbmd0aC4uLiBmaW5kIEVORCB0YWdcclxuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xyXG4gIHZhciByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoXHJcbiAgICAgIGJ1ZmZlcixcclxuICAgICAgJ0ZhaWxlZCB0byBza2lwIGluZGVmaW5pdGUgbGVuZ3RoIGJvZHk6IFwiJyArIHRoaXMudGFnICsgJ1wiJyk7XHJcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXHJcbiAgICByZXR1cm4gcmVzO1xyXG5cclxuICBsZW4gPSBidWZmZXIub2Zmc2V0IC0gc3RhdGUub2Zmc2V0O1xyXG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcclxuICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBVbnRpbEVuZCA9IGZ1bmN0aW9uIHNraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpIHtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xyXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHRhZykpXHJcbiAgICAgIHJldHVybiB0YWc7XHJcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XHJcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcclxuICAgICAgcmV0dXJuIGxlbjtcclxuXHJcbiAgICB2YXIgcmVzO1xyXG4gICAgaWYgKHRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxyXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXHJcbiAgICBlbHNlXHJcbiAgICAgIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpO1xyXG5cclxuICAgIC8vIEZhaWx1cmVcclxuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxyXG4gICAgICByZXR1cm4gcmVzO1xyXG5cclxuICAgIGlmICh0YWcudGFnU3RyID09PSAnZW5kJylcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUxpc3QgPSBmdW5jdGlvbiBkZWNvZGVMaXN0KGJ1ZmZlciwgdGFnLCBkZWNvZGVyKSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xyXG4gICAgdmFyIHBvc3NpYmxlRW5kID0gdGhpcy5fcGVla1RhZyhidWZmZXIsICdlbmQnKTtcclxuICAgIGlmIChidWZmZXIuaXNFcnJvcihwb3NzaWJsZUVuZCkpXHJcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcclxuXHJcbiAgICB2YXIgcmVzID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLCAnZGVyJyk7XHJcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcclxuICAgICAgYnJlYWs7XHJcbiAgICByZXN1bHQucHVzaChyZXMpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVN0ciA9IGZ1bmN0aW9uIGRlY29kZVN0cihidWZmZXIsIHRhZykge1xyXG4gIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XHJcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xyXG4gIH0gZWxzZSBpZiAodGFnID09PSAnYml0c3RyJykge1xyXG4gICAgdmFyIHVudXNlZCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcclxuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxyXG4gICAgICByZXR1cm4gdW51c2VkO1xyXG5cclxuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lhNXN0cicgfHwgdGFnID09PSAndXRmOHN0cicpIHtcclxuICAgIHJldHVybiBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICsgJyB1bnN1cHBvcnRlZCcpO1xyXG4gIH1cclxufTtcclxuXHJcbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xyXG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xyXG4gIHZhciBpZGVudCA9IDA7XHJcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XHJcbiAgICB2YXIgc3ViaWRlbnQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XHJcbiAgICBpZGVudCA8PD0gNztcclxuICAgIGlkZW50IHw9IHN1YmlkZW50ICYgMHg3ZjtcclxuICAgIGlmICgoc3ViaWRlbnQgJiAweDgwKSA9PT0gMCkge1xyXG4gICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcclxuICAgICAgaWRlbnQgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoc3ViaWRlbnQgJiAweDgwKVxyXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XHJcblxyXG4gIHZhciBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XHJcbiAgdmFyIHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XHJcblxyXG4gIGlmIChyZWxhdGl2ZSlcclxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xyXG4gIGVsc2VcclxuICAgIHJlc3VsdCA9IFtmaXJzdCwgc2Vjb25kXS5jb25jYXQoaWRlbnRpZmllcnMuc2xpY2UoMSkpO1xyXG5cclxuICBpZiAodmFsdWVzKVxyXG4gICAgcmVzdWx0ID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcgJyldO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRpbWUgPSBmdW5jdGlvbiBkZWNvZGVUaW1lKGJ1ZmZlciwgdGFnKSB7XHJcbiAgdmFyIHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xyXG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xyXG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgNCkgfCAwO1xyXG4gICAgdmFyIG1vbiA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XHJcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcclxuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XHJcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xyXG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3V0Y3RpbWUnKSB7XHJcbiAgICB2YXIgeWVhciA9IHN0ci5zbGljZSgwLCAyKSB8IDA7XHJcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcclxuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xyXG4gICAgdmFyIGhvdXIgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xyXG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xyXG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcclxuICAgIGlmICh5ZWFyIDwgNzApXHJcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcclxuICAgIGVsc2VcclxuICAgICAgeWVhciA9IDE5MDAgKyB5ZWFyO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdGhpcy5lcnJvcignRGVjb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIERhdGUuVVRDKHllYXIsIG1vbiAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU51bGwgPSBmdW5jdGlvbiBkZWNvZGVOdWxsKGJ1ZmZlcikge1xyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUJvb2wgPSBmdW5jdGlvbiBkZWNvZGVCb29sKGJ1ZmZlcikge1xyXG4gIHZhciByZXMgPSBidWZmZXIucmVhZFVJbnQ4KCk7XHJcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiByZXMgIT09IDA7XHJcbn07XHJcblxyXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XHJcbiAgLy8gQmlnaW50LCByZXR1cm4gYXMgaXQgaXMgKGFzc3VtZSBiaWcgZW5kaWFuKVxyXG4gIHZhciByYXcgPSBidWZmZXIucmF3KCk7XHJcbiAgdmFyIHJlcyA9IG5ldyBiaWdudW0ocmF3KTtcclxuXHJcbiAgaWYgKHZhbHVlcylcclxuICAgIHJlcyA9IHZhbHVlc1tyZXMudG9TdHJpbmcoMTApXSB8fCByZXM7XHJcblxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XHJcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXHJcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcclxuICByZXR1cm4gZW50aXR5Ll9nZXREZWNvZGVyKCdkZXInKS50cmVlO1xyXG59O1xyXG5cclxuLy8gVXRpbGl0eSBtZXRob2RzXHJcblxyXG5mdW5jdGlvbiBkZXJEZWNvZGVUYWcoYnVmLCBmYWlsKSB7XHJcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XHJcbiAgaWYgKGJ1Zi5pc0Vycm9yKHRhZykpXHJcbiAgICByZXR1cm4gdGFnO1xyXG5cclxuICB2YXIgY2xzID0gZGVyLnRhZ0NsYXNzW3RhZyA+PiA2XTtcclxuICB2YXIgcHJpbWl0aXZlID0gKHRhZyAmIDB4MjApID09PSAwO1xyXG5cclxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXHJcbiAgaWYgKCh0YWcgJiAweDFmKSA9PT0gMHgxZikge1xyXG4gICAgdmFyIG9jdCA9IHRhZztcclxuICAgIHRhZyA9IDA7XHJcbiAgICB3aGlsZSAoKG9jdCAmIDB4ODApID09PSAweDgwKSB7XHJcbiAgICAgIG9jdCA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XHJcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxyXG4gICAgICAgIHJldHVybiBvY3Q7XHJcblxyXG4gICAgICB0YWcgPDw9IDc7XHJcbiAgICAgIHRhZyB8PSBvY3QgJiAweDdmO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0YWcgJj0gMHgxZjtcclxuICB9XHJcbiAgdmFyIHRhZ1N0ciA9IGRlci50YWdbdGFnXTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNsczogY2xzLFxyXG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXHJcbiAgICB0YWc6IHRhZyxcclxuICAgIHRhZ1N0cjogdGFnU3RyXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVyRGVjb2RlTGVuKGJ1ZiwgcHJpbWl0aXZlLCBmYWlsKSB7XHJcbiAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XHJcbiAgaWYgKGJ1Zi5pc0Vycm9yKGxlbikpXHJcbiAgICByZXR1cm4gbGVuO1xyXG5cclxuICAvLyBJbmRlZmluaXRlIGZvcm1cclxuICBpZiAoIXByaW1pdGl2ZSAmJiBsZW4gPT09IDB4ODApXHJcbiAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgLy8gRGVmaW5pdGUgZm9ybVxyXG4gIGlmICgobGVuICYgMHg4MCkgPT09IDApIHtcclxuICAgIC8vIFNob3J0IGZvcm1cclxuICAgIHJldHVybiBsZW47XHJcbiAgfVxyXG5cclxuICAvLyBMb25nIGZvcm1cclxuICB2YXIgbnVtID0gbGVuICYgMHg3ZjtcclxuICBpZiAobnVtID49IDQpXHJcbiAgICByZXR1cm4gYnVmLmVycm9yKCdsZW5ndGggb2N0ZWN0IGlzIHRvbyBsb25nJyk7XHJcblxyXG4gIGxlbiA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xyXG4gICAgbGVuIDw8PSA4O1xyXG4gICAgdmFyIGogPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xyXG4gICAgaWYgKGJ1Zi5pc0Vycm9yKGopKVxyXG4gICAgICByZXR1cm4gajtcclxuICAgIGxlbiB8PSBqO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxlbjtcclxufVxyXG4iLCJ2YXIgZGVjb2RlcnMgPSBleHBvcnRzO1xyXG5cclxuZGVjb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcclxuZGVjb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcclxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xyXG5cclxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XHJcbnZhciBERVJEZWNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcclxuXHJcbmZ1bmN0aW9uIFBFTURlY29kZXIoZW50aXR5KSB7XHJcbiAgREVSRGVjb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XHJcbiAgdGhpcy5lbmMgPSAncGVtJztcclxufTtcclxuaW5oZXJpdHMoUEVNRGVjb2RlciwgREVSRGVjb2Rlcik7XHJcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcclxuXHJcblBFTURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XHJcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XHJcblxyXG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgdmFyIHJlID0gL14tLS0tLShCRUdJTnxFTkQpIChbXi1dKyktLS0tLSQvO1xyXG4gIHZhciBzdGFydCA9IC0xO1xyXG4gIHZhciBlbmQgPSAtMTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBsaW5lc1tpXS5tYXRjaChyZSk7XHJcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXHJcbiAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXHJcbiAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcclxuICAgICAgaWYgKG1hdGNoWzFdICE9PSAnQkVHSU4nKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBzdGFydCA9IGk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdFTkQnKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBlbmQgPSBpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xyXG5cclxuICB2YXIgYmFzZTY0ID0gbGluZXMuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLmpvaW4oJycpO1xyXG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xyXG4gIGJhc2U2NC5yZXBsYWNlKC9bXmEtejAtOVxcK1xcLz1dKy9naSwgJycpO1xyXG5cclxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xyXG4gIHJldHVybiBERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCBpbnB1dCwgb3B0aW9ucyk7XHJcbn07XHJcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcclxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcclxuXHJcbnZhciBhc24xID0gcmVxdWlyZSgnLi4vYXNuMScpO1xyXG52YXIgYmFzZSA9IGFzbjEuYmFzZTtcclxudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xyXG5cclxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcclxudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcclxuXHJcbmZ1bmN0aW9uIERFUkVuY29kZXIoZW50aXR5KSB7XHJcbiAgdGhpcy5lbmMgPSAnZGVyJztcclxuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcclxuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcclxuXHJcbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxyXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XHJcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBERVJFbmNvZGVyO1xyXG5cclxuREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyKSB7XHJcbiAgcmV0dXJuIHRoaXMudHJlZS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKS5qb2luKCk7XHJcbn07XHJcblxyXG4vLyBUcmVlIG1ldGhvZHNcclxuXHJcbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XHJcbiAgYmFzZS5Ob2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XHJcbn1cclxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcclxuXHJcbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xyXG4gIHZhciBlbmNvZGVkVGFnID0gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHRoaXMucmVwb3J0ZXIpO1xyXG5cclxuICAvLyBTaG9ydCBmb3JtXHJcbiAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgMHg4MCkge1xyXG4gICAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMik7XHJcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xyXG4gICAgaGVhZGVyWzFdID0gY29udGVudC5sZW5ndGg7XHJcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcclxuICB9XHJcblxyXG4gIC8vIExvbmcgZm9ybVxyXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcclxuICB2YXIgbGVuT2N0ZXRzID0gMTtcclxuICBmb3IgKHZhciBpID0gY29udGVudC5sZW5ndGg7IGkgPj0gMHgxMDA7IGkgPj49IDgpXHJcbiAgICBsZW5PY3RldHMrKztcclxuXHJcbiAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMSArIDEgKyBsZW5PY3RldHMpO1xyXG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XHJcbiAgaGVhZGVyWzFdID0gMHg4MCB8IGxlbk9jdGV0cztcclxuXHJcbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcclxuICAgIGhlYWRlcltpXSA9IGogJiAweGZmO1xyXG5cclxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcclxufTtcclxuXHJcbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcclxuICBpZiAodGFnID09PSAnb2N0c3RyJylcclxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XHJcbiAgZWxzZSBpZiAodGFnID09PSAnYml0c3RyJylcclxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgc3RyLnVudXNlZCB8IDAsIHN0ci5kYXRhIF0pO1xyXG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2lhNXN0cicgfHwgdGFnID09PSAndXRmOHN0cicpXHJcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xyXG4gIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB1bnN1cHBvcnRlZCcpO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZU9iamlkID0gZnVuY3Rpb24gZW5jb2RlT2JqaWQoaWQsIHZhbHVlcywgcmVsYXRpdmUpIHtcclxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKCF2YWx1ZXMpXHJcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdzdHJpbmcgb2JqaWQgZ2l2ZW4sIGJ1dCBubyB2YWx1ZXMgbWFwIGZvdW5kJyk7XHJcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShpZCkpXHJcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xyXG4gICAgaWQgPSB2YWx1ZXNbaWRdLnNwbGl0KC9bXFxzXFwuXSsvZyk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKVxyXG4gICAgICBpZFtpXSB8PSAwO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcclxuICAgIGlkID0gaWQuc2xpY2UoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXHJcbiAgICAgIGlkW2ldIHw9IDA7XHJcbiAgfVxyXG5cclxuICBpZiAoIUFycmF5LmlzQXJyYXkoaWQpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQoKSBzaG91bGQgYmUgZWl0aGVyIGFycmF5IG9yIHN0cmluZywgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcclxuICB9XHJcblxyXG4gIGlmICghcmVsYXRpdmUpIHtcclxuICAgIGlmIChpZFsxXSA+PSA0MClcclxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1NlY29uZCBvYmppZCBpZGVudGlmaWVyIE9PQicpO1xyXG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XHJcbiAgfVxyXG5cclxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXHJcbiAgdmFyIHNpemUgPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBpZGVudCA9IGlkW2ldO1xyXG4gICAgZm9yIChzaXplKys7IGlkZW50ID49IDB4ODA7IGlkZW50ID4+PSA3KVxyXG4gICAgICBzaXplKys7XHJcbiAgfVxyXG5cclxuICB2YXIgb2JqaWQgPSBuZXcgQnVmZmVyKHNpemUpO1xyXG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xyXG4gIGZvciAodmFyIGkgPSBpZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgdmFyIGlkZW50ID0gaWRbaV07XHJcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XHJcbiAgICB3aGlsZSAoKGlkZW50ID4+PSA3KSA+IDApXHJcbiAgICAgIG9iamlkW29mZnNldC0tXSA9IDB4ODAgfCAoaWRlbnQgJiAweDdmKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG9iamlkKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHR3byhudW0pIHtcclxuICBpZiAobnVtIDwgMTApXHJcbiAgICByZXR1cm4gJzAnICsgbnVtO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBudW07XHJcbn1cclxuXHJcbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcclxuICB2YXIgc3RyO1xyXG4gIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XHJcblxyXG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xyXG4gICAgc3RyID0gW1xyXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcclxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxyXG4gICAgICB0d28oZGF0ZS5nZXRVVENEYXRlKCkpLFxyXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcclxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcclxuICAgICAgdHdvKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSxcclxuICAgICAgJ1onXHJcbiAgICBdLmpvaW4oJycpO1xyXG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcclxuICAgIHN0ciA9IFtcclxuICAgICAgdHdvKGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCksXHJcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcclxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcclxuICAgICAgdHdvKGRhdGUuZ2V0VVRDSG91cnMoKSksXHJcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXHJcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXHJcbiAgICAgICdaJ1xyXG4gICAgXS5qb2luKCcnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihzdHIsICdvY3RzdHInKTtcclxufTtcclxuXHJcbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVOdWxsID0gZnVuY3Rpb24gZW5jb2RlTnVsbCgpIHtcclxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcignJyk7XHJcbn07XHJcblxyXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSwgdmFsdWVzKSB7XHJcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAoIXZhbHVlcylcclxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1N0cmluZyBpbnQgb3IgZW51bSBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAnKTtcclxuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1ZhbHVlcyBtYXAgZG9lc25cXCd0IGNvbnRhaW46ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShudW0pKTtcclxuICAgIH1cclxuICAgIG51bSA9IHZhbHVlc1tudW1dO1xyXG4gIH1cclxuXHJcbiAgLy8gQmlnbnVtLCBhc3N1bWUgYmlnIGVuZGlhblxyXG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyAmJiAhQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcclxuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XHJcbiAgICBpZiAobnVtLnNpZ24gPT09IGZhbHNlICYmIG51bUFycmF5WzBdICYgMHg4MCkge1xyXG4gICAgICBudW1BcnJheS51bnNoaWZ0KDApO1xyXG4gICAgfVxyXG4gICAgbnVtID0gbmV3IEJ1ZmZlcihudW1BcnJheSk7XHJcbiAgfVxyXG5cclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcclxuICAgIHZhciBzaXplID0gbnVtLmxlbmd0aDtcclxuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxyXG4gICAgICBzaXplKys7XHJcblxyXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XHJcbiAgICBudW0uY29weShvdXQpO1xyXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXHJcbiAgICAgIG91dFswXSA9IDBcclxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG91dCk7XHJcbiAgfVxyXG5cclxuICBpZiAobnVtIDwgMHg4MClcclxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG51bSk7XHJcblxyXG4gIGlmIChudW0gPCAweDEwMClcclxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFswLCBudW1dKTtcclxuXHJcbiAgdmFyIHNpemUgPSAxO1xyXG4gIGZvciAodmFyIGkgPSBudW07IGkgPj0gMHgxMDA7IGkgPj49IDgpXHJcbiAgICBzaXplKys7XHJcblxyXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgb3V0W2ldID0gbnVtICYgMHhmZjtcclxuICAgIG51bSA+Pj0gODtcclxuICB9XHJcbiAgaWYob3V0WzBdICYgMHg4MCkge1xyXG4gICAgb3V0LnVuc2hpZnQoMCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihuZXcgQnVmZmVyKG91dCkpO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUJvb2wgPSBmdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XHJcbn07XHJcblxyXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XHJcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXHJcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcclxuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xyXG59O1xyXG5cclxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcclxuICB2YXIgaTtcclxuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcclxuICBpZiAoc3RhdGUuZGVmYXVsdEJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgc3RhdGUuZGVmYXVsdEJ1ZmZlciA9IHRoaXMuX2VuY29kZVZhbHVlKHN0YXRlWydkZWZhdWx0J10sIHJlcG9ydGVyLCBwYXJlbnQpLmpvaW4oKTtcclxuXHJcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzdGF0ZS5kZWZhdWx0QnVmZmVyLmxlbmd0aClcclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgZm9yIChpPTA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgaWYgKGRhdGFbaV0gIT09IHN0YXRlLmRlZmF1bHRCdWZmZXJbaV0pXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vLyBVdGlsaXR5IG1ldGhvZHNcclxuXHJcbmZ1bmN0aW9uIGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCByZXBvcnRlcikge1xyXG4gIHZhciByZXM7XHJcblxyXG4gIGlmICh0YWcgPT09ICdzZXFvZicpXHJcbiAgICB0YWcgPSAnc2VxJztcclxuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXHJcbiAgICB0YWcgPSAnc2V0JztcclxuXHJcbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcclxuICAgIHJlcyA9IGRlci50YWdCeU5hbWVbdGFnXTtcclxuICBlbHNlIGlmICh0eXBlb2YgdGFnID09PSAnbnVtYmVyJyAmJiAodGFnIHwgMCkgPT09IHRhZylcclxuICAgIHJlcyA9IHRhZztcclxuICBlbHNlXHJcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vua25vd24gdGFnOiAnICsgdGFnKTtcclxuXHJcbiAgaWYgKHJlcyA+PSAweDFmKVxyXG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdNdWx0aS1vY3RldCB0YWcgZW5jb2RpbmcgdW5zdXBwb3J0ZWQnKTtcclxuXHJcbiAgaWYgKCFwcmltaXRpdmUpXHJcbiAgICByZXMgfD0gMHgyMDtcclxuXHJcbiAgcmVzIHw9IChkZXIudGFnQ2xhc3NCeU5hbWVbY2xzIHx8ICd1bml2ZXJzYWwnXSA8PCA2KTtcclxuXHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG4iLCJ2YXIgZW5jb2RlcnMgPSBleHBvcnRzO1xyXG5cclxuZW5jb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcclxuZW5jb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcclxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xyXG5cclxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XHJcbnZhciBERVJFbmNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcclxuXHJcbmZ1bmN0aW9uIFBFTUVuY29kZXIoZW50aXR5KSB7XHJcbiAgREVSRW5jb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XHJcbiAgdGhpcy5lbmMgPSAncGVtJztcclxufTtcclxuaW5oZXJpdHMoUEVNRW5jb2RlciwgREVSRW5jb2Rlcik7XHJcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcclxuXHJcblBFTUVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XHJcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xyXG5cclxuICB2YXIgcCA9IGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSA2NClcclxuICAgIG91dC5wdXNoKHAuc2xpY2UoaSwgaSArIDY0KSk7XHJcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XHJcbiAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMS9hc24xJyk7XHJcbnZhciBCTiA9IHJlcXVpcmUoJy4vYXNuMS9iaWdudW0vYm4nKTtcclxuXHJcbnZhciBFQ1ByaXZhdGVLZXlBU04gPSBhc24xLmRlZmluZSgnRUNQcml2YXRlS2V5JywgZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNlcSgpLm9iaihcclxuICAgICAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxyXG4gICAgICAgIHRoaXMua2V5KCdwcml2YXRlS2V5Jykub2N0c3RyKCksXHJcbiAgICAgICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5leHBsaWNpdCgwKS5vYmppZCgpLm9wdGlvbmFsKCksXHJcbiAgICAgICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLmV4cGxpY2l0KDEpLmJpdHN0cigpLm9wdGlvbmFsKClcclxuICAgIClcclxufSlcclxuXHJcbnZhciBTdWJqZWN0UHVibGljS2V5SW5mb0FTTiA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zZXEoKS5vYmooXHJcbiAgICAgICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcclxuICAgICAgICAgICAgdGhpcy5rZXkoXCJpZFwiKS5vYmppZCgpLFxyXG4gICAgICAgICAgICB0aGlzLmtleShcImN1cnZlXCIpLm9iamlkKClcclxuICAgICAgICApLFxyXG4gICAgICAgIHRoaXMua2V5KCdwdWInKS5iaXRzdHIoKVxyXG4gICAgKVxyXG59KVxyXG5cclxudmFyIGN1cnZlcyA9IHtcclxuICAgIHNlY3AyNTZrMToge1xyXG4gICAgICAgIGN1cnZlUGFyYW1ldGVyczogWzEsIDMsIDEzMiwgMCwgMTBdLFxyXG4gICAgICAgIHByaXZhdGVQRU1PcHRpb25zOiB7bGFiZWw6ICdFQyBQUklWQVRFIEtFWSd9LFxyXG4gICAgICAgIHB1YmxpY1BFTU9wdGlvbnM6IHtsYWJlbDogJ1BVQkxJQyBLRVknfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcclxuICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEtleUVuY29kZXIob3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGFzc2VydChjdXJ2ZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcclxuICAgICAgICBvcHRpb25zID0gY3VydmVzW29wdGlvbnNdXHJcbiAgICB9XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5hbGdvcml0aG1JRCA9IFsxLCAyLCA4NDAsIDEwMDQ1LCAyLCAxXVxyXG59XHJcblxyXG5LZXlFbmNvZGVyLkVDUHJpdmF0ZUtleUFTTiA9IEVDUHJpdmF0ZUtleUFTTjtcclxuS2V5RW5jb2Rlci5TdWJqZWN0UHVibGljS2V5SW5mb0FTTiA9IFN1YmplY3RQdWJsaWNLZXlJbmZvQVNOO1xyXG5cclxuS2V5RW5jb2Rlci5wcm90b3R5cGUucHJpdmF0ZUtleU9iamVjdCA9IGZ1bmN0aW9uKHJhd1ByaXZhdGVLZXksIHJhd1B1YmxpY0tleSkge1xyXG4gICAgdmFyIHByaXZhdGVLZXlPYmplY3QgPSB7XHJcbiAgICAgICAgdmVyc2lvbjogbmV3IEJOKDEpLFxyXG4gICAgICAgIHByaXZhdGVLZXk6IG5ldyBCdWZmZXIocmF3UHJpdmF0ZUtleSwgJ2hleCcpLFxyXG4gICAgICAgIHBhcmFtZXRlcnM6IHRoaXMub3B0aW9ucy5jdXJ2ZVBhcmFtZXRlcnMsXHJcbiAgICAgICAgcGVtT3B0aW9uczoge2xhYmVsOlwiRUMgUFJJVkFURSBLRVlcIn1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHJhd1B1YmxpY0tleSkge1xyXG4gICAgICAgIHByaXZhdGVLZXlPYmplY3QucHVibGljS2V5ID0ge1xyXG4gICAgICAgICAgICB1bnVzZWQ6IDAsXHJcbiAgICAgICAgICAgIGRhdGE6IG5ldyBCdWZmZXIocmF3UHVibGljS2V5LCAnaGV4JylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByaXZhdGVLZXlPYmplY3RcclxufTtcclxuXHJcbktleUVuY29kZXIucHJvdG90eXBlLnB1YmxpY0tleU9iamVjdCA9IGZ1bmN0aW9uKHJhd1B1YmxpY0tleSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhbGdvcml0aG06IHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMuYWxnb3JpdGhtSUQsXHJcbiAgICAgICAgICAgIGN1cnZlOiB0aGlzLm9wdGlvbnMuY3VydmVQYXJhbWV0ZXJzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdWI6IHtcclxuICAgICAgICAgICAgdW51c2VkOiAwLFxyXG4gICAgICAgICAgICBkYXRhOiBuZXcgQnVmZmVyKHJhd1B1YmxpY0tleSwgJ2hleCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwZW1PcHRpb25zOiB7IGxhYmVsIDpcIlBVQkxJQyBLRVlcIn1cclxuICAgIH1cclxufVxyXG5cclxuS2V5RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlUHJpdmF0ZSA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIG9yaWdpbmFsRm9ybWF0LCBkZXN0aW5hdGlvbkZvcm1hdCkge1xyXG4gICAgdmFyIHByaXZhdGVLZXlPYmplY3RcclxuXHJcbiAgICAvKiBQYXJzZSB0aGUgaW5jb21pbmcgcHJpdmF0ZSBrZXkgYW5kIGNvbnZlcnQgaXQgdG8gYSBwcml2YXRlIGtleSBvYmplY3QgKi9cclxuICAgIGlmIChvcmlnaW5hbEZvcm1hdCA9PT0gJ3JhdycpIHtcclxuICAgICAgICBpZiAoIXR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyAncHJpdmF0ZSBrZXkgbXVzdCBiZSBhIHN0cmluZydcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByaXZhdGVLZXlPYmplY3QgPSB0aGlzLm9wdGlvbnMuY3VydmUua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSwgJ2hleCcpLFxyXG4gICAgICAgICAgICByYXdQdWJsaWNLZXkgPSBwcml2YXRlS2V5T2JqZWN0LmdldFB1YmxpYygnaGV4JylcclxuICAgICAgICBwcml2YXRlS2V5T2JqZWN0ID0gdGhpcy5wcml2YXRlS2V5T2JqZWN0KHByaXZhdGVLZXksIHJhd1B1YmxpY0tleSlcclxuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdkZXInKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcml2YXRlS2V5ID09PSAnYnVmZmVyJykge1xyXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJpdmF0ZUtleSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IG5ldyBCdWZmZXIocHJpdmF0ZUtleSwgJ2hleCcpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgJ3ByaXZhdGUga2V5IG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByaXZhdGVLZXlPYmplY3QgPSBFQ1ByaXZhdGVLZXlBU04uZGVjb2RlKHByaXZhdGVLZXksICdkZXInKVxyXG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbEZvcm1hdCA9PT0gJ3BlbScpIHtcclxuICAgICAgICBpZiAoIXR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyAncHJpdmF0ZSBrZXkgbXVzdCBiZSBhIHN0cmluZydcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpdmF0ZUtleU9iamVjdCA9IEVDUHJpdmF0ZUtleUFTTi5kZWNvZGUocHJpdmF0ZUtleSwgJ3BlbScsIHRoaXMub3B0aW9ucy5wcml2YXRlUEVNT3B0aW9ucylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0J1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEV4cG9ydCB0aGUgcHJpdmF0ZSBrZXkgb2JqZWN0IHRvIHRoZSBkZXNpcmVkIGZvcm1hdCAqL1xyXG4gICAgaWYgKGRlc3RpbmF0aW9uRm9ybWF0ID09PSAncmF3Jykge1xyXG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5T2JqZWN0LnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpXHJcbiAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uRm9ybWF0ID09PSAnZGVyJykge1xyXG4gICAgICAgIHJldHVybiBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHByaXZhdGVLZXlPYmplY3QsICdkZXInKS50b1N0cmluZygnaGV4JylcclxuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb25Gb3JtYXQgPT09ICdwZW0nKSB7XHJcbiAgICAgICAgcmV0dXJuIEVDUHJpdmF0ZUtleUFTTi5lbmNvZGUocHJpdmF0ZUtleU9iamVjdCwgJ3BlbScsIHRoaXMub3B0aW9ucy5wcml2YXRlUEVNT3B0aW9ucylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgZGVzdGluYXRpb24gZm9ybWF0IGZvciBwcml2YXRlIGtleSdcclxuICAgIH1cclxufVxyXG5cclxuS2V5RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlUHVibGljID0gZnVuY3Rpb24ocHVibGljS2V5LCBvcmlnaW5hbEZvcm1hdCwgZGVzdGluYXRpb25Gb3JtYXQpIHtcclxuICAgIHZhciBwdWJsaWNLZXlPYmplY3RcclxuXHJcbiAgICAvKiBQYXJzZSB0aGUgaW5jb21pbmcgcHVibGljIGtleSBhbmQgY29udmVydCBpdCB0byBhIHB1YmxpYyBrZXkgb2JqZWN0ICovXHJcbiAgICBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdyYXcnKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlb2YgcHVibGljS2V5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyAncHVibGljIGtleSBtdXN0IGJlIGEgc3RyaW5nJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWNLZXlPYmplY3QgPSB0aGlzLnB1YmxpY0tleU9iamVjdChwdWJsaWNLZXkpXHJcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRm9ybWF0ID09PSAnZGVyJykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHVibGljS2V5ID09PSAnYnVmZmVyJykge1xyXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHVibGljS2V5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXkgPSBuZXcgQnVmZmVyKHB1YmxpY0tleSwgJ2hleCcpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgJ3B1YmxpYyBrZXkgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZydcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljS2V5T2JqZWN0ID0gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZGVjb2RlKHB1YmxpY0tleSwgJ2RlcicpXHJcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRm9ybWF0ID09PSAncGVtJykge1xyXG4gICAgICAgIGlmICghdHlwZW9mIHB1YmxpY0tleSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ3B1YmxpYyBrZXkgbXVzdCBiZSBhIHN0cmluZydcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljS2V5T2JqZWN0ID0gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZGVjb2RlKHB1YmxpY0tleSwgJ3BlbScsIHRoaXMub3B0aW9ucy5wdWJsaWNQRU1PcHRpb25zKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyAnaW52YWxpZCBwdWJsaWMga2V5IGZvcm1hdCdcclxuICAgIH1cclxuXHJcbiAgICAvKiBFeHBvcnQgdGhlIHByaXZhdGUga2V5IG9iamVjdCB0byB0aGUgZGVzaXJlZCBmb3JtYXQgKi9cclxuICAgIGlmIChkZXN0aW5hdGlvbkZvcm1hdCA9PT0gJ3JhdycpIHtcclxuICAgICAgICByZXR1cm4gcHVibGljS2V5T2JqZWN0LnB1Yi5kYXRhLnRvU3RyaW5nKCdoZXgnKVxyXG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbkZvcm1hdCA9PT0gJ2RlcicpIHtcclxuICAgICAgICByZXR1cm4gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZW5jb2RlKHB1YmxpY0tleU9iamVjdCwgJ2RlcicpLnRvU3RyaW5nKCdoZXgnKVxyXG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbkZvcm1hdCA9PT0gJ3BlbScpIHtcclxuICAgICAgICByZXR1cm4gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZW5jb2RlKHB1YmxpY0tleU9iamVjdCwgJ3BlbScsIHRoaXMub3B0aW9ucy5wdWJsaWNQRU1PcHRpb25zKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyAnaW52YWxpZCBkZXN0aW5hdGlvbiBmb3JtYXQgZm9yIHB1YmxpYyBrZXknXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5RW5jb2RlcjsiLCJjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHlhemwgPSByZXF1aXJlKFwieWF6bFwiKTtcclxuY29uc3QgeWF1emwgPSByZXF1aXJlKFwieWF1emxcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKFwiLi91dGlscy9EdXBsZXhTdHJlYW1cIik7XHJcbmNvbnN0IFBhc3NUaHJvdWdoU3RyZWFtID0gcmVxdWlyZShcIi4vdXRpbHMvUGFzc1Rocm91Z2hTdHJlYW1cIik7XHJcbmNvbnN0IGlzU3RyZWFtID0gcmVxdWlyZShcIi4vdXRpbHMvaXNTdHJlYW1cIik7XHJcblxyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcclxuXHJcbmNvbnN0IGNvdW50RmlsZXMgPSByZXF1aXJlKCcuL3V0aWxzL2NvdW50RmlsZXMnKTtcclxuXHJcbmZ1bmN0aW9uIFBza0FyY2hpdmVyKCkge1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgIHRoaXMub24gPSBldmVudC5vbjtcclxuICAgIHRoaXMub2ZmID0gZXZlbnQub2ZmO1xyXG4gICAgdGhpcy5lbWl0ID0gZXZlbnQuZW1pdDtcclxuXHJcbiAgICB0aGlzLnppcFN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dFBhdGgsIG91dHB1dCwgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgZXh0ID0gXCJcIjtcclxuICAgICAgICBjb25zdCB6aXBGaWxlID0gbmV3IHlhemwuWmlwRmlsZSgpO1xyXG4gICAgICAgIGNvbnN0IHB0U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKCk7XHJcblxyXG4gICAgICAgIGNvdW50RmlsZXMuY29tcHV0ZVNpemUoaW5wdXRQYXRoLCAoZXJyLCB0b3RhbFNpemUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9fYWRkVG9BcmNoaXZlUmVjdXJzaXZlbHkoemlwRmlsZSwgaW5wdXRQYXRoLCBcIlwiLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgemlwRmlsZS5lbmQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZShpbnB1dFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRGaWxlbmFtZSA9IGZpbGVuYW1lLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcGxpdEZpbGVuYW1lLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ID0gXCIuXCIgKyBzcGxpdEZpbGVuYW1lW3NwbGl0RmlsZW5hbWUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBteVN0cmVhbSA9IHppcEZpbGUub3V0cHV0U3RyZWFtLnBpcGUocHRTdHJlYW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVE9ETyByZXZpZXcgdGhpc1xyXG4gICAgICAgICAgICAgICAgICogSW4gYnJvd3NlciwgcGlwaW5nIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgYW5kIHRoZSBzdGFjayBxdWV1ZSBpcyBub3QgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBteVN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzTGVuZ3RoID4gMzAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG15U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteVN0cmVhbS5yZXN1bWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0UHJvZ3Jlc3ModG90YWxTaXplLCB0b3RhbExlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBteVN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRQcm9ncmVzcyh0b3RhbFNpemUsIHRvdGFsU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdFRvdGFsU2l6ZSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJlYW0uaXNXcml0YWJsZShvdXRwdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXlTdHJlYW0ucGlwZShvdXRwdXQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG91dHB1dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgZnMubWtkaXIob3V0cHV0LCB7cmVjdXJzaXZlOiB0cnVlfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvblBhdGggPSBwYXRoLmpvaW4ob3V0cHV0LCBwYXRoLmJhc2VuYW1lKGlucHV0UGF0aCwgZXh0KSArIFwiLnppcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXlTdHJlYW0ucGlwZShmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0aW5hdGlvblBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBfX2FkZFRvQXJjaGl2ZVJlY3Vyc2l2ZWx5KHppcEZpbGUsIGlucHV0UGF0aCwgcm9vdCA9ICcnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICBmcy5zdGF0KGlucHV0UGF0aCwgKGVyciwgc3RhdHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgemlwRmlsZS5hZGRGaWxlKGlucHV0UGF0aCwgcGF0aC5qb2luKHJvb3QsIHBhdGguYmFzZW5hbWUoaW5wdXRQYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnMucmVhZGRpcihpbnB1dFBhdGgsIChlcnIsIGZpbGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmX2xlbmd0aCA9IGZpbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmX2FkZF9pbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tTdGF0dXMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZfbGVuZ3RoID09PSBmX2FkZF9pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1N0YXR1cygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcFBhdGggPSBwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hZGRUb0FyY2hpdmVSZWN1cnNpdmVseSh6aXBGaWxlLCB0ZW1wUGF0aCwgcGF0aC5qb2luKHJvb3QsIHBhdGguYmFzZW5hbWUoaW5wdXRQYXRoKSksIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZfYWRkX2luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1N0YXR1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51bnppcFN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0UGF0aCwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgbGV0IHNpemUgPSAwO1xyXG5cclxuICAgICAgICBmcy5zdGF0KGlucHV0LCAoZXJyLCBzdGF0cykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IHN0YXRzLnNpemU7XHJcblxyXG5cclxuICAgICAgICAgICAgeWF1emwub3BlbihpbnB1dCwge2xhenlFbnRyaWVzOiB0cnVlfSwgKGVyciwgemlwRmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgICAgICAgIHppcEZpbGUub25jZShcImVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdFByb2dyZXNzKHRvdGFsU2l6ZSwgdG90YWxTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlTmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB6aXBGaWxlLm9uKFwiZW50cnlcIiwgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLmVuZHNXaXRoKHBhdGguc2VwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6aXBGaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZXIgPSBwYXRoLmRpcm5hbWUoZW50cnkuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcy5ta2RpcihwYXRoLmpvaW4ob3V0cHV0UGF0aCwgZm9sZGVyKSwge3JlY3Vyc2l2ZTogdHJ1ZX0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcEZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVE9ETyByZXZpZXcgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIGJyb3dzZXIsIHBpcGluZyB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIGFuZCB0aGUgc3RhY2sgcXVldWUgaXMgbm90IGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzTGVuZ3RoID4gMzAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFByb2dyZXNzKHRvdGFsU2l6ZSwgdG90YWxMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXBGaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gcGF0aC5qb2luKG91dHB1dFBhdGgsIGVudHJ5LmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVyID0gcGF0aC5kaXJuYW1lKGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3RyZWFtID0gcmVhZFN0cmVhbS5waXBlKHB0U3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnMubWtkaXIoZm9sZGVyLCB7cmVjdXJzaXZlOiB0cnVlfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBwdFN0cmVhbS5nZXRTaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN0cmVhbS5waXBlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuemlwSW5NZW1vcnkgPSBmdW5jdGlvbiAoaW5wdXRPYmosIGRlcHRoLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHppcEZpbGUgPSBuZXcgeWF6bC5aaXBGaWxlKCk7XHJcbiAgICAgICAgY29uc3QgZHMgPSBuZXcgRHVwbGV4U3RyZWFtKCk7XHJcbiAgICAgICAgemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgaW5wdXRPYmosIFwiXCIsIGRlcHRoLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHppcEZpbGUuZW5kKCk7XHJcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICAgICAgICAgIGRzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIGNodW5rXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgemlwRmlsZS5vdXRwdXRTdHJlYW0ucGlwZShkcykub24oXCJmaW5pc2hcIiwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51bnppcEluTWVtb3J5ID0gZnVuY3Rpb24gKGlucHV0WmlwLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1bnppcElucHV0KHppcEZpbGUpIHtcclxuICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgICAgIHppcEZpbGUub25jZShcImVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBvYmopO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHppcEZpbGUub24oXCJlbnRyeVwiLCAoZW50cnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHppcEZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcyA9IG5ldyBEdXBsZXhTdHJlYW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHppcEZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHMub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5waXBlKGRzKS5vbihcImZpbmlzaFwiLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0RW50cnkgPSBlbnRyeS5maWxlTmFtZS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzcGxpdEVudHJ5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9wc1JlY3Vyc2l2ZWx5KG9iaiwgc3BsaXRFbnRyeSwgdHlwZSwgbmV3IEJ1ZmZlcihzdHIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXRaaXApKSB7XHJcbiAgICAgICAgICAgIHlhdXpsLmZyb21CdWZmZXIoaW5wdXRaaXAsIHtsYXp5RW50cmllczogdHJ1ZX0sIChlcnIsIHppcEZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuemlwSW5wdXQoemlwRmlsZSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBiZSBhIGJ1ZmZlclwiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgb2JqLCByb290LCBkZXB0aCwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcclxuICAgICAgICAgICAgemlwRmlsZS5hZGRCdWZmZXIobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShvYmopKSwgcm9vdCArIFwiL3N0cmluZ2lmeVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKEJ1ZmZlci5hbGxvYygwKSwgcm9vdCArIFwiL3VuZGVmaW5lZFwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKG5ldyBCdWZmZXIob2JqLnRvU3RyaW5nKCkpLCByb290ICsgXCIvbnVtYmVyXCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgemlwRmlsZS5hZGRCdWZmZXIobmV3IEJ1ZmZlcihvYmopLCByb290ICsgXCIvc3RyaW5nXCIpXHJcbiAgICAgICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICAgICAgemlwRmlsZS5hZGRCdWZmZXIoQnVmZmVyLmFsbG9jKDApLCByb290ICsgXCIvbnVsbFwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XHJcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKG9iaiwgcm9vdCArIFwiL2J1ZmZlclwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyZWFtLmlzUmVhZGFibGUob2JqKSkge1xyXG4gICAgICAgICAgICB6aXBGaWxlLmFkZFJlYWRTdHJlYW0ob2JqLCByb290ICsgXCIvc3RyZWFtXCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKEJ1ZmZlci5hbGxvYygwKSwgcm9vdCArIFwiL2FycmF5XCIpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHppcFJlY3Vyc2l2ZWx5KHppcEZpbGUsIG9ialtpXSwgcm9vdCArIFwiL2FycmF5L1wiICsgaSwgZGVwdGgsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB6aXBGaWxlLmFkZEJ1ZmZlcihCdWZmZXIuYWxsb2MoMCksIHJvb3QgKyBcIi9vYmplY3RcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkT2JqID0ge307XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRPYmpbZW5jb2RlVVJJQ29tcG9uZW50KGtleSldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9iaiA9IGVuY29kZWRPYmo7XHJcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnRyeU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IHJvb3QgKyBcIi9cIiArIGtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgb2JqW2tleV0sIGVudHJ5TmFtZSwgZGVwdGggLSAxLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUHJvcHNSZWN1cnNpdmVseShvYmosIHNwbGl0TmFtZSwgdHlwZSwgZGF0YSkge1xyXG4gICAgICAgIGlmIChzcGxpdE5hbWUubGVuZ3RoID49IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcCA9IGRlY29kZVVSSUNvbXBvbmVudChzcGxpdE5hbWUuc2hpZnQoKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gcGFyc2VJbnQoZGF0YS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJlYW0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBidWZmZXJUb1N0cmVhbShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZ2lmeSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgcmVhY2ggdGhpcycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0TmFtZVswXSA9PT0gJ2FycmF5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzcGxpdE5hbWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRQcm9wc1JlY3Vyc2l2ZWx5KG9ialtwcm9wXSwgc3BsaXROYW1lLCB0eXBlLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3BzUmVjdXJzaXZlbHkob2JqW3Byb3BdLCBzcGxpdE5hbWUsIHR5cGUsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBidWZmZXJUb1N0cmVhbShidWZmZXIpIHtcclxuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlKCk7XHJcbiAgICAgICAgc3RyZWFtLnB1c2goYnVmZmVyKTtcclxuICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRQcm9ncmVzcyh0b3RhbCwgcHJvY2Vzc2VkKSB7XHJcblxyXG5cclxuICAgICAgICBpZiAocHJvY2Vzc2VkID4gdG90YWwpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkID0gdG90YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9ICgxMDAgKiBwcm9jZXNzZWQpIC8gdG90YWw7XHJcbiAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHByb2dyZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbWl0VG90YWxTaXplKHRvdGFsKSB7XHJcbiAgICAgICAgc2VsZi5lbWl0KCd0b3RhbCcsIHRvdGFsKTtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBza0FyY2hpdmVyOyIsImNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxuY29uc3QgRHVwbGV4ID0gc3RyZWFtLkR1cGxleDtcclxuXHJcbmZ1bmN0aW9uIER1cGxleFN0cmVhbShvcHRpb25zKSB7XHJcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleFN0cmVhbSkpIHtcclxuXHRcdHJldHVybiBuZXcgRHVwbGV4U3RyZWFtKG9wdGlvbnMpO1xyXG5cdH1cclxuXHREdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcclxufVxyXG51dGlsLmluaGVyaXRzKER1cGxleFN0cmVhbSwgRHVwbGV4KTtcclxuXHJcbkR1cGxleFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmMsIGNiKSB7XHJcblx0dGhpcy5wdXNoKGNodW5rKTtcclxuXHRjYigpO1xyXG59O1xyXG5cclxuXHJcbkR1cGxleFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4U3RyZWFtOyIsImNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxuY29uc3QgUGFzc1Rocm91Z2ggPSBzdHJlYW0uUGFzc1Rocm91Z2g7XHJcblxyXG5mdW5jdGlvbiBQYXNzVGhyb3VnaFN0cmVhbShvcHRpb25zKSB7XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2hTdHJlYW0pKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaFN0cmVhbShvcHRpb25zKTtcclxuICAgIH1cclxuICAgIFBhc3NUaHJvdWdoLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IHNpemUgPSAwO1xyXG5cclxuICAgIHRoaXMuYWRkVG9TaXplID0gZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgIHNpemUgKz0gYW1vdW50O1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2hTdHJlYW0sIFBhc3NUaHJvdWdoKTtcclxuXHJcblBhc3NUaHJvdWdoU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuYywgY2IpIHtcclxuICAgIHRoaXMuYWRkVG9TaXplKGNodW5rLmxlbmd0aCk7XHJcbiAgICB0aGlzLnB1c2goY2h1bmspO1xyXG4gICAgY2IoKTtcclxufTtcclxuXHJcblxyXG5QYXNzVGhyb3VnaFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2hTdHJlYW07IiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCB5YXV6bCA9IHJlcXVpcmUoJ3lhdXpsJyk7XHJcblxyXG5mdW5jdGlvbiBjb3VudEZpbGVzKGlucHV0UGF0aCwgY2FsbGJhY2spIHtcclxuICAgIGxldCB0b3RhbCA9IDA7XHJcblxyXG4gICAgZnMuc3RhdChpbnB1dFBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZzLnJlYWRkaXIoaW5wdXRQYXRoLCAoZXJyLCBmaWxlcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHRvdGFsID0gZmlsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSBmaWxlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAodG90YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQsIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgZnMuc3RhdChwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKSwgKGVyciwgc3RhdHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLS10b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRGaWxlcyhwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKSwgKGVyciwgZmlsZXNOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBmaWxlc051bWJlcjtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHRvdGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS10b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdG90YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY291bnRaaXBFbnRyaWVzKGlucHV0UGF0aCwgY2FsbGJhY2spIHtcclxuICAgIGxldCBwcm9jZXNzZWQgPSAwO1xyXG5cclxuICAgIHlhdXpsLm9wZW4oaW5wdXRQYXRoLCB7bGF6eUVudHJpZXM6IHRydWV9LCAoZXJyLCB6aXBGaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHppcEZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgemlwRmlsZS5vbmNlKFwiZW5kXCIsICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcHJvY2Vzc2VkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgemlwRmlsZS5vbihcImVudHJ5XCIsIChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICArK3Byb2Nlc3NlZDtcclxuXHJcbiAgICAgICAgICAgIHppcEZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZVNpemUoaW5wdXRQYXRoLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICBmcy5zdGF0KGlucHV0UGF0aCwgKGVyciwgc3RhdHMpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQsIHN0YXRzLnNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnMucmVhZGRpcihpbnB1dFBhdGgsIChlcnIsIGZpbGVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gZmlsZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgICAgIGZzLnN0YXQocGF0aC5qb2luKGlucHV0UGF0aCwgZmlsZSksIChlcnIsIHN0YXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTaXplKHBhdGguam9pbihpbnB1dFBhdGgsIGZpbGUpLCAoZXJyLCBmaWxlc1NpemUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gZmlsZXNTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplICs9IHN0YXRzLnNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjb3VudEZpbGVzLFxyXG4gICAgY291bnRaaXBFbnRyaWVzLFxyXG4gICAgY29tcHV0ZVNpemVcclxufTtcclxuIiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5cclxuY29uc3QgYWxnb3JpdGhtID0gJ2Flcy0yNTYtZ2NtJztcclxuXHJcblxyXG5jb25zdCBpdGVyYXRpb25zX251bWJlciA9IDEwMDA7XHJcblxyXG5mdW5jdGlvbiBlbmNvZGUoYnVmZmVyKSB7XHJcblx0cmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0JylcclxuXHRcdC5yZXBsYWNlKC9cXCsvZywgJycpXHJcblx0XHQucmVwbGFjZSgvXFwvL2csICcnKVxyXG5cdFx0LnJlcGxhY2UoLz0rJC8sICcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVsZXRlUmVjdXJzaXZlbHkoaW5wdXRQYXRoLCBjYWxsYmFjaykge1xyXG5cclxuXHRmcy5zdGF0KGlucHV0UGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcclxuXHRcdGlmIChlcnIpIHtcclxuXHRcdFx0Y2FsbGJhY2soZXJyLCBzdGF0cyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmIChzdGF0cy5pc0ZpbGUoKSkge1xyXG5cdFx0XHRmcy51bmxpbmsoaW5wdXRQYXRoLCBmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyLCBudWxsKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xyXG5cdFx0XHRmcy5yZWFkZGlyKGlucHV0UGF0aCwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcclxuXHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIsIG51bGwpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zdCBmX2xlbmd0aCA9IGZpbGVzLmxlbmd0aDtcclxuXHRcdFx0XHRsZXQgZl9kZWxldGVfaW5kZXggPSAwO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjaGVja1N0YXR1cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdGlmIChmX2xlbmd0aCA9PT0gZl9kZWxldGVfaW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0ZnMucm1kaXIoaW5wdXRQYXRoLCBmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyLCBudWxsKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRpZiAoIWNoZWNrU3RhdHVzKCkpIHtcclxuXHRcdFx0XHRcdGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdGVtcFBhdGggPSBwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlUmVjdXJzaXZlbHkodGVtcFBhdGgsIGZ1bmN0aW9uIHJlbW92ZVJlY3Vyc2l2ZUNCKGVyciwgc3RhdHVzKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFlcnIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZfZGVsZXRlX2luZGV4Kys7XHJcblx0XHRcdFx0XHRcdFx0XHRjaGVja1N0YXR1cygpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIsIG51bGwpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUHNrSGFzaChkYXRhKSB7XHJcblx0Y29uc3QgcHNrSGFzaCA9IG5ldyBQc2tIYXNoKCk7XHJcblx0cHNrSGFzaC51cGRhdGUoZGF0YSk7XHJcblx0cmV0dXJuIHBza0hhc2guZGlnZXN0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBza0hhc2goKSB7XHJcblx0Y29uc3Qgc2hhNTEyID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpO1xyXG5cdGNvbnN0IHNoYTI1NiA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcclxuXHRcdHNoYTUxMi51cGRhdGUoZGF0YSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkaWdlc3QoKSB7XHJcblx0XHRzaGEyNTYudXBkYXRlKHNoYTUxMi5kaWdlc3QoKSk7XHJcblx0XHRyZXR1cm4gc2hhMjU2LmRpZ2VzdCgpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHVwZGF0ZSxcclxuXHRcdGRpZ2VzdFxyXG5cdH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2FsdChpbnB1dERhdGEsIHNhbHRMZW4pIHtcclxuXHRjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpO1xyXG5cdGhhc2gudXBkYXRlKGlucHV0RGF0YSk7XHJcblx0Y29uc3QgZGlnZXN0ID0gQnVmZmVyLmZyb20oaGFzaC5kaWdlc3QoJ2hleCcpLCAnYmluYXJ5Jyk7XHJcblxyXG5cdHJldHVybiBkaWdlc3Quc2xpY2UoMCwgc2FsdExlbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY3J5cHQoZGF0YSwgcGFzc3dvcmQpIHtcclxuXHRjb25zdCBrZXlTYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcclxuXHRjb25zdCBrZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwga2V5U2FsdCwgaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XHJcblxyXG5cdGNvbnN0IGFhZFNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xyXG5cdGNvbnN0IGFhZCA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBhYWRTYWx0LCBpdGVyYXRpb25zX251bWJlciwgMzIsICdzaGE1MTInKTtcclxuXHJcblx0Y29uc3Qgc2FsdCA9IEJ1ZmZlci5jb25jYXQoW2tleVNhbHQsIGFhZFNhbHRdKTtcclxuXHRjb25zdCBpdiA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zX251bWJlciwgMTIsICdzaGE1MTInKTtcclxuXHJcblx0Y29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGFsZ29yaXRobSwga2V5LCBpdik7XHJcblx0Y2lwaGVyLnNldEFBRChhYWQpO1xyXG5cdGxldCBlbmNyeXB0ZWRUZXh0ID0gY2lwaGVyLnVwZGF0ZShkYXRhLCAnYmluYXJ5Jyk7XHJcblx0Y29uc3QgZmluYWwgPSBCdWZmZXIuZnJvbShjaXBoZXIuZmluYWwoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XHJcblx0Y29uc3QgdGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcclxuXHJcblx0ZW5jcnlwdGVkVGV4dCA9IEJ1ZmZlci5jb25jYXQoW2VuY3J5cHRlZFRleHQsIGZpbmFsXSk7XHJcblxyXG5cdHJldHVybiBCdWZmZXIuY29uY2F0KFtzYWx0LCBlbmNyeXB0ZWRUZXh0LCB0YWddKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVjcnlwdChlbmNyeXB0ZWREYXRhLCBwYXNzd29yZCkge1xyXG5cdGNvbnN0IHNhbHQgPSBlbmNyeXB0ZWREYXRhLnNsaWNlKDAsIDY0KTtcclxuXHRjb25zdCBrZXlTYWx0ID0gc2FsdC5zbGljZSgwLCAzMik7XHJcblx0Y29uc3QgYWFkU2FsdCA9IHNhbHQuc2xpY2UoLTMyKTtcclxuXHJcblx0Y29uc3QgaXYgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9uc19udW1iZXIsIDEyLCAnc2hhNTEyJyk7XHJcblx0Y29uc3Qga2V5ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIGtleVNhbHQsIGl0ZXJhdGlvbnNfbnVtYmVyLCAzMiwgJ3NoYTUxMicpO1xyXG5cdGNvbnN0IGFhZCA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBhYWRTYWx0LCBpdGVyYXRpb25zX251bWJlciwgMzIsICdzaGE1MTInKTtcclxuXHJcblx0Y29uc3QgY2lwaGVydGV4dCA9IGVuY3J5cHRlZERhdGEuc2xpY2UoNjQsIGVuY3J5cHRlZERhdGEubGVuZ3RoIC0gMTYpO1xyXG5cdGNvbnN0IHRhZyA9IGVuY3J5cHRlZERhdGEuc2xpY2UoLTE2KTtcclxuXHJcblx0Y29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihhbGdvcml0aG0sIGtleSwgaXYpO1xyXG5cdGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcclxuXHRkZWNpcGhlci5zZXRBQUQoYWFkKTtcclxuXHJcblx0bGV0IHBsYWludGV4dCA9IEJ1ZmZlci5mcm9tKGRlY2lwaGVyLnVwZGF0ZShjaXBoZXJ0ZXh0LCAnYmluYXJ5JyksICdiaW5hcnknKTtcclxuXHRjb25zdCBmaW5hbCA9IEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmZpbmFsKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xyXG5cdHBsYWludGV4dCA9IEJ1ZmZlci5jb25jYXQoW3BsYWludGV4dCwgZmluYWxdKTtcclxuXHRyZXR1cm4gcGxhaW50ZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmNyeXB0T2JqZWN0SW5NZW1vcnkoaW5wdXRPYmosIHBhc3N3b3JkLCBkZXB0aCwgY2FsbGJhY2spIHtcclxuXHRjb25zdCBQc2tBcmNoaXZlciA9IHJlcXVpcmUoXCIuLi9wc2stYXJjaGl2ZXJcIik7XHJcblx0Y29uc3QgYXJjaGl2ZXIgPSBuZXcgUHNrQXJjaGl2ZXIoKTtcclxuXHJcblx0YXJjaGl2ZXIuemlwSW5NZW1vcnkoaW5wdXRPYmosIGRlcHRoLCBmdW5jdGlvbiAoZXJyLCB6aXBwZWRPYmopIHtcclxuXHRcdGlmIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHR9XHJcblx0XHRjb25zdCBjaXBoZXJUZXh0ID0gZW5jcnlwdCh6aXBwZWRPYmosIHBhc3N3b3JkKTtcclxuXHRcdGNhbGxiYWNrKG51bGwsIGNpcGhlclRleHQpO1xyXG5cdH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY3J5cHRPYmplY3RJbk1lbW9yeShlbmNyeXB0ZWRPYmplY3QsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xyXG5cdGNvbnN0IGFyY2hpdmVyID0gbmV3IFBza0FyY2hpdmVyKCk7XHJcblxyXG5cdGNvbnN0IHppcHBlZE9iamVjdCA9IGRlY3J5cHQoZW5jcnlwdGVkT2JqZWN0LCBwYXNzd29yZCk7XHJcblx0YXJjaGl2ZXIudW56aXBJbk1lbW9yeSh6aXBwZWRPYmplY3QsIGZ1bmN0aW9uIChlcnIsIG9iaikge1xyXG5cdFx0aWYgKGVycikge1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdH1cclxuXHRcdGNhbGxiYWNrKG51bGwsIG9iaik7XHJcblx0fSlcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGNyZWF0ZVBza0hhc2gsXHJcblx0ZW5jcnlwdCxcclxuXHRlbmNyeXB0T2JqZWN0SW5NZW1vcnksXHJcblx0ZGVjcnlwdCxcclxuXHRkZWNyeXB0T2JqZWN0SW5NZW1vcnksXHJcblx0ZGVsZXRlUmVjdXJzaXZlbHksXHJcblx0ZW5jb2RlLFxyXG5cdGdlbmVyYXRlU2FsdCxcclxuXHRpdGVyYXRpb25zX251bWJlcixcclxuXHRhbGdvcml0aG0sXHJcblx0UHNrSGFzaFxyXG59O1xyXG5cclxuIiwiY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gaXNTdHJlYW0gKG9iaikge1xyXG5cdHJldHVybiBvYmogaW5zdGFuY2VvZiBzdHJlYW0uU3RyZWFtIHx8IG9iaiBpbnN0YW5jZW9mIHN0cmVhbS5EdXBsZXg7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcclxuXHRyZXR1cm4gaXNTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLl9yZWFkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouX3JlYWRhYmxlU3RhdGUgPT09ICdvYmplY3QnXHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc1dyaXRhYmxlIChvYmopIHtcclxuXHRyZXR1cm4gaXNTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0J1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaXNEdXBsZXggKG9iaikge1xyXG5cdHJldHVybiBpc1JlYWRhYmxlKG9iaikgJiYgaXNXcml0YWJsZShvYmopXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgICAgID0gaXNTdHJlYW07XHJcbm1vZHVsZS5leHBvcnRzLmlzUmVhZGFibGUgPSBpc1JlYWRhYmxlO1xyXG5tb2R1bGUuZXhwb3J0cy5pc1dyaXRhYmxlID0gaXNXcml0YWJsZTtcclxubW9kdWxlLmV4cG9ydHMuaXNEdXBsZXggICA9IGlzRHVwbGV4OyIsIi8qXHJcbiBTaWduU2VucyBoZWxwZXIgZnVuY3Rpb25zXHJcbiAqL1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbmV4cG9ydHMud2lwZU91dHNpZGVQYXlsb2FkID0gZnVuY3Rpb24gd2lwZU91dHNpZGVQYXlsb2FkKGhhc2hTdHJpbmdIZXhhLCBwb3MsIHNpemUpe1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHZhciBzeiA9IGhhc2hTdHJpbmdIZXhhLmxlbmd0aDtcclxuXHJcbiAgICB2YXIgZW5kID0gKHBvcyArIHNpemUpICUgc3o7XHJcblxyXG4gICAgaWYocG9zIDwgZW5kKXtcclxuICAgICAgICByZXN1bHQgPSAnMCcucmVwZWF0KHBvcykgKyAgaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKHBvcywgZW5kKSArICcwJy5yZXBlYXQoc3ogLSBlbmQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKDAsIGVuZCkgKyAnMCcucmVwZWF0KHBvcyAtIGVuZCkgKyBoYXNoU3RyaW5nSGV4YS5zdWJzdHJpbmcocG9zLCBzeik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydHMuZXh0cmFjdFBheWxvYWQgPSBmdW5jdGlvbiBleHRyYWN0UGF5bG9hZChoYXNoU3RyaW5nSGV4YSwgcG9zLCBzaXplKXtcclxuICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgdmFyIHN6ID0gaGFzaFN0cmluZ0hleGEubGVuZ3RoO1xyXG4gICAgdmFyIGVuZCA9IChwb3MgKyBzaXplKSAlIHN6O1xyXG5cclxuICAgIGlmKCBwb3MgPCBlbmQpe1xyXG4gICAgICAgIHJlc3VsdCA9IGhhc2hTdHJpbmdIZXhhLnN1YnN0cmluZyhwb3MsIHBvcyArIHNpemUpO1xyXG4gICAgfSBlbHNle1xyXG5cclxuICAgICAgICBpZigwICE9IGVuZCl7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhc2hTdHJpbmdIZXhhLnN1YnN0cmluZygwLCBlbmQpXHJcbiAgICAgICAgfSAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBoYXNoU3RyaW5nSGV4YS5zdWJzdHJpbmcocG9zLCBzeik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydHMuZmlsbFBheWxvYWQgPSBmdW5jdGlvbiBmaWxsUGF5bG9hZChwYXlsb2FkLCBwb3MsIHNpemUpe1xyXG4gICAgdmFyIHN6ID0gNjQ7XHJcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuXHJcbiAgICB2YXIgZW5kID0gKHBvcyArIHNpemUpICUgc3o7XHJcblxyXG4gICAgaWYoIHBvcyA8IGVuZCl7XHJcbiAgICAgICAgcmVzdWx0ID0gJzAnLnJlcGVhdChwb3MpICsgcGF5bG9hZCArICcwJy5yZXBlYXQoc3ogLSBlbmQpO1xyXG4gICAgfSBlbHNle1xyXG4gICAgICAgIHJlc3VsdCA9IHBheWxvYWQuc3Vic3RyaW5nKDAsZW5kKTtcclxuICAgICAgICByZXN1bHQgKz0gJzAnLnJlcGVhdChwb3MgLSBlbmQpO1xyXG4gICAgICAgIHJlc3VsdCArPSBwYXlsb2FkLnN1YnN0cmluZyhlbmQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnRzLmdlbmVyYXRlUG9zSGFzaFhUaW1lcyA9IGZ1bmN0aW9uIGdlbmVyYXRlUG9zSGFzaFhUaW1lcyhidWZmZXIsIHBvcywgc2l6ZSwgY291bnQpeyAvL2dlbmVyYXRlIHBvc2l0aW9uYWwgaGFzaFxyXG4gICAgdmFyIHJlc3VsdCAgPSBidWZmZXIudG9TdHJpbmcoXCJoZXhcIik7XHJcblxyXG4gICAgLyppZihwb3MgIT0gLTEgKVxyXG4gICAgICAgIHJlc3VsdFtwb3NdID0gMDsgKi9cclxuXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKyl7XHJcbiAgICAgICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XHJcbiAgICAgICAgcmVzdWx0ID0gZXhwb3J0cy53aXBlT3V0c2lkZVBheWxvYWQocmVzdWx0LCBwb3MsIHNpemUpO1xyXG4gICAgICAgIGhhc2gudXBkYXRlKHJlc3VsdCk7XHJcbiAgICAgICAgcmVzdWx0ID0gaGFzaC5kaWdlc3QoJ2hleCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cG9ydHMud2lwZU91dHNpZGVQYXlsb2FkKHJlc3VsdCwgcG9zLCBzaXplKTtcclxufVxyXG5cclxuZXhwb3J0cy5oYXNoU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiAoY291bnRlciwgYXJyLCBwYXlsb2FkU2l6ZSl7XHJcblxyXG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcclxuICAgIHZhciByZXN1bHQgPSBjb3VudGVyLnRvU3RyaW5nKDE2KTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAwIDsgaSA8IDY0OyBpKyspe1xyXG4gICAgICAgIHJlc3VsdCArPSBleHBvcnRzLmV4dHJhY3RQYXlsb2FkKGFycltpXSxpLCBwYXlsb2FkU2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzaC51cGRhdGUocmVzdWx0KTtcclxuICAgIHZhciByZXN1bHQgPSBoYXNoLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGR1bXBNZW1iZXIob2JqKXtcclxuICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShvYmopID8gXCJhcnJheVwiIDogdHlwZW9mIG9iajtcclxuICAgIGlmKG9iaiA9PT0gbnVsbCl7XHJcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgfVxyXG4gICAgaWYob2JqID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOnJldHVybiBvYmoudG9TdHJpbmcoKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4gZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyhvYmopOyBicmVhaztcclxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiByZXR1cm4gIG9iaj8gXCJ0cnVlXCI6IFwiZmFsc2VcIjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8IG9iai5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyhvYmpbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgXCIgKyAgdHlwZSArIFwiIGNhbm5vdCBiZSBjcnlwdG9ncmFwaGljYWxseSBkaWdlc3RlZFwiKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnRzLmR1bXBPYmplY3RGb3JIYXNoaW5nID0gZnVuY3Rpb24ob2JqKXtcclxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuICAgIGlmKG9iaiA9PT0gbnVsbCl7XHJcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgfVxyXG4gICAgaWYob2JqID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNpY1R5cGVzID0ge1xyXG4gICAgICAgIFwiYXJyYXlcIiAgICAgOiB0cnVlLFxyXG4gICAgICAgIFwibnVtYmVyXCIgICAgOiB0cnVlLFxyXG4gICAgICAgIFwiYm9vbGVhblwiICAgOiB0cnVlLFxyXG4gICAgICAgIFwic3RyaW5nXCIgICAgOiB0cnVlLFxyXG4gICAgICAgIFwib2JqZWN0XCIgICAgOiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShvYmopID8gXCJhcnJheVwiIDogdHlwZW9mIG9iajtcclxuICAgIGlmKCBiYXNpY1R5cGVzW3R5cGVdKXtcclxuICAgICAgICByZXR1cm4gZHVtcE1lbWJlcihvYmopO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgIGtleXMuc29ydCgpO1xyXG5cclxuXHJcbiAgICBmb3IodmFyIGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHJlc3VsdCArPSBkdW1wTWVtYmVyKGtleXNbaV0pO1xyXG4gICAgICAgIHJlc3VsdCArPSBkdW1wTWVtYmVyKG9ialtrZXlzW2ldXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbmV4cG9ydHMuaGFzaFZhbHVlcyAgPSBmdW5jdGlvbiAodmFsdWVzKXtcclxuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XHJcbiAgICB2YXIgcmVzdWx0ID0gZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyh2YWx1ZXMpO1xyXG4gICAgaGFzaC51cGRhdGUocmVzdWx0KTtcclxuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnaGV4Jyk7XHJcbn07XHJcblxyXG5leHBvcnRzLmdldEpTT05Gcm9tU2lnbmF0dXJlID0gZnVuY3Rpb24gZ2V0SlNPTkZyb21TaWduYXR1cmUoc2lnbmF0dXJlLCBzaXplKXtcclxuICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgcHJvb2Y6W11cclxuICAgIH07XHJcbiAgICB2YXIgYSA9IHNpZ25hdHVyZS5zcGxpdChcIjpcIik7XHJcbiAgICByZXN1bHQuYWdlbnQgICAgICAgID0gYVswXTtcclxuICAgIHJlc3VsdC5jb3VudGVyICAgICAgPSAgcGFyc2VJbnQoYVsxXSwgXCJoZXhcIik7XHJcbiAgICByZXN1bHQubmV4dFB1YmxpYyAgID0gIGFbMl07XHJcblxyXG4gICAgdmFyIHByb29mID0gYVszXVxyXG5cclxuXHJcbiAgICBpZihwcm9vZi5sZW5ndGgvc2l6ZSAhPSA2NCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIFwiICsgcHJvb2YpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKXtcclxuICAgICAgICByZXN1bHQucHJvb2YucHVzaChleHBvcnRzLmZpbGxQYXlsb2FkKHByb29mLnN1YnN0cmluZyhpICogc2l6ZSwoaSsxKSAqIHNpemUgKSwgaSwgc2l6ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0cy5jcmVhdGVTaWduYXR1cmUgPSBmdW5jdGlvbiAoYWdlbnQsY291bnRlciwgbmV4dFB1YmxpYywgYXJyLCBzaXplKXtcclxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHJlc3VsdCArPSBleHBvcnRzLmV4dHJhY3RQYXlsb2FkKGFycltpXSwgaSAsIHNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhZ2VudCArIFwiOlwiICsgY291bnRlciArIFwiOlwiICsgbmV4dFB1YmxpYyArIFwiOlwiICsgcmVzdWx0O1xyXG59IiwiY29uc3QgTG9nRmFjdG9yeSA9IHJlcXVpcmUoJy4vTG9nRmFjdG9yeScpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7VHJhbnNwb3J0SW50ZXJmYWNlfSBtZXNzYWdlUHVibGlzaGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gR2VuZXJpY0xvZ2dlckNsaWVudChtZXNzYWdlUHVibGlzaGVyKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdG8gYmUgdXNlZCB0byBzZW5kIG5vcm1hbCBsb2dzLiBUaGV5IHdpbGwgYmUgcHVibGlzaGVkIGluIGEgc3ViY2hhbm5lbCBvZiB0aGUgXCJsb2dzXCIgY2hhbm5lbC5cclxuICAgICAqIEl0IGlzIGVhc2llciB0byB0cmFjZSBvbmx5IHVzZXIgYW5kIHBsYXRmb3JtIGxvZ3MgaWYgdGhleSBhcmUgc2VwYXJhdGVkIGluIHRoaXMgY2hhbm5lbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e2NvZGU6IE51bWJlciwgbmFtZTogc3RyaW5nfX0gbG9nTGV2ZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG1lc3NhZ2VzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7e2xldmVsLCBtZXRhLCB0aW1lLCBtc1RpbWUsIG1lc3NhZ2VzfX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbG9nKGxvZ0xldmVsLCBtZXRhLCBtZXNzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGxvZyA9IExvZ0ZhY3RvcnkuY3JlYXRlTG9nKGxvZ0xldmVsLCBtZXRhLCBtZXNzYWdlcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvZ0NoYW5uZWwgPSBgbG9ncy4ke2xvZ0xldmVsLm5hbWV9YDtcclxuICAgICAgICBtZXNzYWdlUHVibGlzaGVyLnNlbmQobG9nQ2hhbm5lbCwgbG9nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvZztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRvIGJlIHVzZWQgZm9yIHNlbmRpbmcgY3VzdG9tIGV2ZW50cyB3aGVuIG1lc3NhZ2VzIGRvbid0IGhhcHBlbiBpbiB0aGUgbm9ybWFsIGZsb3cgb2YgdGhlIHBsYXRmb3JtXHJcbiAgICAgKiBvciB0aGV5IHNob3VsZG4ndCBpbnRlcmZlcmUgd2l0aCB0aGUgdHJhY2luZyBvZiBsb2dzXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgc2VuZGluZyBzdGF0aXN0aWNzIGFib3V0IGEgbm9kZSBvciBhIHNhbmRib3ggaXMgaGFwcGVuaW5nIHBlcmlvZGljYWxseSBhbmQgbm90IGFzIGEgcmVzdWx0IG9mXHJcbiAgICAgKiB1c2VycycgcnVubmluZyBjb2RlLCB0aGVyZWZvcmUgdGhpcyBzaG91bGQgbm90IGJlIG1lcmdlZCB3aXRoIGxvZ3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbWVzc2FnZXNcclxuICAgICAqIEByZXR1cm4ge3ttZXRhLCBtZXNzYWdlcywgdGltZX19XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGV2ZW50KGNoYW5uZWwsIG1ldGEsIG1lc3NhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBMb2dGYWN0b3J5LmNyZWF0ZUV2ZW50KG1ldGEsIG1lc3NhZ2VzKTtcclxuXHJcbiAgICAgICAgY29uc3QgbG9nQ2hhbm5lbCA9IGBldmVudHMuJHtjaGFubmVsfWA7XHJcbiAgICAgICAgbWVzc2FnZVB1Ymxpc2hlci5zZW5kKGxvZ0NoYW5uZWwsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHB1Ymxpc2goY2hhbm5lbCwgbWVzc2FnZSkge1xyXG4gICAgICAgIG1lc3NhZ2VQdWJsaXNoZXIuc2VuZChjaGFubmVsLCBtZXNzYWdlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ldmVudCAgPSBldmVudDtcclxuICAgIHRoaXMubG9nICAgID0gbG9nO1xyXG4gICAgdGhpcy5wdWJsaXNoID0gcHVibGlzaDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmljTG9nZ2VyQ2xpZW50O1xyXG4iLCJmdW5jdGlvbiBnZXRUaW1lKCkge1xyXG4gICAgaWYocHJvY2Vzcy5lbnYuY29udGV4dCA9PT0gJ3NhbmRib3gnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHtwZXJmb3JtYW5jZX0gPSByZXF1aXJlKCdwZXJmX2hvb2tzJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKSArIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMb2cobG9nTGV2ZWwsIG1ldGEsIG1lc3NhZ2VzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxldmVsOiBsb2dMZXZlbCxcclxuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXHJcbiAgICAgICAgbWV0YTogbWV0YSxcclxuICAgICAgICB0aW1lOiBnZXRUaW1lKClcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXZlbnQobWV0YSwgbWVzc2FnZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVzc2FnZXMsXHJcbiAgICAgICAgbWV0YSxcclxuICAgICAgICB0aW1lOiBnZXRUaW1lKClcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY3JlYXRlTG9nLFxyXG4gICAgY3JlYXRlRXZlbnRcclxufTtcclxuIiwiY29uc3QgR2VuZXJpY0xvZ2dlckNsaWVudCA9IHJlcXVpcmUoJy4vR2VuZXJpY0xvZ2dlckNsaWVudCcpO1xyXG5jb25zdCBMb2dMZXZlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0xvZ0xldmVsJyk7XHJcbmNvbnN0IExvZ2dlckludGVyZmFjZSA9IHJlcXVpcmUoJy4vTG9nZ2VySW50ZXJmYWNlJyk7XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtUcmFuc3BvcnRJbnRlcmZhY2V9IG1lc3NhZ2VQdWJsaXNoZXJcclxuICogQGltcGxlbWVudHMgTG9nZ2VySW50ZXJmYWNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTG9nZ2VyQ2xpZW50KG1lc3NhZ2VQdWJsaXNoZXIpIHtcclxuICAgIExvZ2dlckludGVyZmFjZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIGNvbnN0IGdlbmVyaWNMb2dnZXJDbGllbnQgPSBuZXcgR2VuZXJpY0xvZ2dlckNsaWVudChtZXNzYWdlUHVibGlzaGVyKTtcclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFVCTElDIE1FVEhPRFMgKioqKioqKioqKioqKi9cclxuXHJcbiAgICBmdW5jdGlvbiBkZWJ1ZyhtZXRhID0ge30sIC4uLnBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gX2dldExvZ0xldmVsKExvZ0xldmVsLmRlYnVnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVycm9yKG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBfZ2V0TG9nTGV2ZWwoTG9nTGV2ZWwuZXJyb3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2VuZXJpY0xvZ2dlckNsaWVudC5sb2cobG9nTGV2ZWwsIG1ldGEsIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5mbyhtZXRhID0ge30sIC4uLnBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gX2dldExvZ0xldmVsKExvZ0xldmVsLmluZm8pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2VuZXJpY0xvZ2dlckNsaWVudC5sb2cobG9nTGV2ZWwsIG1ldGEsIHBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9nKG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBfZ2V0TG9nTGV2ZWwoTG9nTGV2ZWwubG9nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdhcm4obWV0YSA9IHt9LCAuLi5wYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBsb2dMZXZlbCA9IF9nZXRMb2dMZXZlbChMb2dMZXZlbC53YXJuKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV2ZW50KGNoYW5uZWwsIG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQuZXZlbnQoY2hhbm5lbCwgbWV0YSwgLi4ucGFyYW1zKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcmVkaXJlY3QoY2hhbm5lbCwgbG9nT2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQucHVibGlzaChjaGFubmVsLCBsb2dPYmplY3QpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqIFBSSVZBVEUgTUVUSE9EUyAqKioqKioqKioqKioqL1xyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRMb2dMZXZlbChsZXZlbENvZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiBsZXZlbENvZGUsXHJcbiAgICAgICAgICAgIG5hbWU6IExvZ0xldmVsW2xldmVsQ29kZV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKioqKioqKioqKioqKiBFWFBPUlRTICoqKioqKioqKioqKiovXHJcblxyXG4gICAgdGhpcy5kZWJ1ZyAgICA9IGRlYnVnO1xyXG4gICAgdGhpcy5lcnJvciAgICA9IGVycm9yO1xyXG4gICAgdGhpcy5ldmVudCAgICA9IGV2ZW50O1xyXG4gICAgdGhpcy5pbmZvICAgICA9IGluZm87XHJcbiAgICB0aGlzLmxvZyAgICAgID0gbG9nO1xyXG4gICAgdGhpcy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xyXG4gICAgdGhpcy53YXJuICAgICA9IHdhcm47XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyQ2xpZW50O1xyXG4iLCIvKipcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxuZnVuY3Rpb24gTG9nZ2VySW50ZXJmYWNlKCkge1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJpY01ldGhvZChjaGFubmVsLCBsb2dPYmplY3QpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGVidWcgICAgPSBnZW5lcmljTWV0aG9kO1xyXG4gICAgdGhpcy5lcnJvciAgICA9IGdlbmVyaWNNZXRob2Q7XHJcbiAgICB0aGlzLmV2ZW50ICAgID0gZ2VuZXJpY01ldGhvZDtcclxuICAgIHRoaXMuaW5mbyAgICAgPSBnZW5lcmljTWV0aG9kO1xyXG4gICAgdGhpcy5sb2cgICAgICA9IGdlbmVyaWNNZXRob2Q7XHJcbiAgICB0aGlzLnJlZGlyZWN0ID0gZ2VuZXJpY01ldGhvZDtcclxuICAgIHRoaXMud2FybiAgICAgPSBnZW5lcmljTWV0aG9kO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlckludGVyZmFjZTtcclxuIiwiY29uc3QgR2VuZXJpY0xvZ2dlckNsaWVudCA9IHJlcXVpcmUoJy4vR2VuZXJpY0xvZ2dlckNsaWVudCcpO1xyXG5jb25zdCBMb2dGYWN0b3J5ICAgICAgICAgID0gcmVxdWlyZSgnLi9Mb2dGYWN0b3J5Jyk7XHJcbmNvbnN0IExvZ2dlckNsaWVudCAgICAgICAgPSByZXF1aXJlKCcuL0xvZ2dlckNsaWVudCcpO1xyXG5jb25zdCBMb2dnZXJJbnRlcmZhY2UgICAgID0gcmVxdWlyZSgnLi9Mb2dnZXJJbnRlcmZhY2UnKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEdlbmVyaWNMb2dnZXJDbGllbnQsXHJcbiAgICBMb2dGYWN0b3J5LFxyXG4gICAgTG9nZ2VyQ2xpZW50LFxyXG4gICAgTG9nZ2VySW50ZXJmYWNlXHJcbn07XHJcbiIsImNvbnN0IFRyYW5zcG9ydEludGVyZmFjZSA9IHJlcXVpcmUoJy4vVHJhbnNwb3J0SW50ZXJmYWNlJyk7XHJcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuY29uc3QgemVyb01RID0gcmVxdWlyZSgnemVyb21xJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBaZXJvTVEgUHVibGlzaGVyIFNvY2tldCBhbmQgY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZvciBhIFplcm9NUSBTdWJzY3JpYmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nIX0gYWRkcmVzcyAtIEJhc2UgYWRkcmVzcyBpbmNsdWRpbmcgcHJvdG9jb2wgYW5kIHBvcnQgKGV4OiB0Y3A6Ly8xMjcuMC4wLjE6ODA4MClcclxuICogQGltcGxlbWVudHMgVHJhbnNwb3J0SW50ZXJmYWNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTWVzc2FnZVB1Ymxpc2hlcihhZGRyZXNzKSB7XHJcbiAgICBUcmFuc3BvcnRJbnRlcmZhY2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICBjb25zdCB6bXFTb2NrZXQgPSB6ZXJvTVEuY3JlYXRlU29ja2V0KCdwdWInKTtcclxuXHJcbiAgICAvLyB1bmNvbW1lbnQgbmV4dCBsaW5lIGlmIG1lc3NhZ2VzIGFyZSBsb3N0XHJcbiAgICAvLyB6bXFTb2NrZXQuc2V0c29ja29wdCh6ZXJvTVEuWk1RX1NOREhXTSwgMCk7XHJcbiAgICBjb25zdCBzb2NrZXQgPSBuZXcgdXRpbHMuQnVmZmVyZWRTb2NrZXQoem1xU29ja2V0LCB1dGlscy5Tb2NrZXRUeXBlLmNvbm5lY3RhYmxlKTtcclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFVCTElDIE1FVEhPRFMgKioqKioqKioqKioqKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ09iamVjdFxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgbG9nT2JqZWN0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZExvZyA9IEpTT04uc3RyaW5naWZ5KGxvZ09iamVjdCk7XHJcblxyXG4gICAgICAgICAgICBzb2NrZXQuc2VuZChbY2hhbm5lbCwgc2VyaWFsaXplZExvZ10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoJ0Vycm9yIHdoaWxlIHNlbmRpbmcgb3Igc2VyaWFsaXppbmcgbWVzc2FnZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqIE1PTklUT1IgU09DS0VUICoqKioqKioqKioqKiovXHJcblxyXG4gICAgem1xU29ja2V0LmNvbm5lY3QoYWRkcmVzcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVB1Ymxpc2hlcjtcclxuIiwiY29uc3QgVHJhbnNwb3J0SW50ZXJmYWNlID0gcmVxdWlyZSgnLi9UcmFuc3BvcnRJbnRlcmZhY2UnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFzc3VtZXMgaXQgaXMgZXhlY3V0ZWQgaW5zaWRlIGEgc2FuZGJveCBhbmQgdGhhdCBleGlzdHMgYW4gb2JqZWN0IFwibG9nZ2VyXCIgb24gXCJnbG9iYWxcIiB3aXRoIGEgbWV0aG9kIFwic2VuZFwiLlxyXG4gKiBTYW5kYm94ZXMgY2FuJ3QgY29ubmVjdCBkaXJlY3RseSB0byBaZXJvTVEgdGhlcmVmb3JlIHRoaXMganVzdCByZWxheXMgdGhlIG1lc3NhZ2Ugb3V0c2lkZSB0aGUgc2FuZGJveC5cclxuICpcclxuICogQGltcGxlbWVudHMgVHJhbnNwb3J0SW50ZXJmYWNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTWVzc2FnZVB1Ymxpc2hlckZvclNhbmRib3goKSB7XHJcblxyXG4gICAgVHJhbnNwb3J0SW50ZXJmYWNlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFVCTElDIE1FVEhPRFMgKioqKioqKioqKioqKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ09iamVjdFxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgbG9nT2JqZWN0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZ2xvYmFsLmxvZ2dlci5zZW5kKFtjaGFubmVsLCBsb2dPYmplY3RdKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdoaWxlIHNlbmRpbmcgb3Igc2VyaWFsaXppbmcgbWVzc2FnZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VQdWJsaXNoZXJGb3JTYW5kYm94O1xyXG4iLCIvKipcclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxuZnVuY3Rpb24gVHJhbnNwb3J0SW50ZXJmYWNlKCkge1xyXG4gICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gKGNoYW5uZWwsIGxvZ09iamVjdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0SW50ZXJmYWNlO1xyXG4iLCJjb25zdCBUcmFuc3BvcnRJbnRlcmZhY2UgPSByZXF1aXJlKCcuL1RyYW5zcG9ydEludGVyZmFjZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBUcmFuc3BvcnRJbnRlcmZhY2VcclxufTtcclxuXHJcbmlmKHByb2Nlc3MuZW52LmNvbnRleHQgPT09ICdzYW5kYm94Jykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMuTWVzc2FnZVB1Ymxpc2hlciA9IHJlcXVpcmUoJy4vTWVzc2FnZVB1Ymxpc2hlckZvclNhbmRib3gnKTtcclxufSBlbHNlIHtcclxuICAgIG1vZHVsZS5leHBvcnRzLk1lc3NhZ2VQdWJsaXNoZXIgPSByZXF1aXJlKCcuL01lc3NhZ2VQdWJsaXNoZXInKTtcclxufVxyXG4iLCJjb25zdCB6ZXJvTVEgPSByZXF1aXJlKCd6ZXJvbXEnKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgWmVyb01RIFN1YnNjcmliZXIgdGhhdCBsaXN0ZW5zIGZvciBwcm92aWRlZCB0b3BpY3Mgb24gdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZvciBhIHB1Ymxpc2hlclxyXG4gKiBAcGFyYW0ge3N0cmluZyF9IGFkZHJlc3MgLSBCYXNlIGFkZHJlc3MgaW5jbHVkaW5nIHByb3RvY29sIGFuZCBwb3J0IChleDogdGNwOi8vMTI3LjAuMC4xOjgwODApXHJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPnxmdW5jdGlvbj99IHN1YnNjcmlwdGlvbnMgLSBhIGxpc3Qgb2Ygc3Vic2NyaXB0aW9uIHRvcGljcywgaWYgbWlzc2luZyBpdCB3aWxsIHN1YnNjcmliZSB0byBldmVyeXRoaW5nXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24hfSBvbk1lc3NhZ2VDYWxsYmFja1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE1lc3NhZ2VTdWJzY3JpYmVyKGFkZHJlc3MsIHN1YnNjcmlwdGlvbnMsIG9uTWVzc2FnZUNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCB6bXFTb2NrZXQgPSB6ZXJvTVEuY3JlYXRlU29ja2V0KCdzdWInKTtcclxuXHJcbiAgICAvLyB1bmNvbW1lbnQgbmV4dCBsaW5lIGlmIG1lc3NhZ2VzIGFyZSBsb3N0XHJcbiAgICAvLyB6bXFTb2NrZXQuc2V0c29ja29wdCh6ZXJvTVEuWk1RX1JDVkhXTSwgMCk7XHJcblxyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uTWVzc2FnZUNhbGxiYWNrID0gc3Vic2NyaXB0aW9ucztcclxuICAgICAgICBzdWJzY3JpcHRpb25zID0gWycnXTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHptcVNvY2tldC5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uKSk7XHJcblxyXG4gICAgem1xU29ja2V0LmNvbm5lY3QoYWRkcmVzcyk7XHJcblxyXG4gICAgem1xU29ja2V0Lm9uKCdtZXNzYWdlJywgb25NZXNzYWdlQ2FsbGJhY2spO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50cyA9IFtcIlNJR0lOVFwiLCBcIlNJR1VTUjFcIiwgXCJTSUdVU1IyXCIsIFwidW5jYXVnaHRFeGNlcHRpb25cIiwgXCJTSUdURVJNXCIsIFwiU0lHSFVQXCJdO1xyXG5cclxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICBwcm9jZXNzLm9uKGV2ZW50LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHptcVNvY2tldC5jbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVN1YnNjcmliZXI7XHJcbiIsImNvbnN0IE1lc3NhZ2VTdWJzY3JpYmVyID0gcmVxdWlyZSgnLi9NZXNzYWdlU3Vic2NyaWJlcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7TWVzc2FnZVN1YnNjcmliZXJ9O1xyXG4iLCJjb25zdCBMb2dnZXJDbGllbnRNb2R1bGUgPSByZXF1aXJlKCcuLi9Mb2dnZXJDbGllbnQnKTtcclxuXHJcbmNvbnN0IExvZ2dlckNsaWVudCA9IExvZ2dlckNsaWVudE1vZHVsZS5Mb2dnZXJDbGllbnQ7XHJcbmNvbnN0IExvZ2dlckludGVyZmFjZSA9IExvZ2dlckNsaWVudE1vZHVsZS5Mb2dnZXJJbnRlcmZhY2U7XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXNzYWdlUHVibGlzaGVyXHJcbiAqIEBpbXBsZW1lbnRzIExvZ2dlckludGVyZmFjZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEdlbmVyaWNQU0tMb2dnZXIobWVzc2FnZVB1Ymxpc2hlcikge1xyXG4gICAgTG9nZ2VySW50ZXJmYWNlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlckNsaWVudChtZXNzYWdlUHVibGlzaGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBkZWJ1ZyguLi5wYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBtZXRhID0gcHJlcGFyZU1ldGEoKTtcclxuICAgICAgICByZXR1cm4gbG9nZ2VyLmRlYnVnKG1ldGEsIC4uLnBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXJyb3IoLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YSA9IHByZXBhcmVNZXRhKCk7XHJcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihtZXRhLCAuLi5wYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluZm8oLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YSA9IHByZXBhcmVNZXRhKCk7XHJcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5pbmZvKG1ldGEsIC4uLnBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9nKC4uLnBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xyXG4gICAgICAgIHJldHVybiBsb2dnZXIubG9nKG1ldGEsIC4uLnBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2FybiguLi5wYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBtZXRhID0gcHJlcGFyZU1ldGEoKTtcclxuICAgICAgICByZXR1cm4gbG9nZ2VyLndhcm4obWV0YSwgLi4ucGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBldmVudChldmVudCwgLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YSA9IHByZXBhcmVNZXRhKCk7XHJcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5ldmVudChldmVudCwgbWV0YSwgcGFyYW1zKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcmVkaXJlY3QobG9nVHlwZSwgbG9nT2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgbG9nTWV0YSA9IGxvZ09iamVjdC5tZXRhO1xyXG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWV0YSwgbG9nTWV0YSk7XHJcblxyXG4gICAgICAgIGxvZ09iamVjdC5tZXRhID0gbWV0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5yZWRpcmVjdChsb2dUeXBlLCBsb2dPYmplY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByZXBhcmVNZXRhKCkge1xyXG4gICAgICAgIGlmIChnbG9iYWwuJCQuZ2V0RW52aXJvbm1lbnREYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwuJCQuZ2V0RW52aXJvbm1lbnREYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdGhpcy5kZWJ1ZyAgICA9IGRlYnVnO1xyXG4gICAgdGhpcy5lcnJvciAgICA9IGVycm9yO1xyXG4gICAgdGhpcy5ldmVudCAgICA9IGV2ZW50O1xyXG4gICAgdGhpcy5pbmZvICAgICA9IGluZm87XHJcbiAgICB0aGlzLmxvZyAgICAgID0gbG9nO1xyXG4gICAgdGhpcy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xyXG4gICAgdGhpcy53YXJuICAgICA9IHdhcm47XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNQU0tMb2dnZXI7XHJcbiIsImNvbnN0IENvbmZpZ3VyYXRvciAgICAgPSByZXF1aXJlKCcuLi91dGlscy9Db25maWd1cmF0b3InKTtcclxuY29uc3QgR2VuZXJpY1BTS0xvZ2dlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1BTS0xvZ2dlcicpO1xyXG5jb25zdCBNZXNzYWdlUHVibGlzaGVyID0gcmVxdWlyZSgnLi4vTWVzc2FnZVB1Ymxpc2hlcicpLk1lc3NhZ2VQdWJsaXNoZXI7XHJcblxyXG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XHJcbiAgICBsZXQgbWVzc2FnZVB1Ymxpc2hlcjtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuY29udGV4dCA9PT0gJ3NhbmRib3gnKSB7XHJcblxyXG4gICAgICAgIG1lc3NhZ2VQdWJsaXNoZXIgPSBuZXcgTWVzc2FnZVB1Ymxpc2hlcigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSBDb25maWd1cmF0b3IuZ2V0Q29uZmlnKCk7XHJcbiAgICAgICAgbWVzc2FnZVB1Ymxpc2hlciA9IG5ldyBNZXNzYWdlUHVibGlzaGVyKGNvbmZpZy5hZGRyZXNzRm9yUHVibGlzaGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBHZW5lcmljUFNLTG9nZ2VyKG1lc3NhZ2VQdWJsaXNoZXIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldExvZ2dlclxyXG59O1xyXG4iLCJjb25zdCB6ZXJvTVEgPSByZXF1aXJlKCd6ZXJvbXEnKTtcclxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG5cclxuLyoqXHJcbiAqIFByb3h5IGJldHdlZW4gcHVibGlzaGVycyBhbmQgc3Vic2NyaWJlcnMgdG8gYXZvaWQgc3RhciB0b3BvbG9neSBjb21tdW5pY2F0aW9uXHJcbiAqIFN1YnNjcmliZXJzIHNob3VsZCBjb25uZWN0IGZpcnN0IG90aGVyd2lzZSBubyBzdWJzY3JpcHRpb24gcmVxdWVzdCB3aWxsIGJlIHNlbnQgdG8gcHVibGlzaGVycyBhbmQgdGhlcmVmb3JlIHRoZXlcclxuICogd29uJ3QgZXZlbiBzZW5kIHRoZSBtZXNzYWdlcyB0byB0aGUgcHJveHkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgZmlsdGVyaW5nIGlzIGRvbmUgb24gdGhlIHB1Ymxpc2hlciBmb3IgdGNwIG9yIGlwYyxcclxuICogdmlldyBodHRwOi8vemd1aWRlLnplcm9tcS5vcmcvcGFnZTphbGwjR2V0dGluZy10aGUtTWVzc2FnZS1PdXQgZm9yIG1vcmUgaW5mb1xyXG4gKiBAcGFyYW0ge3N0cmluZyF9IGFkZHJlc3NGb3JQdWJsaXNoZXJzIC0gQmFzZSBhZGRyZXNzIGluY2x1ZGluZyBwcm90b2NvbCBhbmQgcG9ydCAoZXg6IHRjcDovLzEyNy4wLjAuMTo4MDgwKVxyXG4gKiBAcGFyYW0ge3N0cmluZyF9IGFkZHJlc3NGb3JTdWJzY3JpYmVycyAtIEJhc2UgYWRkcmVzcyBpbmNsdWRpbmcgcHJvdG9jb2wgYW5kIHBvcnQgKGV4OiB0Y3A6Ly8xMjcuMC4wLjE6ODA4MClcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBQdWJTdWJQcm94eSh7YWRkcmVzc0ZvclB1Ymxpc2hlcnMsIGFkZHJlc3NGb3JTdWJzY3JpYmVyc30pIHtcclxuICAgIGNvbnN0IGZyb250ZW5kID0gemVyb01RLmNyZWF0ZVNvY2tldCgneHN1YicpO1xyXG4gICAgY29uc3QgYmFja2VuZCA9IHplcm9NUS5jcmVhdGVTb2NrZXQoJ3hwdWInKTtcclxuICAgIGNvbnN0IGJ1ZmZlcmVkQmFja2VuZCA9IG5ldyB1dGlscy5CdWZmZXJlZFNvY2tldChiYWNrZW5kLCB1dGlscy5Tb2NrZXRUeXBlLmJpbmRhYmxlKTtcclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0IHhwdWIgb25seSBzaWduYWxzIG5ldyBzdWJzY3JpcHRpb25zXHJcbiAgICAvLyBTZXR0aW5ncyBpdCB0byB2ZXJib3NlID0gMSAsIHdpbGwgc2lnbmFsIG9uIGV2ZXJ5IG5ldyBzdWJzY3JpYmVcclxuICAgIC8vIHVuY29tbWVudCBuZXh0IGxpbmVzIGlmIG1lc3NhZ2VzIGFyZSBsb3N0XHJcbiAgICAvLyBiYWNrZW5kLnNldHNvY2tvcHQoemVyb01RLlpNUV9YUFVCX1ZFUkJPU0UsIDEpO1xyXG4gICAgLy8gYmFja2VuZC5zZXRzb2Nrb3B0KHplcm9NUS5aTVFfU05ESFdNLCAwKTtcclxuICAgIC8vIGJhY2tlbmQuc2V0c29ja29wdCh6ZXJvTVEuWk1RX1JDVkhXTSwgMCk7XHJcbiAgICAvLyBmcm9udGVuZC5zZXRzb2Nrb3B0KHplcm9NUS5aTVFfUkNWSFdNLCAwKTtcclxuICAgIC8vIGZyb250ZW5kLnNldHNvY2tvcHQoemVyb01RLlpNUV9TTkRIV00sIDApO1xyXG5cclxuICAgIC8vIFdoZW4gd2UgcmVjZWl2ZSBkYXRhIG9uIGZyb250ZW5kLCBpdCBtZWFucyBzb21lb25lIGlzIHB1Ymxpc2hpbmdcclxuICAgIGZyb250ZW5kLm9uKCdtZXNzYWdlJywgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBXZSBqdXN0IHJlbGF5IGl0IHRvIHRoZSBiYWNrZW5kLCBzbyBzdWJzY3JpYmVycyBjYW4gcmVjZWl2ZSBpdFxyXG4gICAgICAgIGJ1ZmZlcmVkQmFja2VuZC5zZW5kKGFyZ3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2hlbiBiYWNrZW5kIHJlY2VpdmVzIGEgbWVzc2FnZSwgaXQncyBzdWJzY3JpYmUgcmVxdWVzdHNcclxuICAgIGJhY2tlbmQub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgIC8vIFdlIHNlbmQgaXQgdG8gZnJvbnRlbmQsIHNvIGl0IGtub3dzIHRvIHdoYXQgY2hhbm5lbHMgdG8gbGlzdGVuIHRvXHJcbiAgICAgICAgZnJvbnRlbmQuc2VuZChkYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqIE1PTklUT1IgU09DS0VUICoqKioqKioqKioqKiovXHJcblxyXG4gICAgZnJvbnRlbmQuYmluZFN5bmMoYWRkcmVzc0ZvclB1Ymxpc2hlcnMpO1xyXG4gICAgYmFja2VuZC5iaW5kU3luYyhhZGRyZXNzRm9yU3Vic2NyaWJlcnMpO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50cyA9IFtcIlNJR0lOVFwiLCBcIlNJR1VTUjFcIiwgXCJTSUdVU1IyXCIsIFwidW5jYXVnaHRFeGNlcHRpb25cIiwgXCJTSUdURVJNXCIsIFwiU0lHSFVQXCJdO1xyXG5cclxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICBwcm9jZXNzLm9uKGV2ZW50LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGZyb250ZW5kLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGJhY2tlbmQuY2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFB1YlN1YlByb3h5O1xyXG4iLCJjb25zdCBQdWJTdWJQcm94eSA9IHJlcXVpcmUoJy4vUHViU3ViUHJveHknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1B1YlN1YlByb3h5fTtcclxuIiwiY29uc3QgU29ja2V0VHlwZSA9IHJlcXVpcmUoJy4vU29ja2V0VHlwZScpO1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXIgZm9yIFplcm9NUSBzb2NrZXQgdGhhdCB0cmllcyB0byBwcmV2ZW50ICdzbG93IGpvaW5lcicsIG1lYW5pbmcgaXQgYnVmZmVycyB0aGUgZmlyc3QgbWVzc2FnZXMgdW50aWwgdGhlXHJcbiAqIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIG90aGVyd2lzZSB0aGUgZmlyc3QgbWVzc2FnZXMgd291bGQgYmUgbG9zdFxyXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0IC0gaW5zdGFuY2Ugb2YgWmVyb01RIFNvY2tldFxyXG4gKiBAcGFyYW0ge1NvY2tldFR5cGU8bnVtYmVyPn0gdHlwZSAtIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHNob3VsZCBsaXN0ZW4gZm9yICdjb25uZWN0JyBvciAnYWNjZXB0JyBldmVudFxyXG4gKiBAcGFyYW0ge051bWJlcj99IG1heFNpemUgPSAxMDAwIC0gTWF4IHNpemUgZm9yIHRoZSBpbnRlcm5hbCBidWZmZXIsIGlmIDAgdGhlIGJ1ZmZlciBpcyBpbmZpbml0ZSBidXQgY2FuIGNhdXNlIG1lbW9yeSBsZWFrXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQnVmZmVyZWRTb2NrZXQoc29ja2V0LCB0eXBlLCBtYXhTaXplID0gMTAwMDApIHtcclxuICAgIGlmKG1heFNpemUgPCAwKSB7XHJcbiAgICAgICAgbWF4U2l6ZSA9IDEwMDA7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IFtdO1xyXG4gICAgbGV0IGlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICBsZXQgY3VycmVudEJ1ZmZlclNpemUgPSAwO1xyXG5cclxuICAgIHNvY2tldC5tb25pdG9yKCk7XHJcbiAgICBjb25zdCBldmVudCA9IF9nZXRFdmVudEZvclR5cGUodHlwZSk7XHJcblxyXG4gICAgc29ja2V0Lm9uKGV2ZW50LCAoKSA9PiB7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIF9mbHVzaFF1ZXVlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKiBQVUJMSUMgTUVUSE9EUyAqKioqKioqKioqKioqL1xyXG5cclxuICAgIGZ1bmN0aW9uIHNlbmQobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKG1heFNpemUgIT09IDAgJiYgY3VycmVudEJ1ZmZlclNpemUgPCBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QnVmZmVyU2l6ZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb2NrZXQuc2VuZChtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKiogUFJJVkFURSBNRVRIT0RTICoqKioqKioqKioqKiovXHJcblxyXG4gICAgZnVuY3Rpb24gX2ZsdXNoUXVldWUoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VRdWV1ZSkge1xyXG4gICAgICAgICAgICBzb2NrZXQuc2VuZChtZXNzYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1lc3NhZ2VRdWV1ZSA9IFtdO1xyXG4gICAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0RXZlbnRGb3JUeXBlKHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gU29ja2V0VHlwZS5jb25uZWN0YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Nvbm5lY3QnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gU29ja2V0VHlwZS5iaW5kYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2FjY2VwdCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqIEVYUE9SVFMgKioqKioqKioqKioqKi9cclxuXHJcbiAgICB0aGlzLnNlbmQgPSBzZW5kO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNvY2tldDtcclxuIiwiY29uc3QgY29uZmlnID0ge1xyXG4gICAgYWRkcmVzc0ZvclB1Ymxpc2hlcnM6ICd0Y3A6Ly8xMjcuMC4wLjE6NzAwMCcsXHJcbiAgICBhZGRyZXNzRm9yU3Vic2NyaWJlcnM6ICd0Y3A6Ly8xMjcuMC4wLjE6NzAwMScsXHJcbiAgICBhZGRyZXNzRm9yQ29sbGVjdG9yOiAndGNwOi8vMTI3LjAuMC4xOjU1NTgnXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldENvbmZpZyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoY29uZmlnKTtcclxuICAgIH1cclxufTtcclxuIiwiXHJcblxyXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudERhdGEgKCkge1xyXG4gICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuICAgIGNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKTtcclxuXHJcbiAgICBjb25zdCBwcm9jZXNzUGF0aCA9IHByb2Nlc3MuYXJndlsxXTtcclxuICAgIGNvbnN0IGxhc3RTZXAgPSBwcm9jZXNzUGF0aC5sYXN0SW5kZXhPZihwYXRoLnNlcCk7XHJcbiAgICBjb25zdCBwcm9jZXNzU3RhcnRGaWxlID0gcHJvY2Vzc1BhdGguc3Vic3RyaW5nKGxhc3RTZXAgKyAxKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3JpZ2luOiAnbm9kZScsXHJcbiAgICAgICAgY29udGV4dDogcHJvY2Vzc1N0YXJ0RmlsZSxcclxuICAgICAgICBwcm9jZXNzU3RhcnRGaWxlOiBwcm9jZXNzU3RhcnRGaWxlLFxyXG4gICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnREYXRhRm9yRG9tYWluKCkge1xyXG4gICAgY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3JpZ2luOiAnZG9tYWluJyxcclxuICAgICAgICBkb21haW46IHByb2Nlc3MuZW52LlBSSVZBVEVTS1lfRE9NQUlOX05BTUUsXHJcbiAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEVudmlyb25tZW50RGF0YUZvckFnZW50KCkge1xyXG4gICAgY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3JpZ2luOiAnYWdlbnQnLFxyXG4gICAgICAgIGRvbWFpbjogcHJvY2Vzcy5lbnYuUFJJVkFURVNLWV9ET01BSU5fTkFNRSxcclxuICAgICAgICBhZ2VudDogcHJvY2Vzcy5lbnYuUFJJVkFURVNLWV9BR0VOVF9OQU1FLFxyXG4gICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudERhdGFGb3JTYW5kYm94KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvcmlnaW46ICdzYW5kYm94J1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldEVudmlyb25tZW50RGF0YSxcclxuICAgIGdldEVudmlyb25tZW50RGF0YUZvckFnZW50LFxyXG4gICAgZ2V0RW52aXJvbm1lbnREYXRhRm9yRG9tYWluLFxyXG4gICAgZ2V0RW52aXJvbm1lbnREYXRhRm9yU2FuZGJveFxyXG59O1xyXG4iLCJjb25zdCBMb2dMZXZlbCA9IHt9O1xyXG5cclxuTG9nTGV2ZWxbTG9nTGV2ZWxbXCJlcnJvclwiXSA9IDBdID0gXCJlcnJvclwiO1xyXG5Mb2dMZXZlbFtMb2dMZXZlbFtcIndhcm5cIl0gID0gMV0gPSBcIndhcm5cIjtcclxuTG9nTGV2ZWxbTG9nTGV2ZWxbXCJpbmZvXCJdICA9IDJdID0gXCJpbmZvXCI7XHJcbkxvZ0xldmVsW0xvZ0xldmVsW1wiZGVidWdcIl0gPSAzXSA9IFwiZGVidWdcIjtcclxuTG9nTGV2ZWxbTG9nTGV2ZWxbXCJsb2dcIl0gICA9IDRdID0gXCJsb2dcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShMb2dMZXZlbCk7XHJcbiIsImNvbnN0IFNvY2tldFR5cGUgPSB7fTtcclxuU29ja2V0VHlwZVtTb2NrZXRUeXBlW1wiY29ubmVjdGFibGVcIl0gPSAwXSA9IFwiY29ubmVjdGFibGVcIjsgLy8gaWYgLmNvbm5lY3QgaXMgY2FsbGVkIG9uIHNvY2tldFxyXG5Tb2NrZXRUeXBlW1NvY2tldFR5cGVbXCJiaW5kYWJsZVwiXSA9IDFdID0gXCJiaW5kYWJsZVwiOyAvLyBpZiAuYmluZCBpcyBjYWxsZWQgb24gc29ja2V0XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoU29ja2V0VHlwZSk7XHJcbiIsImNvbnN0IENvbmZpZ3VyYXRvciAgICAgICAgICAgID0gcmVxdWlyZSgnLi9Db25maWd1cmF0b3InKTtcclxuY29uc3QgRW52aXJvbm1lbnREYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuL0Vudmlyb25tZW50RGF0YVByb3ZpZGVyJyk7XHJcbmNvbnN0IExvZ0xldmVsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9Mb2dMZXZlbCcpO1xyXG5jb25zdCBCdWZmZXJlZFNvY2tldCAgICAgICAgICA9IHJlcXVpcmUoJy4vQnVmZmVyZWRTb2NrZXQnKTtcclxuY29uc3QgU29ja2V0VHlwZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL1NvY2tldFR5cGUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ29uZmlndXJhdG9yLFxyXG4gICAgRW52aXJvbm1lbnREYXRhUHJvdmlkZXIsXHJcbiAgICBMb2dMZXZlbCxcclxuICAgIEJ1ZmZlcmVkU29ja2V0LFxyXG4gICAgU29ja2V0VHlwZVxyXG59O1xyXG4iLCIvKlxyXG5Jbml0aWFsIExpY2Vuc2U6IChjKSBBeGlvbG9naWMgUmVzZWFyY2ggJiBBbGJvYWllIFPDrm5pY8SDLlxyXG5Db250cmlidXRvcnM6IEF4aW9sb2dpYyBSZXNlYXJjaCAsIFByaXZhdGVTa3kgcHJvamVjdFxyXG5Db2RlIExpY2Vuc2U6IExHUEwgb3IgTUlULlxyXG4qL1xyXG5cclxuXHJcbi8qKlxyXG4gKiAgIFVzdWFsbHkgYW4gZXZlbnQgY291bGQgY2F1c2UgZXhlY3V0aW9uIG9mIG90aGVyIGNhbGxiYWNrIGV2ZW50cyAuIFdlIHNheSB0aGF0IGlzIGEgbGV2ZWwgMSBldmVudCBpZiBpcyBjYXVzZWVkIGJ5IGEgbGV2ZWwgMCBldmVudCBhbmQgc28gb25cclxuICpcclxuICogICAgICBTb3VuZFB1YlN1YiBwcm92aWRlcyBpbnR1aXRpdmUgcmVzdWx0cyByZWdhcmRpbmcgdG8gYXN5bmNocm9ub3VzIGNhbGxzIG9mIGNhbGxiYWNrcyBhbmQgY29tcHV0ZWQgdmFsdWVzL2V4cHJlc3Npb25zOlxyXG4gKiAgIHdlIHByZXZlbnQgaW1tZWRpYXRlIGV4ZWN1dGlvbiBvZiBldmVudCBjYWxsYmFja3MgdG8gZW5zdXJlIHRoZSBpbnR1aXRpdmUgZmluYWwgcmVzdWx0IGlzIGd1YXJhbnRlZWQgYXMgbGV2ZWwgMCBleGVjdXRpb25cclxuICogICB3ZSBndWFyYW50ZWUgdGhhdCBhbnkgY2FsbGJhY2sgZnVuY3Rpb24gaXMgXCJyZS1lbnRyYW50XCJcclxuICogICB3ZSBhcmUgYWxzbyB0cnlpbmcgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IGxvb2tpbmcgaW4gcXVldWVzIGF0IG5ldyBtZXNzYWdlcyBwdWJsaXNoZWQgYnlcclxuICogICB0cnlpbmcgdG8gY29tcGFjdCB0aG9zZSBtZXNzYWdlcyAocmVtb3ZpbmcgZHVwbGljYXRlIG1lc3NhZ2VzLCBtb2RpZnlpbmcgbWVzc2FnZXMsIG9yIGFkZGluZyBpbiB0aGUgaGlzdG9yeSBvZiBhbm90aGVyIGV2ZW50ICxldGMpXHJcbiAqXHJcbiAqICAgICAgRXhhbXBsZSBvZiB3aGF0IGNhbiBiZSB3cm9uZyB3aXRob3V0IG5vbi1zb3VuZCBhc3luY2hyb25vdXMgY2FsbHM6XHJcbiAqXHJcbiAqICBTdGVwIDA6IEluaXRpYWwgc3RhdGU6XHJcbiAqICAgYSA9IDA7XHJcbiAqICAgYiA9IDA7XHJcbiAqXHJcbiAqICBTdGVwIDE6IEluaXRpYWwgb3BlcmF0aW9uczpcclxuICogICBhID0gMTtcclxuICogICBiID0gLTE7XHJcbiAqXHJcbiAqICAvLyBhbiBvYnNlcnZlciByZWFjdHMgdG8gY2hhbmdlcyBpbiBhIGFuZCBiIGFuZCBjb21wdXRlIENPUlJFQ1QgbGlrZSB0aGlzOlxyXG4gKiAgIGlmKCBhICsgYiA9PSAwKSB7XHJcbiAqICAgICAgIENPUlJFQ1QgPSBmYWxzZTtcclxuICogICAgICAgbm90aWZ5KC4uLik7IC8vIGFjdCBvciBzZW5kIGEgbm90aWZpY2F0aW9uIHNvbWV3aGVyZS4uXHJcbiAqICAgfSBlbHNlIHtcclxuICogICAgICBDT1JSRUNUID0gZmFsc2U7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgICBOb3RpY2UgdGhhdDogQ09SUkVDVCB3aWxsIGJlIHRydWUgaW4gdGhlIGVuZCAsIGJ1dCBtZWFudGltZSwgYWZ0ZXIgYSBub3RpZmljYXRpb24gd2FzIHNlbnQgYW5kIENPUlJFQ1Qgd2FzIHdyb25nbHksIHRlbXBvcmFyaWx5IGZhbHNlIVxyXG4gKiAgICBzb3VuZFB1YlN1YiBndWFyYW50ZWUgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlbiBiZWNhdXNlIHRoZSBzeW5jcm9ub3VzIGNhbGwgd2lsbCBiZWZvcmUgYW55IG9ic2VydmVyIChib3QgYXNpZ25hdGlvbiBvbiBhIGFuZCBiKVxyXG4gKlxyXG4gKiAgIE1vcmU6XHJcbiAqICAgeW91IGNhbiB1c2UgYmxvY2tDYWxsQmFja3MgYW5kIHJlbGVhc2VDYWxsQmFja3MgaW4gYSBmdW5jdGlvbiB0aGF0IGNoYW5nZSBhIGxvdCBhIGNvbGxlY3Rpb24gb3IgYmluZGFibGUgb2JqZWN0cyBhbmQgYWxsXHJcbiAqICAgdGhlIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBzZW50IGNvbXBhY3RlZCBhbmQgcHJvcGVybHlcclxuICovXHJcblxyXG4vLyBUT0RPOiBvcHRpbWlzYXRpb24hPyB1c2UgYSBtb3JlIGVmZmljaWVudCBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5cyB3aXRoIHB1c2ggYW5kIHNoaWZ0IT9cclxuLy8gVE9ETzogc2VlIGhvdyBiaWcgdGhvc2UgcXVldWVzIGNhbiBiZSBpbiByZWFsIGFwcGxpY2F0aW9uc1xyXG4vLyBmb3IgYSBmZXcgaHVuZHJlZHMgaXRlbXMsIHF1ZXVlcyBtYWRlIGZyb20gYXJyYXkgc2hvdWxkIGJlIGVub3VnaFxyXG4vLyogICBQb3RlbnRpYWwgVE9ET3M6XHJcbi8vICAgICogICAgIHByZXZlbnQgYW55IGZvcm0gb2YgcHJvYmxlbSBieSBjYWxsaW5nIGNhbGxiYWNrcyBpbiB0aGUgZXhwZWN0ZWQgb3JkZXIgIT9cclxuLy8qICAgICBwcmV2ZW50aW5nIGluZmluaXRlIGxvb3BzIGV4ZWN1dGlvbiBjYXVzZSBieSBldmVudHMhP1xyXG4vLypcclxuLy8qXHJcbi8vIFRPRE86IGRldGVjdCBpbmZpbml0ZSBsb29wcyAob3IgdmVyeSBkZWVwIHByb3BhZ2F0aW9uKSBJdCBpcyBwb3NzaWJsZSE/XHJcblxyXG5jb25zdCBRdWV1ZSA9IHJlcXVpcmUoJ3N3YXJtdXRpbHMnKS5RdWV1ZTtcclxuXHJcbmZ1bmN0aW9uIFNvdW5kUHViU3ViKCl7XHJcblxyXG5cdC8qKlxyXG5cdCAqIHB1Ymxpc2hcclxuXHQgKiAgICAgIFB1Ymxpc2ggYSBtZXNzYWdlIHtPYmplY3R9IHRvIGEgbGlzdCBvZiBzdWJzY3JpYmVycyBvbiBhIHNwZWNpZmljIHRvcGljXHJcblx0ICpcclxuXHQgKiBAcGFyYW1zIHtTdHJpbmd8TnVtYmVyfSB0YXJnZXQsICB7T2JqZWN0fSBtZXNzYWdlXHJcblx0ICogQHJldHVybiBudW1iZXIgb2YgY2hhbm5lbCBzdWJzY3JpYmVycyB0aGF0IHdpbGwgYmUgbm90aWZpZWRcclxuXHQgKi9cclxuXHR0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbih0YXJnZXQsIG1lc3NhZ2Upe1xyXG5cdFx0aWYoIWludmFsaWRDaGFubmVsTmFtZSh0YXJnZXQpICYmICFpbnZhbGlkTWVzc2FnZVR5cGUobWVzc2FnZSkgJiYgKHR5cGVvZiBjaGFubmVsU3Vic2NyaWJlcnNbdGFyZ2V0XSAhPSAndW5kZWZpbmVkJykpe1xyXG5cdFx0XHRjb21wYWN0QW5kU3RvcmUodGFyZ2V0LCBtZXNzYWdlKTtcclxuXHRcdFx0c2V0VGltZW91dChkaXNwYXRjaE5leHQsIDApO1xyXG5cdFx0XHRyZXR1cm4gY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF0ubGVuZ3RoO1xyXG5cdFx0fSBlbHNle1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBzdWJzY3JpYmVcclxuXHQgKiAgICAgIFN1YnNjcmliZSAvIGFkZCBhIHtGdW5jdGlvbn0gY2FsbEJhY2sgb24gYSB7U3RyaW5nfE51bWJlcn10YXJnZXQgY2hhbm5lbCBzdWJzY3JpYmVycyBsaXN0IGluIG9yZGVyIHRvIHJlY2VpdmVcclxuXHQgKiAgICAgIG1lc3NhZ2VzIHB1Ymxpc2hlZCBpZiB0aGUgY29uZGl0aW9ucyBkZWZpbmVkIGJ5IHtGdW5jdGlvbn13YWl0Rm9yTW9yZSBhbmQge0Z1bmN0aW9ufWZpbHRlciBhcmUgcGFzc2VkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtcyB7U3RyaW5nfE51bWJlcn10YXJnZXQsIHtGdW5jdGlvbn1jYWxsQmFjaywge0Z1bmN0aW9ufXdhaXRGb3JNb3JlLCB7RnVuY3Rpb259ZmlsdGVyXHJcblx0ICpcclxuXHQgKiAgICAgICAgICB0YXJnZXQgICAgICAtIGNoYW5uZWwgbmFtZSB0byBzdWJzY3JpYmVcclxuXHQgKiAgICAgICAgICBjYWxsYmFjayAgICAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGEgbWVzc2FnZSB3YXMgcHVibGlzaGVkIG9uIHRoZSBjaGFubmVsXHJcblx0ICogICAgICAgICAgd2FpdEZvck1vcmUgLSBhIGludGVybWVkaWFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgc3VjY2Vzc2Z1bHkgbWVzc2FnZSBkZWxpdmVyeSBpbiBvcmRlclxyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0byBkZWNpZGUgaWYgYSBuZXcgbWVzc2FnZXMgaXMgZXhwZWN0ZWQuLi5cclxuXHQgKiAgICAgICAgICBmaWx0ZXIgICAgICAtIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVzc2FnZSBiZWZvcmUgaW52b2NhdGlvbiBvZiBjYWxsYmFjayBmdW5jdGlvbiBpbiBvcmRlciB0byBhbGxvd1xyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICByZWxldmFudCBtZXNzYWdlIGJlZm9yZSBlbnRlcmluZyBpbiBub3JtYWwgY2FsbGJhY2sgZmxvd1xyXG5cdCAqIEByZXR1cm5cclxuXHQgKi9cclxuXHR0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRhcmdldCwgY2FsbEJhY2ssIHdhaXRGb3JNb3JlLCBmaWx0ZXIpe1xyXG5cdFx0aWYoIWludmFsaWRDaGFubmVsTmFtZSh0YXJnZXQpICYmICFpbnZhbGlkRnVuY3Rpb24oY2FsbEJhY2spKXtcclxuXHRcdFx0dmFyIHN1YnNjcmliZXIgPSB7XCJjYWxsQmFja1wiOmNhbGxCYWNrLCBcIndhaXRGb3JNb3JlXCI6d2FpdEZvck1vcmUsIFwiZmlsdGVyXCI6ZmlsdGVyfTtcclxuXHRcdFx0dmFyIGFyciA9IGNoYW5uZWxTdWJzY3JpYmVyc1t0YXJnZXRdO1xyXG5cdFx0XHRpZih0eXBlb2YgYXJyID09ICd1bmRlZmluZWQnKXtcclxuXHRcdFx0XHRhcnIgPSBbXTtcclxuXHRcdFx0XHRjaGFubmVsU3Vic2NyaWJlcnNbdGFyZ2V0XSA9IGFycjtcclxuXHRcdFx0fVxyXG5cdFx0XHRhcnIucHVzaChzdWJzY3JpYmVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiB1bnN1YnNjcmliZVxyXG5cdCAqICAgICAgVW5zdWJzY3JpYmUvcmVtb3ZlIHtGdW5jdGlvbn0gY2FsbEJhY2sgZnJvbSB0aGUgbGlzdCBvZiBzdWJzY3JpYmVycyBvZiB0aGUge1N0cmluZ3xOdW1iZXJ9IHRhcmdldCBjaGFubmVsXHJcblx0ICpcclxuXHQgKiBAcGFyYW1zIHtTdHJpbmd8TnVtYmVyfSB0YXJnZXQsIHtGdW5jdGlvbn0gY2FsbEJhY2ssIHtGdW5jdGlvbn0gZmlsdGVyXHJcblx0ICpcclxuXHQgKiAgICAgICAgICB0YXJnZXQgICAgICAtIGNoYW5uZWwgbmFtZSB0byB1bnN1YnNjcmliZVxyXG5cdCAqICAgICAgICAgIGNhbGxiYWNrICAgIC0gcmVmZXJlbmNlIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0aGF0IHdhcyB1c2VkIGFzIHN1YnNjcmliZVxyXG5cdCAqICAgICAgICAgIGZpbHRlciAgICAgIC0gcmVmZXJlbmNlIG9mIHRoZSBvcmlnaW5hbCBmaWx0ZXIgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJuXHJcblx0ICovXHJcblx0dGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRhcmdldCwgY2FsbEJhY2ssIGZpbHRlcil7XHJcblx0XHRpZighaW52YWxpZEZ1bmN0aW9uKGNhbGxCYWNrKSl7XHJcblx0XHRcdHZhciBnb3RpdCA9IGZhbHNlO1xyXG5cdFx0XHRpZihjaGFubmVsU3Vic2NyaWJlcnNbdGFyZ2V0XSl7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNoYW5uZWxTdWJzY3JpYmVyc1t0YXJnZXRdLmxlbmd0aDtpKyspe1xyXG5cdFx0XHRcdFx0dmFyIHN1YnNjcmliZXIgPSAgY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF1baV07XHJcblx0XHRcdFx0XHRpZihzdWJzY3JpYmVyLmNhbGxCYWNrID09PSBjYWxsQmFjayAmJiAoIHR5cGVvZiBmaWx0ZXIgPT09ICd1bmRlZmluZWQnIHx8IHN1YnNjcmliZXIuZmlsdGVyID09PSBmaWx0ZXIgKSl7XHJcblx0XHRcdFx0XHRcdGdvdGl0ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0c3Vic2NyaWJlci5mb3JEZWxldGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyLmNhbGxCYWNrID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyLmZpbHRlciA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIWdvdGl0KXtcclxuXHRcdFx0XHR3cHJpbnQoXCJVbmFibGUgdG8gdW5zdWJzY3JpYmUgYSBjYWxsYmFjayB0aGF0IHdhcyBub3Qgc3Vic2NyaWJlZCFcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBibG9ja0NhbGxCYWNrc1xyXG5cdCAqXHJcblx0ICogQHBhcmFtc1xyXG5cdCAqIEByZXR1cm5cclxuXHQgKi9cclxuXHR0aGlzLmJsb2NrQ2FsbEJhY2tzID0gZnVuY3Rpb24oKXtcclxuXHRcdGxldmVsKys7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogcmVsZWFzZUNhbGxCYWNrc1xyXG5cdCAqXHJcblx0ICogQHBhcmFtc1xyXG5cdCAqIEByZXR1cm5cclxuXHQgKi9cclxuXHR0aGlzLnJlbGVhc2VDYWxsQmFja3MgPSBmdW5jdGlvbigpe1xyXG5cdFx0bGV2ZWwtLTtcclxuXHRcdC8vaGFjay9vcHRpbWlzYXRpb24gdG8gbm90IGZpbGwgdGhlIHN0YWNrIGluIGV4dHJlbWUgY2FzZXMgKG1hbnkgZXZlbnRzIGNhdXNlZCBieSBsb29wcyBpbiBjb2xsZWN0aW9ucyxldGMpXHJcblx0XHR3aGlsZShsZXZlbCA9PT0gMCAmJiBkaXNwYXRjaE5leHQodHJ1ZSkpe1xyXG5cdFx0XHQvL25vdGhpbmdcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZShsZXZlbCA9PT0gMCAmJiBjYWxsQWZ0ZXJBbGxFdmVudHMoKSl7XHJcbiAgICAgICAgICAgIC8vbm90aGluZ1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIGFmdGVyQWxsRXZlbnRzXHJcblx0ICpcclxuXHQgKiBAcGFyYW1zIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuXHQgKlxyXG5cdCAqICAgICAgICAgIGNhbGxiYWNrIC0gZnVuY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBpbnZva2VkIG9uY2UgYWxsIGV2ZW50cyBhcmUgZGVsaXZlcmVkXHJcblx0ICogQHJldHVyblxyXG5cdCAqL1xyXG5cdHRoaXMuYWZ0ZXJBbGxFdmVudHMgPSBmdW5jdGlvbihjYWxsQmFjayl7XHJcblx0XHRpZighaW52YWxpZEZ1bmN0aW9uKGNhbGxCYWNrKSl7XHJcblx0XHRcdGFmdGVyRXZlbnRzQ2FsbHMucHVzaChjYWxsQmFjayk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmJsb2NrQ2FsbEJhY2tzKCk7XHJcblx0XHR0aGlzLnJlbGVhc2VDYWxsQmFja3MoKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBoYXNDaGFubmVsXHJcblx0ICpcclxuXHQgKiBAcGFyYW1zIHtTdHJpbmd8TnVtYmVyfSBjaGFubmVsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICBjaGFubmVsIC0gbmFtZSBvZiB0aGUgY2hhbm5lbCB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkIGlmIHByZXNlbnRcclxuXHQgKiBAcmV0dXJuXHJcblx0ICovXHJcblx0dGhpcy5oYXNDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCl7XHJcblx0XHRyZXR1cm4gIWludmFsaWRDaGFubmVsTmFtZShjaGFubmVsKSAmJiAodHlwZW9mIGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsXSAhPSAndW5kZWZpbmVkJykgPyB0cnVlIDogZmFsc2U7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogYWRkQ2hhbm5lbFxyXG5cdCAqXHJcblx0ICogQHBhcmFtcyB7U3RyaW5nfSBjaGFubmVsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICBjaGFubmVsIC0gbmFtZSBvZiBhIGNoYW5uZWwgdGhhdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFuZCBhZGRlZCB0byBzb3VuZHB1YnN1YiByZXBvc2l0b3J5XHJcblx0ICogQHJldHVyblxyXG5cdCAqL1xyXG5cdHRoaXMuYWRkQ2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWwpe1xyXG5cdFx0aWYoIWludmFsaWRDaGFubmVsTmFtZShjaGFubmVsKSAmJiAhdGhpcy5oYXNDaGFubmVsKGNoYW5uZWwpKXtcclxuXHRcdFx0Y2hhbm5lbFN1YnNjcmliZXJzW2NoYW5uZWxdID0gW107XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwcm90ZWN0ZWQgc3R1ZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHQvLyBtYXAgY2hhbm5lbE5hbWUgKG9iamVjdCBsb2NhbCBpZCkgLT4gYXJyYXkgd2l0aCBzdWJzY3JpYmVyc1xyXG5cdHZhciBjaGFubmVsU3Vic2NyaWJlcnMgPSB7fTtcclxuXHJcblx0Ly8gbWFwIGNoYW5uZWxOYW1lIChvYmplY3QgbG9jYWwgaWQpIC0+IHF1ZXVlIHdpdGggd2FpdGluZyBtZXNzYWdlc1xyXG5cdHZhciBjaGFubmVsc1N0b3JhZ2UgPSB7fTtcclxuXHJcblx0Ly8gb2JqZWN0XHJcblx0dmFyIHR5cGVDb21wYWN0b3IgPSB7fTtcclxuXHJcblx0Ly8gY2hhbm5lbCBuYW1lc1xyXG5cdHZhciBleGVjdXRpb25RdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG5cdHZhciBsZXZlbCA9IDA7XHJcblxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogcmVnaXN0ZXJDb21wYWN0b3JcclxuXHQgKlxyXG5cdCAqICAgICAgIEFuIGNvbXBhY3RvciB0YWtlcyBhIG5ld0V2ZW50IGFuZCBhbmQgb2xkRXZlbnQgYW5kIHJldHVybiB0aGUgb25lIHRoYXQgc3Vydml2ZXMgKG9sZEV2ZW50IGlmXHJcblx0ICogIGl0IGNhbiBjb21wYWN0IHRoZSBuZXcgb25lIG9yIHRoZSBuZXdFdmVudCBpZiBjYW4ndCBiZSBjb21wYWN0ZWQpXHJcblx0ICpcclxuXHQgKiBAcGFyYW1zIHtTdHJpbmd9IHR5cGUsIHtGdW5jdGlvbn0gY2FsbEJhY2tcclxuXHQgKlxyXG5cdCAqICAgICAgICAgIHR5cGUgICAgICAgIC0gY2hhbm5lbCBuYW1lIHRvIHVuc3Vic2NyaWJlXHJcblx0ICogICAgICAgICAgY2FsbEJhY2sgICAgLSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50IHR5cGVcclxuXHQgKiBAcmV0dXJuXHJcblx0ICovXHJcblx0dGhpcy5yZWdpc3RlckNvbXBhY3RvciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxCYWNrKSB7XHJcblx0XHRpZighaW52YWxpZEZ1bmN0aW9uKGNhbGxCYWNrKSl7XHJcblx0XHRcdHR5cGVDb21wYWN0b3JbdHlwZV0gPSBjYWxsQmFjaztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBkaXNwYXRjaE5leHRcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBmcm9tUmVsZWFzZUNhbGxCYWNrczogaGFjayB0byBwcmV2ZW50IHRvbyBtYW55IHJlY3Vyc2l2ZSBjYWxscyBvbiByZWxlYXNlQ2FsbEJhY2tzXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBkaXNwYXRjaE5leHQoZnJvbVJlbGVhc2VDYWxsQmFja3Mpe1xyXG5cdFx0aWYobGV2ZWwgPiAwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGNoYW5uZWxOYW1lID0gZXhlY3V0aW9uUXVldWUuZnJvbnQoKTtcclxuXHRcdGlmKHR5cGVvZiBjaGFubmVsTmFtZSAhPSAndW5kZWZpbmVkJyl7XHJcblx0XHRcdHNlbGYuYmxvY2tDYWxsQmFja3MoKTtcclxuXHRcdFx0dHJ5e1xyXG5cdFx0XHRcdGxldCBtZXNzYWdlO1xyXG5cdFx0XHRcdGlmKCFjaGFubmVsc1N0b3JhZ2VbY2hhbm5lbE5hbWVdLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0bWVzc2FnZSA9IGNoYW5uZWxzU3RvcmFnZVtjaGFubmVsTmFtZV0uZnJvbnQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIG1lc3NhZ2UgPT0gJ3VuZGVmaW5lZCcpe1xyXG5cdFx0XHRcdFx0aWYoIWNoYW5uZWxzU3RvcmFnZVtjaGFubmVsTmFtZV0uaXNFbXB0eSgpKXtcclxuXHRcdFx0XHRcdFx0d3ByaW50KFwiQ2FuJ3QgdXNlIGFzIG1lc3NhZ2UgaW4gYSBwdWIvc3ViIGNoYW5uZWwgdGhpcyBvYmplY3Q6IFwiICsgbWVzc2FnZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRleGVjdXRpb25RdWV1ZS5wb3AoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIG1lc3NhZ2UuX190cmFuc21pc2lvbkluZGV4ID09ICd1bmRlZmluZWQnKXtcclxuXHRcdFx0XHRcdFx0bWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSBjaGFubmVsU3Vic2NyaWJlcnNbY2hhbm5lbE5hbWVdLmxlbmd0aC0xOyBpID49IDAgOyBpLS0pe1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdWJzY3JpYmVyID0gIGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsTmFtZV1baV07XHJcblx0XHRcdFx0XHRcdFx0aWYoc3Vic2NyaWJlci5mb3JEZWxldGUgPT09IHRydWUpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2hhbm5lbFN1YnNjcmliZXJzW2NoYW5uZWxOYW1lXS5zcGxpY2UoaSwxKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZXtcclxuXHRcdFx0XHRcdFx0bWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXgrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vVE9ETzogZm9yIGltbXV0YWJsZSBvYmplY3RzIGl0IHdpbGwgbm90IHdvcmsgYWxzbywgZml4IGZvciBzaGFwZSBtb2RlbHNcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBtZXNzYWdlLl9fdHJhbnNtaXNpb25JbmRleCA9PSAndW5kZWZpbmVkJyl7XHJcblx0XHRcdFx0XHRcdHdwcmludChcIkNhbid0IHVzZSBhcyBtZXNzYWdlIGluIGEgcHViL3N1YiBjaGFubmVsIHRoaXMgb2JqZWN0OiBcIiArIG1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3Vic2NyaWJlciA9IGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsTmFtZV1bbWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXhdO1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIHN1YnNjcmliZXIgPT0gJ3VuZGVmaW5lZCcpe1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgbWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXg7XHJcblx0XHRcdFx0XHRcdGNoYW5uZWxzU3RvcmFnZVtjaGFubmVsTmFtZV0ucG9wKCk7XHJcblx0XHRcdFx0XHR9IGVsc2V7XHJcblx0XHRcdFx0XHRcdGlmKHN1YnNjcmliZXIuZmlsdGVyID09PSBudWxsIHx8IHR5cGVvZiBzdWJzY3JpYmVyLmZpbHRlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCAoIWludmFsaWRGdW5jdGlvbihzdWJzY3JpYmVyLmZpbHRlcikgJiYgc3Vic2NyaWJlci5maWx0ZXIobWVzc2FnZSkpKXtcclxuXHRcdFx0XHRcdFx0XHRpZighc3Vic2NyaWJlci5mb3JEZWxldGUpe1xyXG5cdFx0XHRcdFx0XHRcdFx0c3Vic2NyaWJlci5jYWxsQmFjayhtZXNzYWdlKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHN1YnNjcmliZXIud2FpdEZvck1vcmUgJiYgIWludmFsaWRGdW5jdGlvbihzdWJzY3JpYmVyLndhaXRGb3JNb3JlKSAmJiAhc3Vic2NyaWJlci53YWl0Rm9yTW9yZShtZXNzYWdlKSl7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN1YnNjcmliZXIuZm9yRGVsZXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2goZXJyKXtcclxuXHRcdFx0XHR3cHJpbnQoXCJFdmVudCBjYWxsYmFjayBmYWlsZWQ6IFwiKyBzdWJzY3JpYmVyLmNhbGxCYWNrICtcImVycm9yOiBcIiArIGVyci5zdGFjayk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9cclxuXHRcdFx0aWYoZnJvbVJlbGVhc2VDYWxsQmFja3Mpe1xyXG5cdFx0XHRcdGxldmVsLS07XHJcblx0XHRcdH0gZWxzZXtcclxuXHRcdFx0XHRzZWxmLnJlbGVhc2VDYWxsQmFja3MoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZXtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29tcGFjdEFuZFN0b3JlKHRhcmdldCwgbWVzc2FnZSl7XHJcblx0XHR2YXIgZ290Q29tcGFjdGVkID0gZmFsc2U7XHJcblx0XHR2YXIgYXJyID0gY2hhbm5lbHNTdG9yYWdlW3RhcmdldF07XHJcblx0XHRpZih0eXBlb2YgYXJyID09ICd1bmRlZmluZWQnKXtcclxuXHRcdFx0YXJyID0gbmV3IFF1ZXVlKCk7XHJcblx0XHRcdGNoYW5uZWxzU3RvcmFnZVt0YXJnZXRdID0gYXJyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UudHlwZSAhPSAndW5kZWZpbmVkJyl7XHJcblx0XHRcdHZhciB0eXBlQ29tcGFjdG9yQ2FsbEJhY2sgPSB0eXBlQ29tcGFjdG9yW21lc3NhZ2UudHlwZV07XHJcblxyXG5cdFx0XHRpZih0eXBlb2YgdHlwZUNvbXBhY3RvckNhbGxCYWNrICE9ICd1bmRlZmluZWQnKXtcclxuXHRcdFx0XHRmb3IobGV0IGNoYW5uZWwgb2YgYXJyKSB7XHJcblx0XHRcdFx0XHRpZih0eXBlQ29tcGFjdG9yQ2FsbEJhY2sobWVzc2FnZSwgY2hhbm5lbCkgPT09IGNoYW5uZWwpIHtcclxuXHRcdFx0XHRcdFx0aWYodHlwZW9mIGNoYW5uZWwuX190cmFuc21pc2lvbkluZGV4ID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0Z290Q29tcGFjdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCFnb3RDb21wYWN0ZWQgJiYgbWVzc2FnZSl7XHJcblx0XHRcdGFyci5wdXNoKG1lc3NhZ2UpO1xyXG5cdFx0XHRleGVjdXRpb25RdWV1ZS5wdXNoKHRhcmdldCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgYWZ0ZXJFdmVudHNDYWxscyA9IG5ldyBRdWV1ZSgpO1xyXG5cdGZ1bmN0aW9uIGNhbGxBZnRlckFsbEV2ZW50cyAoKXtcclxuXHRcdGlmKCFhZnRlckV2ZW50c0NhbGxzLmlzRW1wdHkoKSl7XHJcblx0XHRcdHZhciBjYWxsQmFjayA9IGFmdGVyRXZlbnRzQ2FsbHMucG9wKCk7XHJcblx0XHRcdC8vZG8gbm90IGNhdGNoIGV4Y2VwdGlvbnMgaGVyZS4uXHJcblx0XHRcdGNhbGxCYWNrKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gIWFmdGVyRXZlbnRzQ2FsbHMuaXNFbXB0eSgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW52YWxpZENoYW5uZWxOYW1lKG5hbWUpe1xyXG5cdFx0dmFyIHJlc3VsdCA9IGZhbHNlO1xyXG5cdFx0aWYoIW5hbWUgfHwgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIG5hbWUgIT0gXCJudW1iZXJcIikpe1xyXG5cdFx0XHRyZXN1bHQgPSB0cnVlO1xyXG5cdFx0XHR3cHJpbnQoXCJJbnZhbGlkIGNoYW5uZWwgbmFtZTogXCIgKyBuYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW52YWxpZE1lc3NhZ2VUeXBlKG1lc3NhZ2Upe1xyXG5cdFx0dmFyIHJlc3VsdCA9IGZhbHNlO1xyXG5cdFx0aWYoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT0gXCJvYmplY3RcIil7XHJcblx0XHRcdHJlc3VsdCA9IHRydWU7XHJcblx0XHRcdHdwcmludChcIkludmFsaWQgbWVzc2FnZXMgdHlwZXM6IFwiICsgbWVzc2FnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW52YWxpZEZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuXHRcdHZhciByZXN1bHQgPSBmYWxzZTtcclxuXHRcdGlmKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0cmVzdWx0ID0gdHJ1ZTtcclxuXHRcdFx0d3ByaW50KFwiRXhwZWN0ZWQgdG8gYmUgZnVuY3Rpb24gYnV0IGlzOiBcIiArIGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnRzLnNvdW5kUHViU3ViID0gbmV3IFNvdW5kUHViU3ViKCk7IiwiZnVuY3Rpb24gcHJvZHVjdChhcmdzKSB7XHJcbiAgICBpZighYXJncy5sZW5ndGgpe1xyXG4gICAgICAgIHJldHVybiBbIFtdIF07XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvZCA9IHByb2R1Y3QoYXJncy5zbGljZSgxKSksIHIgPSBbXTtcclxuICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgcHJvZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcclxuICAgICAgICAgICAgci5wdXNoKFsgeCBdLmNvbmNhdChwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYmplY3RQcm9kdWN0KG9iaikge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLFxyXG4gICAgICAgIHZhbHVlcyA9IGtleXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIG9ialt4XTsgfSk7XHJcblxyXG4gICAgcmV0dXJuIHByb2R1Y3QodmFsdWVzKS5tYXAoZnVuY3Rpb24ocCkge1xyXG4gICAgICAgIHZhciBlID0ge307XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGssIG4pIHsgZVtrXSA9IHBbbl07IH0pO1xyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0UHJvZHVjdDsiLCJ2YXIgbWV0YSA9IFwibWV0YVwiO1xyXG5cclxuZnVuY3Rpb24gT3dNKHNlcmlhbGl6ZWQpe1xyXG5cclxuICAgIGlmKHNlcmlhbGl6ZWQpe1xyXG4gICAgICAgIHJldHVybiBPd00ucHJvdG90eXBlLmNvbnZlcnQoc2VyaWFsaXplZCk7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1ldGEsIHtcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZToge31cclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldE1ldGFcIiwge1xyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6ZmFsc2UsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIHByb3AgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgPT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHAgaW4gcHJvcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRhXVtwXSA9IHByb3BbcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzW21ldGFdW3Byb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRNZXRhXCIsIHtcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByb3Ape1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1ttZXRhXVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGVzdE93TVNlcmlhbGl6YXRpb24ob2JqKXtcclxuICAgIGxldCByZXMgPSBmYWxzZTtcclxuXHJcbiAgICBpZihvYmope1xyXG4gICAgICAgIHJlcyA9IHR5cGVvZiBvYmpbbWV0YV0gIT0gXCJ1bmRlZmluZWRcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIE93TSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuT3dNLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24oc2VyaWFsaXplZCl7XHJcbiAgICBjb25zdCBvd20gPSBuZXcgT3dNKCk7XHJcblxyXG4gICAgZm9yKHZhciBtZXRhUHJvcCBpbiBzZXJpYWxpemVkLm1ldGEpe1xyXG4gICAgICAgIGlmKCF0ZXN0T3dNU2VyaWFsaXphdGlvbihzZXJpYWxpemVkW21ldGFQcm9wXSkpIHtcclxuICAgICAgICAgICAgb3dtLnNldE1ldGEobWV0YVByb3AsIHNlcmlhbGl6ZWQubWV0YVttZXRhUHJvcF0pO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBvd20uc2V0TWV0YShtZXRhUHJvcCwgT3dNLnByb3RvdHlwZS5jb252ZXJ0KHNlcmlhbGl6ZWQubWV0YVttZXRhUHJvcF0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKHZhciBzaW1wbGVQcm9wIGluIHNlcmlhbGl6ZWQpe1xyXG4gICAgICAgIGlmKHNpbXBsZVByb3AgPT09IG1ldGEpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighdGVzdE93TVNlcmlhbGl6YXRpb24oc2VyaWFsaXplZFtzaW1wbGVQcm9wXSkpe1xyXG4gICAgICAgICAgICBvd21bc2ltcGxlUHJvcF0gPSBzZXJpYWxpemVkW3NpbXBsZVByb3BdO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBvd21bc2ltcGxlUHJvcF0gPSBPd00ucHJvdG90eXBlLmNvbnZlcnQoc2VyaWFsaXplZFtzaW1wbGVQcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvd207XHJcbn07XHJcblxyXG5Pd00ucHJvdG90eXBlLmdldE1ldGFGcm9tID0gZnVuY3Rpb24ob2JqLCBuYW1lKXtcclxuICAgIHZhciByZXM7XHJcbiAgICBpZighbmFtZSl7XHJcbiAgICAgICAgcmVzID0gb2JqW21ldGFdO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgcmVzID0gb2JqW21ldGFdW25hbWVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbk93TS5wcm90b3R5cGUuc2V0TWV0YUZvciA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpe1xyXG4gICAgb2JqW21ldGFdW25hbWVdID0gdmFsdWU7XHJcbiAgICByZXR1cm4gb2JqW21ldGFdW25hbWVdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPd007IiwiZnVuY3Rpb24gUXVldWVFbGVtZW50KGNvbnRlbnQpIHtcclxuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xyXG5cdHRoaXMubmV4dCA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFF1ZXVlKCkge1xyXG5cdHRoaXMuaGVhZCA9IG51bGw7XHJcblx0dGhpcy50YWlsID0gbnVsbDtcclxuXHR0aGlzLmxlbmd0aCA9IDA7XHJcblx0dGhpcy5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHRjb25zdCBuZXdFbGVtZW50ID0gbmV3IFF1ZXVlRWxlbWVudCh2YWx1ZSk7XHJcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xyXG5cdFx0XHR0aGlzLmhlYWQgPSBuZXdFbGVtZW50O1xyXG5cdFx0XHR0aGlzLnRhaWwgPSBuZXdFbGVtZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy50YWlsLm5leHQgPSBuZXdFbGVtZW50O1xyXG5cdFx0XHR0aGlzLnRhaWwgPSBuZXdFbGVtZW50O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZW5ndGgrKztcclxuXHR9O1xyXG5cclxuXHR0aGlzLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5oZWFkKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgaGVhZENvcHkgPSB0aGlzLmhlYWQ7XHJcblx0XHR0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcclxuXHRcdHRoaXMubGVuZ3RoLS07XHJcblxyXG5cdFx0Ly9maXg/Pz8/Pz8/XHJcblx0XHRpZih0aGlzLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhlYWRDb3B5LmNvbnRlbnQ7XHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9udCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmhlYWQgPyB0aGlzLmhlYWQuY29udGVudCA6IHVuZGVmaW5lZDtcclxuXHR9O1xyXG5cclxuXHR0aGlzLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oZWFkID09PSBudWxsO1xyXG5cdH07XHJcblxyXG5cdHRoaXNbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKiAoKSB7XHJcblx0XHRsZXQgaGVhZCA9IHRoaXMuaGVhZDtcclxuXHRcdHdoaWxlKGhlYWQgIT09IG51bGwpIHtcclxuXHRcdFx0eWllbGQgaGVhZC5jb250ZW50O1xyXG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xyXG5cdFx0fVxyXG5cdH0uYmluZCh0aGlzKTtcclxufVxyXG5cclxuUXVldWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdGxldCBzdHJpbmdpZmllZFF1ZXVlID0gJyc7XHJcblx0bGV0IGl0ZXJhdG9yID0gdGhpcy5oZWFkO1xyXG5cdHdoaWxlIChpdGVyYXRvcikge1xyXG5cdFx0c3RyaW5naWZpZWRRdWV1ZSArPSBgJHtKU09OLnN0cmluZ2lmeShpdGVyYXRvci5jb250ZW50KX0gYDtcclxuXHRcdGl0ZXJhdG9yID0gaXRlcmF0b3IubmV4dDtcclxuXHR9XHJcblx0cmV0dXJuIHN0cmluZ2lmaWVkUXVldWU7XHJcbn07XHJcblxyXG5RdWV1ZS5wcm90b3R5cGUuaW5zcGVjdCA9IFF1ZXVlLnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7IiwiY29uc3QgT3dNID0gcmVxdWlyZShcIi4vT3dNXCIpO1xyXG5cclxuLypcclxuICAgIFByZXBhcmUgdGhlIHN0YXRlIG9mIGEgc3dhcm0gdG8gYmUgc2VyaWFsaXNlZFxyXG4qL1xyXG5cclxuZXhwb3J0cy5hc0pTT04gPSBmdW5jdGlvbih2YWx1ZU9iaiwgcGhhc2VOYW1lLCBhcmdzLCBjYWxsYmFjayl7XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZU9iamVjdCA9IHZhbHVlT2JqLnZhbHVlT2YoKTtcclxuICAgICAgICBsZXQgcmVzID0gbmV3IE93TSgpO1xyXG4gICAgICAgIHJlcy5wdWJsaWNWYXJzICAgICAgICAgID0gdmFsdWVPYmplY3QucHVibGljVmFycztcclxuICAgICAgICByZXMucHJpdmF0ZVZhcnMgICAgICAgICA9IHZhbHVlT2JqZWN0LnByaXZhdGVWYXJzO1xyXG5cclxuICAgICAgICByZXMuc2V0TWV0YShcInN3YXJtVHlwZU5hbWVcIiwgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJzd2FybVR5cGVOYW1lXCIpKTtcclxuICAgICAgICByZXMuc2V0TWV0YShcInN3YXJtSWRcIiwgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJzd2FybUlkXCIpKTtcclxuICAgICAgICByZXMuc2V0TWV0YShcInRhcmdldFwiLCAgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJ0YXJnZXRcIikpO1xyXG4gICAgICAgIHJlcy5zZXRNZXRhKFwiaG9tZVNlY3VyaXR5Q29udGV4dFwiLCAgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJob21lU2VjdXJpdHlDb250ZXh0XCIpKTtcclxuICAgICAgICByZXMuc2V0TWV0YShcInJlcXVlc3RJZFwiLCAgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJyZXF1ZXN0SWRcIikpO1xyXG5cclxuICAgICAgICBpZighcGhhc2VOYW1lKXtcclxuICAgICAgICAgICAgcmVzLnNldE1ldGEoXCJjb21tYW5kXCIsIFwic3RvcmVkXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcy5zZXRNZXRhKFwicGhhc2VOYW1lXCIsIHBoYXNlTmFtZSk7XHJcbiAgICAgICAgICAgIHJlcy5zZXRNZXRhKFwicGhhc2VJZFwiLCAkJC51aWRHZW5lcmF0b3Iuc2FmZV91dWlkKCkpO1xyXG4gICAgICAgICAgICByZXMuc2V0TWV0YShcImFyZ3NcIiwgYXJncyk7XHJcbiAgICAgICAgICAgIHJlcy5zZXRNZXRhKFwiY29tbWFuZFwiLCBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHZhbHVlT2JqZWN0LCBcImNvbW1hbmRcIikgfHwgXCJleGVjdXRlU3dhcm1QaGFzZVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcy5zZXRNZXRhKFwid2FpdFN0YWNrXCIsIHZhbHVlT2JqZWN0Lm1ldGEud2FpdFN0YWNrKTsgLy9UT0RPOiB0aGluayBpZiBpcyBub3QgYmV0dGVyIHRvIGJlIGRlZXAgY2xvbmVkIGFuZCBub3QgcmVmZXJlbmNlZCEhIVxyXG5cclxuICAgICAgICBpZihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYXNKU09OOlwiLCByZXMsIHZhbHVlT2JqZWN0KTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuZXhwb3J0cy5qc29uVG9OYXRpdmUgPSBmdW5jdGlvbihzZXJpYWxpc2VkVmFsdWVzLCByZXN1bHQpe1xyXG5cclxuICAgIGZvcihsZXQgdiBpbiBzZXJpYWxpc2VkVmFsdWVzLnB1YmxpY1ZhcnMpe1xyXG4gICAgICAgIHJlc3VsdC5wdWJsaWNWYXJzW3ZdID0gc2VyaWFsaXNlZFZhbHVlcy5wdWJsaWNWYXJzW3ZdO1xyXG5cclxuICAgIH07XHJcbiAgICBmb3IobGV0IGwgaW4gc2VyaWFsaXNlZFZhbHVlcy5wcml2YXRlVmFycyl7XHJcbiAgICAgICAgcmVzdWx0LnByaXZhdGVWYXJzW2xdID0gc2VyaWFsaXNlZFZhbHVlcy5wcml2YXRlVmFyc1tsXTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yKGxldCBpIGluIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc2VyaWFsaXNlZFZhbHVlcykpe1xyXG4gICAgICAgIE93TS5wcm90b3R5cGUuc2V0TWV0YUZvcihyZXN1bHQsIGksIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc2VyaWFsaXNlZFZhbHVlcywgaSkpO1xyXG4gICAgfTtcclxuXHJcbn07IiwidmFyIGNvbW1hbmRzID0ge307XHJcbnZhciBjb21tYW5kc19oZWxwID0ge307XHJcblxyXG4vL2dsb2JhbCBmdW5jdGlvbiBhZGRDb21tYW5kXHJcbmFkZENvbW1hbmQgPSBmdW5jdGlvbiBhZGRDb21tYW5kKHZlcmIsIGFkdmVyYmUsIGZ1bmN0LCBoZWxwTGluZSl7XHJcbiAgICB2YXIgY21kSWQ7XHJcbiAgICBpZighaGVscExpbmUpe1xyXG4gICAgICAgIGhlbHBMaW5lID0gXCIgXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhlbHBMaW5lID0gXCIgXCIgKyBoZWxwTGluZTtcclxuICAgIH1cclxuICAgIGlmKGFkdmVyYmUpe1xyXG4gICAgICAgIGNtZElkID0gdmVyYiArIFwiIFwiICsgIGFkdmVyYmU7XHJcbiAgICAgICAgaGVscExpbmUgPSB2ZXJiICsgXCIgXCIgKyAgYWR2ZXJiZSArIGhlbHBMaW5lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjbWRJZCA9IHZlcmI7XHJcbiAgICAgICAgaGVscExpbmUgPSB2ZXJiICsgaGVscExpbmU7XHJcbiAgICB9XHJcbiAgICBjb21tYW5kc1tjbWRJZF0gPSBmdW5jdDtcclxuICAgICAgICBjb21tYW5kc19oZWxwW2NtZElkXSA9IGhlbHBMaW5lO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZG9IZWxwKCl7XHJcbiAgICBjb25zb2xlLmxvZyhcIkxpc3Qgb2YgY29tbWFuZHM6XCIpO1xyXG4gICAgZm9yKHZhciBsIGluIGNvbW1hbmRzX2hlbHApe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx0XCIsIGNvbW1hbmRzX2hlbHBbbF0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5hZGRDb21tYW5kKFwiLWhcIiwgbnVsbCwgZG9IZWxwLCBcIlxcdFxcdFxcdFxcdFxcdFxcdCB8anVzdCBwcmludCB0aGUgaGVscFwiKTtcclxuYWRkQ29tbWFuZChcIi8/XCIsIG51bGwsIGRvSGVscCwgXCJcXHRcXHRcXHRcXHRcXHRcXHQgfGp1c3QgcHJpbnQgdGhlIGhlbHBcIik7XHJcbmFkZENvbW1hbmQoXCJoZWxwXCIsIG51bGwsIGRvSGVscCwgXCJcXHRcXHRcXHRcXHRcXHRcXHQgfGp1c3QgcHJpbnQgdGhlIGhlbHBcIik7XHJcblxyXG5cclxuZnVuY3Rpb24gcnVuQ29tbWFuZCgpe1xyXG4gIHZhciBhcmd2ID0gT2JqZWN0LmFzc2lnbihbXSwgcHJvY2Vzcy5hcmd2KTtcclxuICB2YXIgY21kSWQgPSBudWxsO1xyXG4gIHZhciBjbWQgPSBudWxsO1xyXG4gIGFyZ3Yuc2hpZnQoKTtcclxuICBhcmd2LnNoaWZ0KCk7XHJcblxyXG4gIGlmKGFyZ3YubGVuZ3RoID49MSl7XHJcbiAgICAgIGNtZElkID0gYXJndlswXTtcclxuICAgICAgY21kID0gY29tbWFuZHNbY21kSWRdO1xyXG4gICAgICBhcmd2LnNoaWZ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgaWYoIWNtZCAmJiBhcmd2Lmxlbmd0aCA+PTEpe1xyXG4gICAgICBjbWRJZCA9IGNtZElkICsgXCIgXCIgKyBhcmd2WzBdO1xyXG4gICAgICBjbWQgPSBjb21tYW5kc1tjbWRJZF07XHJcbiAgICAgIGFyZ3Yuc2hpZnQoKTtcclxuICB9XHJcblxyXG4gIGlmKCFjbWQpe1xyXG4gICAgaWYoY21kSWQpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBjb21tYW5kOiBcIiwgY21kSWQpO1xyXG4gICAgfVxyXG4gICAgY21kID0gZG9IZWxwO1xyXG4gIH1cclxuXHJcbiAgY21kLmFwcGx5KG51bGwsYXJndik7XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHJ1bkNvbW1hbmRcclxufTtcclxuXHJcbiIsIlxyXG5mdW5jdGlvbiBlbmNvZGUoYnVmZmVyKSB7XHJcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvPSskLywgJycpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc3RhbXBXaXRoVGltZShidWYsIHNhbHQsIG1zYWx0KXtcclxuICAgIGlmKCFzYWx0KXtcclxuICAgICAgICBzYWx0ID0gMTtcclxuICAgIH1cclxuICAgIGlmKCFtc2FsdCl7XHJcbiAgICAgICAgbXNhbHQgPSAxO1xyXG4gICAgfVxyXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZTtcclxuICAgIHZhciBjdCA9IE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBzYWx0KTtcclxuICAgIHZhciBjb3VudGVyID0gMDtcclxuICAgIHdoaWxlKGN0ID4gMCApe1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDb3VudGVyXCIsIGNvdW50ZXIsIGN0KTtcclxuICAgICAgICBidWZbY291bnRlciptc2FsdF0gPSBNYXRoLmZsb29yKGN0ICUgMjU2KTtcclxuICAgICAgICBjdCA9IE1hdGguZmxvb3IoY3QgLyAyNTYpO1xyXG4gICAgICAgIGNvdW50ZXIrKztcclxuICAgIH1cclxufVxyXG5cclxuLypcclxuICAgIFRoZSB1aWQgY29udGFpbnMgYXJvdW5kIDI1NiBiaXRzIG9mIHJhbmRvbW5lc3MgYW5kIGFyZSB1bmlxdWUgYXQgdGhlIGxldmVsIG9mIHNlY29uZHMuIFRoaXMgVVVJRCBzaG91bGQgYnkgY3J5cHRvZ3JhcGhpY2FsbHkgc2FmZSAoY2FuIG5vdCBiZSBndWVzc2VkKVxyXG5cclxuICAgIFdlIGdlbmVyYXRlIGEgc2FmZSBVSUQgdGhhdCBpcyBndWFyYW50ZWVkIHVuaXF1ZSAoYnkgdXNhZ2Ugb2YgYSBQUk5HIHRvIGdlbmVhdGUgMjU2IGJpdHMpIGFuZCB0aW1lIHN0YW1waW5nIHdpdGggdGhlIG51bWJlciBvZiBzZWNvbmRzIGF0IHRoZSBtb21lbnQgd2hlbiBpcyBnZW5lcmF0ZWRcclxuICAgIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBzYWZlIHRvIHVzZSBhdCB0aGUgbGV2ZWwgb2YgdmVyeSBsYXJnZSBkaXN0cmlidXRlZCBzeXN0ZW1zLlxyXG4gICAgVGhlIFVVSUQgaXMgc3RhbXBlZCB3aXRoIHRpbWUgKHNlY29uZHMpOiBkb2VzIGl0IG9wZW4gYSB3YXkgdG8gZ3Vlc3MgdGhlIFVVSUQ/IEl0IGRlcGVuZHMgaG93IHNhZmUgaXMgXCJjcnlwdG9cIiBQUk5HLCBidXQgaXQgc2hvdWxkIGJlIG5vIHByb2JsZW0uLi5cclxuXHJcbiAqL1xyXG5cclxudmFyIGdlbmVyYXRlVWlkID0gbnVsbDtcclxuXHJcblxyXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihleHRlcm5hbEdlbmVyYXRvcil7XHJcbiAgICBnZW5lcmF0ZVVpZCA9IGV4dGVybmFsR2VuZXJhdG9yLmdlbmVyYXRlVWlkO1xyXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG59O1xyXG5cclxuZXhwb3J0cy5zYWZlX3V1aWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBidWYgPSBnZW5lcmF0ZVVpZCgzMik7XHJcbiAgICBzdGFtcFdpdGhUaW1lKGJ1ZiwgMTAwMCwgMyk7XHJcbiAgICByZXR1cm4gZW5jb2RlKGJ1Zik7XHJcbn07XHJcblxyXG5cclxuXHJcbi8qXHJcbiAgICBUcnkgdG8gZ2VuZXJhdGUgYSBzbWFsbCBVSUQgdGhhdCBpcyB1bmlxdWUgYWdhaW5zdCBjaGFuY2UgaW4gdGhlIHNhbWUgbWlsbGlzZWNvbmQgc2Vjb25kIGFuZCBpbiBhIHNwZWNpZmljIGNvbnRleHQgKGVnIGluIHRoZSBzYW1lIGNob3Jlb2dyYXBoeSBleGVjdXRpb24pXHJcbiAgICBUaGUgaWQgY29udGFpbnMgYXJvdW5kIDYqOCA9IDQ4ICBiaXRzIG9mIHJhbmRvbW5lc3MgYW5kIGFyZSB1bmlxdWUgYXQgdGhlIGxldmVsIG9mIG1pbGxpc2Vjb25kc1xyXG4gICAgVGhpcyBtZXRob2QgaXMgc2FmZSBvbiBhIHNpbmdsZSBjb21wdXRlciBidXQgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlIG90aGVyd2lzZVxyXG4gICAgVGhpcyBVVUlEIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzYWZlIChjYW4gYmUgZ3Vlc3NlZClcclxuICovXHJcbmV4cG9ydHMuc2hvcnRfdXVpZCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcygxMiwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YW1wV2l0aFRpbWUoYnVmLDEsMik7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZW5jb2RlKGJ1ZikpO1xyXG4gICAgfSk7XHJcbn07IiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbmNvbnN0IFF1ZXVlID0gcmVxdWlyZShcIi4vUXVldWVcIik7XHJcbnZhciBQU0tCdWZmZXIgPSB0eXBlb2YgJCQgIT09IFwidW5kZWZpbmVkXCIgJiYgJCQuUFNLQnVmZmVyID8gJCQuUFNLQnVmZmVyIDogQnVmZmVyO1xyXG5cclxuZnVuY3Rpb24gVWlkR2VuZXJhdG9yKG1pbkJ1ZmZlcnMsIGJ1ZmZlcnNTaXplKSB7XHJcblx0dmFyIGJ1ZmZlcnMgPSBuZXcgUXVldWUoKTtcclxuXHR2YXIgbG93TGltaXQgPSAuMjtcclxuXHJcblx0ZnVuY3Rpb24gZmlsbEJ1ZmZlcnMoc2l6ZSl7XHJcblx0XHQvL25vdGlmeU9ic2VydmVyKCk7XHJcblx0XHRjb25zdCBzeiA9IHNpemUgfHwgbWluQnVmZmVycztcclxuXHRcdGlmKGJ1ZmZlcnMubGVuZ3RoIDwgTWF0aC5mbG9vcihtaW5CdWZmZXJzKmxvd0xpbWl0KSl7XHJcblx0XHRcdGZvcih2YXIgaT0wK2J1ZmZlcnMubGVuZ3RoOyBpIDwgc3o7IGkrKyl7XHJcblx0XHRcdFx0Z2VuZXJhdGVPbmVCdWZmZXIobnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZpbGxCdWZmZXJzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlT25lQnVmZmVyKGIpe1xyXG5cdFx0aWYoIWIpe1xyXG5cdFx0XHRiID0gUFNLQnVmZmVyLmFsbG9jKDApO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3Qgc3ogPSBidWZmZXJzU2l6ZSAtIGIubGVuZ3RoO1xyXG5cdFx0LypjcnlwdG8ucmFuZG9tQnl0ZXMoc3osIGZ1bmN0aW9uIChlcnIsIHJlcykge1xyXG5cdFx0XHRidWZmZXJzLnB1c2goQnVmZmVyLmNvbmNhdChbcmVzLCBiXSkpO1xyXG5cdFx0XHRub3RpZnlPYnNlcnZlcigpO1xyXG5cdFx0fSk7Ki9cclxuXHRcdGJ1ZmZlcnMucHVzaChQU0tCdWZmZXIuY29uY2F0KFsgY3J5cHRvLnJhbmRvbUJ5dGVzKHN6KSwgYiBdKSk7XHJcblx0XHRub3RpZnlPYnNlcnZlcigpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXh0cmFjdE4obil7XHJcblx0XHR2YXIgc3ogPSBNYXRoLmZsb29yKG4gLyBidWZmZXJzU2l6ZSk7XHJcblx0XHR2YXIgcmV0ID0gW107XHJcblxyXG5cdFx0Zm9yKHZhciBpPTA7IGk8c3o7IGkrKyl7XHJcblx0XHRcdHJldC5wdXNoKGJ1ZmZlcnMucG9wKCkpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGdlbmVyYXRlT25lQnVmZmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblxyXG5cclxuXHRcdHZhciByZW1haW5kZXIgPSBuICUgYnVmZmVyc1NpemU7XHJcblx0XHRpZihyZW1haW5kZXIgPiAwKXtcclxuXHRcdFx0dmFyIGZyb250ID0gYnVmZmVycy5wb3AoKTtcclxuXHRcdFx0cmV0LnB1c2goZnJvbnQuc2xpY2UoMCxyZW1haW5kZXIpKTtcclxuXHRcdFx0Ly9nZW5lcmF0ZU9uZUJ1ZmZlcihmcm9udC5zbGljZShyZW1haW5kZXIpKTtcclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdGdlbmVyYXRlT25lQnVmZmVyKGZyb250LnNsaWNlKHJlbWFpbmRlcikpO1xyXG5cdFx0XHR9LDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vc2V0VGltZW91dChmaWxsQnVmZmVycywgMSk7XHJcblxyXG5cdFx0cmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcclxuXHR9XHJcblxyXG5cdHZhciBmaWxsSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlVWlkID0gZnVuY3Rpb24obil7XHJcblx0XHR2YXIgdG90YWxTaXplID0gYnVmZmVycy5sZW5ndGggKiBidWZmZXJzU2l6ZTtcclxuXHRcdGlmKG4gPD0gdG90YWxTaXplKXtcclxuXHRcdFx0cmV0dXJuIGV4dHJhY3ROKG4pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYoIWZpbGxJblByb2dyZXNzKXtcclxuXHRcdFx0XHRmaWxsSW5Qcm9ncmVzcyA9IHRydWU7XHJcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0ZmlsbEJ1ZmZlcnMoTWF0aC5mbG9vcihtaW5CdWZmZXJzKjIuNSkpO1xyXG5cdFx0XHRcdFx0ZmlsbEluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHRcdFx0XHR9LCAxKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHZhciBvYnNlcnZlcjtcclxuXHR0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIgPSBmdW5jdGlvbihvYnMpe1xyXG5cdFx0aWYob2JzZXJ2ZXIpe1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKG5ldyBFcnJvcihcIk9uZSBvYnNlcnZlciBhbGxvd2VkIVwiKSk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0aWYodHlwZW9mIG9icyA9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0XHRcdG9ic2VydmVyID0gb2JzO1xyXG5cdFx0XHRcdC8vbm90aWZ5T2JzZXJ2ZXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG5vdGlmeU9ic2VydmVyKCl7XHJcblx0XHRpZihvYnNlcnZlcil7XHJcblx0XHRcdHZhciB2YWx1ZVRvUmVwb3J0ID0gYnVmZmVycy5sZW5ndGgqYnVmZmVyc1NpemU7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRvYnNlcnZlcihudWxsLCB7XCJzaXplXCI6IHZhbHVlVG9SZXBvcnR9KTtcclxuXHRcdFx0fSwgMTApO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMuY3JlYXRlVWlkR2VuZXJhdG9yID0gZnVuY3Rpb24gKG1pbkJ1ZmZlcnMsIGJ1ZmZlclNpemUpIHtcclxuXHRyZXR1cm4gbmV3IFVpZEdlbmVyYXRvcihtaW5CdWZmZXJzLCBidWZmZXJTaXplKTtcclxufTtcclxuIiwidmFyIG1xID0gJCQucmVxdWlyZShcImZvbGRlcm1xXCIpO1xyXG5cclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcblxyXG5jb25zdCBSRVNUQVJUX1RJTUVPVVQgPSA1MDA7XHJcbmNvbnN0IFJFU1RBUlRfVElNRU9VVF9MSU1JVCA9IDUwMDAwO1xyXG5cclxudmFyIHNhbmRib3hlcyA9IHt9O1xyXG52YXIgZXhpdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZXhpdEhhbmRsZXJcIikoc2FuZGJveGVzKTtcclxuXHJcbnZhciBib290U2FuZEJveCA9ICQkLmZsb3cuZGVzY3JpYmUoXCJQcml2YXRlU2t5LnN3YXJtLmVuZ2luZS5ib290SW5MYXVuY2hlclwiLCB7XHJcbiAgICBib290OmZ1bmN0aW9uKHNhbmRCb3gsIHNwYWNlTmFtZSwgZm9sZGVyLCBjb2RlRm9sZGVyLCBjYWxsYmFjayl7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJCb290aW5nIGluIFwiLCBmb2xkZXIsIFwiIGNvbnRleHQgXCIsIHNwYWNlTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgICA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuZm9sZGVyICAgICA9IGZvbGRlcjtcclxuICAgICAgICB0aGlzLnNwYWNlTmFtZSAgPSBzcGFjZU5hbWU7XHJcbiAgICAgICAgdGhpcy5zYW5kQm94ICAgID0gc2FuZEJveDtcclxuICAgICAgICB0aGlzLmNvZGVGb2xkZXIgICAgPSBjb2RlRm9sZGVyO1xyXG4gICAgICAgIHRoaXMudGltZW91dE11bHRpcGxpZXIgPSAxO1xyXG5cclxuICAgICAgICB2YXIgdGFzayA9IHRoaXMuc2VyaWFsKHRoaXMuZW5zdXJlRm9sZGVyc0V4aXN0cyk7XHJcblxyXG4gICAgICAgIHRhc2suZm9sZGVyU2hvdWxkRXhpc3QocGF0aC5qb2luKHRoaXMuZm9sZGVyLCBcIm1xXCIpLCAgICB0YXNrLnByb2dyZXNzKTtcclxuICAgICAgICB0YXNrLmZvbGRlclNob3VsZEV4aXN0KHBhdGguam9pbih0aGlzLmZvbGRlciwgXCJidW5kbGVzXCIpLCAgdGFzay5wcm9ncmVzcyk7XHJcbiAgICAgICAgdGFzay5mb2xkZXJTaG91bGRFeGlzdChwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwidG1wXCIpLCAgIHRhc2sucHJvZ3Jlc3MpO1xyXG4gICAgfSxcclxuICAgIGZvbGRlclNob3VsZEV4aXN0OiAgZnVuY3Rpb24ocGF0aCwgcHJvZ3Jlc3Mpe1xyXG4gICAgICAgIGZzLm1rZGlyKHBhdGgsIHtyZWN1cnNpdmU6IHRydWV9LCBwcm9ncmVzcyk7XHJcbiAgICB9LFxyXG4gICAgY29weUZvbGRlcjogZnVuY3Rpb24oc291cmNlUGF0aCwgdGFyZ2V0UGF0aCwgY2FsbGJhY2spe1xyXG4gICAgICAgIGxldCBmc0V4dCA9IHJlcXVpcmUoXCJ1dGlsc1wiKS5mc0V4dDtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGZzRXh0LmNvcHkoc291cmNlUGF0aCwgdGFyZ2V0UGF0aCwge292ZXJ3cml0ZTogdHJ1ZX0sIGNhbGxiYWNrKTtcclxuICAgICAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb3Qgc29tZXRoaW5nLi4uXCIsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVuc3VyZUZvbGRlcnNFeGlzdHM6IGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuICAgICAgICBpZihlcnIpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGhpcy5wYXJhbGxlbCh0aGlzLnJ1bkNvZGUpO1xyXG4gICAgICAgICAgICB0aGlzLnNhbmRCb3guaW5ib3VuZCA9IG1xLmNyZWF0ZVF1ZShwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwibXEvaW5ib3VuZFwiKSwgdGhpcy5wcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2FuZEJveC5vdXRib3VuZCA9IG1xLmNyZWF0ZVF1ZShwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwibXEvb3V0Ym91bmRcIiksIHRoaXMucHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcmVwYXJpbmcgdG8gY29weVwiLCBwYXRoLmpvaW4odGhpcy5jb2RlRm9sZGVyLCBcImJ1bmRsZXNcIiksIHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwiYnVuZGxlc1wiKSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvcHlGb2xkZXIocGF0aC5qb2luKHRoaXMuY29kZUZvbGRlciwgXCJidW5kbGVzXCIpLCBwYXRoLnJlc29sdmUocGF0aC5qb2luKHRoaXMuZm9sZGVyLCBcImJ1bmRsZXNcIikpLCB0YXNrLnByb2dyZXNzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIHJ1bkNvZGU6IGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuICAgICAgICBpZighZXJyKXtcclxuICAgICAgICAgICAgdmFyIG1haW5GaWxlID0gcGF0aC5qb2luKHByb2Nlc3MuZW52LlBSSVZBVEVTS1lfUk9PVF9GT0xERVIsIFwiY29yZVwiLCBcInNhbmRib3hlc1wiLCBcImFnZW50U2FuZGJveC5qc1wiKTtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5zcGFjZU5hbWUsIHByb2Nlc3MuZW52LlBSSVZBVEVTS1lfUk9PVF9GT0xERVIsIHBhdGgucmVzb2x2ZShwcm9jZXNzLmVudi5QUklWQVRFU0tZX0RPTUFJTl9CVUlMRCldO1xyXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtzdGRpbzogWzAsIDEsIDIsIFwiaXBjXCJdfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydENoaWxkID0gKG1haW5GaWxlLCBhcmdzLCBvcHRzKSA9PiB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJSdW5uaW5nOiBcIiwgbWFpbkZpbGUsIGFyZ3MsIG9wdHMpO1xyXG5cclxuXHRcdFx0XHQvLyBwYXNzaW5nIG9wdGlvbnMuZW52IG1pZ2h0IGJyZWFrIHRoZSBhZ2VudFNhbmRib3gsIGl0IHJlbGllcyBvbiBzb21lIGluaGVyaXRlZCBlbnYgdmFyaWFibGVzIGZyb20gZG9tYWluXHJcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRfcHJvY2Vzcy5mb3JrKG1haW5GaWxlLCBhcmdzKTtcclxuXHRcdFx0XHRzYW5kYm94ZXNbdGhpcy5zcGFjZU5hbWVdID0gY2hpbGQ7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2FuZEJveC5pbmJvdW5kLnNldElQQ0NoYW5uZWwoY2hpbGQpO1xyXG5cdFx0XHRcdHRoaXMuc2FuZEJveC5vdXRib3VuZC5zZXRJUENDaGFubmVsKGNoaWxkKTtcclxuXHJcblx0XHRcdFx0Y2hpbGQub24oXCJleGl0XCIsIChjb2RlLCBzaWduYWwpPT57XHJcblx0XHRcdFx0ICAgIGlmKGNvZGUgPT09IDApe1xyXG5cdFx0XHRcdCAgICAgICAgY29uc29sZS5sb2coYFNhbmRib3ggPCR7dGhpcy5zcGFjZU5hbWV9PiBzaHV0dGluZyBkb3duLmApO1xyXG5cdFx0XHRcdCAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0XHQgICAgbGV0IHRpbWVvdXQgPSAodGhpcy50aW1lb3V0TXVsdGlwbGllcipSRVNUQVJUX1RJTUVPVVQpICUgUkVTVEFSVF9USU1FT1VUX0xJTUlUO1xyXG5cdFx0XHRcdCAgICBjb25zb2xlLmxvZyhgU2FuZGJveCA8JHt0aGlzLnNwYWNlTmFtZX0+IGV4aXRzIHdpdGggY29kZSAke2NvZGV9LiBSZXN0YXJ0aW5nIGluICR7dGltZW91dH0gbXMuYCk7XHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpPT57XHJcblx0XHRcdFx0XHRcdHN0YXJ0Q2hpbGQobWFpbkZpbGUsIGFyZ3MsIG9wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRNdWx0aXBsaWVyICo9IDEuNTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBzdGFydENoaWxkKG1haW5GaWxlLCBhcmdzLCBvcHRzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBleGVjdXRpbmcgc2FuZGJveCE6XCIsIGVycik7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIFNhbmRCb3hIYW5kbGVyKHNwYWNlTmFtZSwgZm9sZGVyLCBjb2RlRm9sZGVyLCByZXN1bHRDYWxsQmFjayl7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIG1xSGFuZGxlcjtcclxuXHJcblxyXG4gICAgYm9vdFNhbmRCb3goKS5ib290KHRoaXMsIHNwYWNlTmFtZSxmb2xkZXIsIGNvZGVGb2xkZXIsIGZ1bmN0aW9uKGVyciwgY2hpbGRQcm9jZXNzKXtcclxuICAgICAgICBpZighZXJyKXtcclxuICAgICAgICAgICAgc2VsZi5jaGlsZFByb2Nlc3MgPSBjaGlsZFByb2Nlc3M7XHJcblxyXG5cclxuICAgICAgICAgICAgLypzZWxmLm91dGJvdW5kLnJlZ2lzdGVyQ29uc3VtZXIoZnVuY3Rpb24oZXJyLCBzd2FybSl7XHJcbiAgICAgICAgICAgICAgICAkJC5QU0tfUHViU3ViLnB1Ymxpc2goJCQuQ09OU1RBTlRTLlNXQVJNX0ZPUl9FWEVDVVRJT04sIHN3YXJtKTtcclxuICAgICAgICAgICAgfSk7Ki9cclxuXHJcbiAgICAgICAgICAgIHNlbGYub3V0Ym91bmQucmVnaXN0ZXJBc0lQQ0NvbnN1bWVyKGZ1bmN0aW9uKGVyciwgc3dhcm0pe1xyXG4gICAgICAgICAgICAgICAgJCQuUFNLX1B1YlN1Yi5wdWJsaXNoKCQkLkNPTlNUQU5UUy5TV0FSTV9GT1JfRVhFQ1VUSU9OLCBzd2FybSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbXFIYW5kbGVyID0gc2VsZi5pbmJvdW5kLmdldEhhbmRsZXIoKTtcclxuICAgICAgICAgICAgaWYocGVuZGluZ01lc3NhZ2VzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTWVzc2FnZXMubWFwKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ01lc3NhZ2VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBwZW5kaW5nTWVzc2FnZXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoc3dhcm0sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYobXFIYW5kbGVyKXtcclxuICAgICAgICAgICAgbXFIYW5kbGVyLnNlbmRTd2FybUZvckV4ZWN1dGlvbihzd2FybSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlcy5wdXNoKHN3YXJtKTsgLy9UT0RPOiB3ZWxsLCBhIGRlZXAgY2xvbmUgd2lsbCBub3QgYmUgYSBiZXR0ZXIgaWRlYT9cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gU2FuZEJveE1hbmFnZXIoc2FuZGJveGVzRm9sZGVyLCBjb2RlRm9sZGVyLCBjYWxsYmFjayl7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHNhbmRCb3hlcyA9IHtcclxuXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gYmVsb25nc1RvUmVwbGljYXRlZFNwYWNlKCl7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIlN1YnNjcmliaW5nIHRvOlwiLCAkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTik7XHJcbiAgICAkJC5QU0tfUHViU3ViLnN1YnNjcmliZSgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTiwgZnVuY3Rpb24oc3dhcm0pe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXhlY3V0aW5nIGluIHNhbmRib3ggdG93YXJkczogXCIsIHN3YXJtLm1ldGEudGFyZ2V0KTtcclxuXHJcbiAgICAgICAgaWYoc3dhcm0ubWV0YS50YXJnZXQgPT0gXCJzeXN0ZW1cIiB8fCBzd2FybS5tZXRhLmNvbW1hbmQgPT0gXCJhc3luY1JldHVyblwiKXtcclxuICAgICAgICAgICAgJCQuc3dhcm1zSW5zdGFuY2VzTWFuYWdlci5yZXZpdmVfc3dhcm0oc3dhcm0pO1xyXG4gICAgICAgICAgICAvLyQkLnN3YXJtcy5yZXN0YXJ0KHN3YXJtLm1ldGEuc3dhcm1UeXBlTmFtZSwgc3dhcm0pO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgIGlmKHN3YXJtLm1ldGEudGFyZ2V0ID09IFwicGRzXCIpe1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgIGlmKGJlbG9uZ3NUb1JlcGxpY2F0ZWRTcGFjZShzd2FybS5tZXRhLnRhcmdldCkpe1xyXG4gICAgICAgICAgICBzZWxmLnB1c2hUb1NwYWNlQVN3YXJtKHN3YXJtLm1ldGEudGFyZ2V0LCBzd2FybSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9UT0RPOiBzZW5kIHRvd2FyZHMgbmV0d29ya1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRTYW5kQm94KHNwYWNlTmFtZSl7XHJcbiAgICAgICAgdmFyIHNhbmRCb3ggPSBuZXcgU2FuZEJveEhhbmRsZXIoc3BhY2VOYW1lLCBwYXRoLmpvaW4oc2FuZGJveGVzRm9sZGVyLCBzcGFjZU5hbWUpLCBjb2RlRm9sZGVyKTtcclxuICAgICAgICBzYW5kQm94ZXNbc3BhY2VOYW1lXSA9IHNhbmRCb3g7XHJcbiAgICAgICAgcmV0dXJuIHNhbmRCb3g7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHRoaXMucHVzaFRvU3BhY2VBU3dhcm0gPSBmdW5jdGlvbihzcGFjZU5hbWUsIHN3YXJtLCBjYWxsYmFjayl7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwicHVzaFRvU3BhY2VBU3dhcm0gXCIgLCBzcGFjZU5hbWUpO1xyXG4gICAgICAgIHZhciBzYW5kYm94ID0gc2FuZEJveGVzW3NwYWNlTmFtZV07XHJcbiAgICAgICAgaWYoIXNhbmRib3gpe1xyXG4gICAgICAgICAgICBzYW5kYm94ID0gc2FuZEJveGVzW3NwYWNlTmFtZV0gPSBzdGFydFNhbmRCb3goc3BhY2VOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2FuZGJveC5zZW5kKHN3YXJtLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XHJcbn1cclxuXHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKGZvbGRlciwgY29kZUZvbGRlciwgY2FsbGJhY2spe1xyXG4gICAgbmV3IFNhbmRCb3hNYW5hZ2VyKGZvbGRlciwgY29kZUZvbGRlciwgY2FsbGJhY2spO1xyXG59O1xyXG5cclxuXHJcbiIsImNvbnN0IGV2ZW50cyA9IFtcImV4aXRcIiwgXCJTSUdJTlRcIiwgXCJTSUdVU1IxXCIsIFwiU0lHVVNSMlwiLCBcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIFwiU0lHVEVSTVwiLCBcIlNJR0hVUFwiXTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hbmFnZVNodXRkb3duUHJvY2VzcyhjaGlsZHJlbkxpc3Qpe1xyXG5cclxuICAgIGxldCBzaHV0dGluZyA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlcigpe1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJIYW5kbGluZyBleGl0IGV2ZW50IG9uXCIsIHByb2Nlc3MucGlkLCBcImFyZ3VtZW50czpcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgY2hpbGRyZW5OYW1lcyA9IE9iamVjdC5rZXlzKGNoaWxkcmVuTGlzdCk7XHJcbiAgICAgICAgZm9yKGxldCBqPTA7IGo8Y2hpbGRyZW5OYW1lcy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuTGlzdFtjaGlsZHJlbk5hbWVzW2pdXTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhgWyR7cHJvY2Vzcy5waWR9XWAsIFwiU2VuZGluZyBraWxsIHNpZ25hbCB0byBQSUQ6XCIsIGNoaWxkLnBpZCk7XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3Mua2lsbChjaGlsZC5waWQpO1xyXG4gICAgICAgICAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgICAgIC8vLi4uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFzaHV0dGluZyl7XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LmN1cnNvclRvKDApO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFtQSUQ6ICR7cHJvY2Vzcy5waWR9XSBbVGltZXN0YW1wOiAke25ldyBEYXRlKCkuZ2V0VGltZSgpfV0gW1Byb2Nlc3MgYXJndjogJHtwcm9jZXNzLmFyZ3Z9XS0gU2h1dHRpbmcgZG93bi4uLlxcbmApO1xyXG4gICAgICAgICAgICB9Y2F0Y2goZXJyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLy4uLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNodXR0aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byByZXBsYWNlIHByb2Nlc3Muc3RkaW4ucmVzdW1lKClcclxuICAgIGlmKG9zLnBhdGZvcm0gPT09IFwid2luMzJcIiAmJiBwcm9jZXNzLmVudi5TSEVMTCA9PT0gXCIvYmluL2Jhc2hcIil7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgZXhlY3V0ZSByZXN1bWUoKSBvbiBzdGRpbi4gUGxlYXNlIHVzZSBjb21tYW5kIHByb21wdCBvbiB3aW5kb3dzIHRvIHJ1biBQU0shISFcXG5cXG5cXG5cIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBwcm9jZXNzLnN0ZGluLnJlc3VtZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcihsZXQgaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2ZW50c1tpXTtcclxuICAgICAgICBwcm9jZXNzLm9uKGV2ZW50VHlwZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiRXhpdCBoYW5kbGVyIHNldHVwIVwiLCBgWyR7cHJvY2Vzcy5waWR9XWApO1xyXG59OyIsIlxyXG4vL3ZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb24oZXJyLCByZXMpe1xyXG5cdC8vY29uc29sZS5sb2coZXJyLnN0YWNrKTtcclxuXHRpZihlcnIpIHRocm93IGVycjtcclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG5yZXF1aXJlKFwiLi9saWIvb3ZlcndyaXRlUmVxdWlyZVwiKTtcclxuLypcclxuY29uc3QgUFNLQnVmZmVyID0gcmVxdWlyZSgncHNrYnVmZmVyJyk7XHJcbiQkLlBTS0J1ZmZlciA9IFBTS0J1ZmZlcjsgKi9cclxuXHJcblxyXG4kJC5fX2ludGVybiA9IHtcclxuICAgICAgICBta0FyZ3M6ZnVuY3Rpb24oYXJncyxwb3Mpe1xyXG4gICAgICAgICAgICB2YXIgYXJnc0FycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IHBvczsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgYXJnc0FycmF5LnB1c2goYXJnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NBcnJheTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG52YXIgc3dhcm1VdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9jaG9yZW9ncmFwaGllcy9zd2FybVwiKTtcclxudmFyIGFzc2V0VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvdXRpbGl0eUZ1bmN0aW9ucy9hc3NldFwiKTtcclxuXHJcbnZhciB0cmFuc2FjdGlvblV0aWxzID0gcmVxdWlyZShcIi4vbGliL3V0aWxpdHlGdW5jdGlvbnMvdHJhbnNhY3Rpb25cIik7XHJcbiQkLmRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb24gPSBkZWZhdWx0RXJyb3JIYW5kbGluZ0ltcGxlbWVudGF0aW9uO1xyXG5cclxudmFyIGNhbGxmbG93TW9kdWxlID0gcmVxdWlyZShcIi4vbGliL3N3YXJtRGVzY3JpcHRpb25cIik7XHJcbiQkLmNhbGxmbG93cyAgICAgICAgPSBjYWxsZmxvd01vZHVsZS5jcmVhdGVTd2FybUVuZ2luZShcImNhbGxmbG93XCIpO1xyXG4kJC5jYWxsZmxvdyAgICAgICAgID0gJCQuY2FsbGZsb3dzO1xyXG4kJC5mbG93ICAgICAgICAgICAgID0gJCQuY2FsbGZsb3dzO1xyXG4kJC5mbG93cyAgICAgICAgICAgID0gJCQuY2FsbGZsb3dzO1xyXG5cclxuJCQuc3dhcm1zICAgICAgICAgICA9IGNhbGxmbG93TW9kdWxlLmNyZWF0ZVN3YXJtRW5naW5lKFwic3dhcm1cIiwgc3dhcm1VdGlscyk7XHJcbiQkLnN3YXJtICAgICAgICAgICAgPSAkJC5zd2FybXM7XHJcbiQkLmNvbnRyYWN0cyAgICAgICAgPSBjYWxsZmxvd01vZHVsZS5jcmVhdGVTd2FybUVuZ2luZShcImNvbnRyYWN0XCIsIHN3YXJtVXRpbHMpO1xyXG4kJC5jb250cmFjdCAgICAgICAgID0gJCQuY29udHJhY3RzO1xyXG4kJC5hc3NldHMgICAgICAgICAgID0gY2FsbGZsb3dNb2R1bGUuY3JlYXRlU3dhcm1FbmdpbmUoXCJhc3NldFwiLCBhc3NldFV0aWxzKTtcclxuJCQuYXNzZXQgICAgICAgICAgICA9ICQkLmFzc2V0cztcclxuJCQudHJhbnNhY3Rpb25zICAgICA9IGNhbGxmbG93TW9kdWxlLmNyZWF0ZVN3YXJtRW5naW5lKFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb25VdGlscyk7XHJcbiQkLnRyYW5zYWN0aW9uICAgICAgPSAkJC50cmFuc2FjdGlvbnM7XHJcblxyXG5cclxuJCQuUFNLX1B1YlN1YiA9IHJlcXVpcmUoXCJzb3VuZHB1YnN1YlwiKS5zb3VuZFB1YlN1YjtcclxuXHJcbiQkLnNlY3VyaXR5Q29udGV4dCA9IFwic3lzdGVtXCI7XHJcbiQkLmxpYnJhcnlQcmVmaXggPSBcImdsb2JhbFwiO1xyXG4kJC5saWJyYXJpZXMgPSB7XHJcbiAgICBnbG9iYWw6e1xyXG5cclxuICAgIH1cclxufTtcclxuXHJcbiQkLmludGVyY2VwdG9yID0gcmVxdWlyZShcIi4vbGliL0ludGVyY2VwdG9yUmVnaXN0cnlcIikuY3JlYXRlSW50ZXJjZXB0b3JSZWdpc3RyeSgpO1xyXG5cclxuJCQubG9hZExpYnJhcnkgPSByZXF1aXJlKFwiLi9saWIvbG9hZExpYnJhcnlcIikubG9hZExpYnJhcnk7XHJcblxyXG5yZXF1aXJlTGlicmFyeSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgLy92YXIgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKCAgJCQuX19nbG9iYWwuX19sb2FkTGlicmFyeVJvb3QgKyBuYW1lKTtcclxuICAgIHJldHVybiAkJC5sb2FkTGlicmFyeShuYW1lLG5hbWUpO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5cclxuLyovL1RPRE86IFNIT1VMRCBiZSBtb3ZlZCBpbiAkJC5fX2dsb2JhbHNcclxuJCQuZW5zdXJlRm9sZGVyRXhpc3RzID0gZnVuY3Rpb24gKGZvbGRlciwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGZsb3cgPSAkJC5mbG93LnN0YXJ0KFwidXRpbHMubWtEaXJSZWNcIik7XHJcbiAgICBmbG93Lm1ha2UoZm9sZGVyLCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG4kJC5lbnN1cmVMaW5rRXhpc3RzID0gZnVuY3Rpb24gKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGZsb3cgPSAkJC5mbG93LnN0YXJ0KFwidXRpbHMubWtEaXJSZWNcIik7XHJcbiAgICBmbG93Lm1ha2VMaW5rKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spO1xyXG59OyovXHJcblxyXG4kJC5wYXRoTm9ybWFsaXplID0gZnVuY3Rpb24gKHBhdGhUb05vcm1hbGl6ZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG4gICAgcGF0aFRvTm9ybWFsaXplID0gcGF0aC5ub3JtYWxpemUocGF0aFRvTm9ybWFsaXplKTtcclxuXHJcbiAgICByZXR1cm4gcGF0aFRvTm9ybWFsaXplLnJlcGxhY2UoL1tcXC9cXFxcXS9nLCBwYXRoLnNlcCk7XHJcbn07XHJcblxyXG4vLyBhZGQgaW50ZXJjZXB0b3JzXHJcblxyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbiQkLmludGVyY2VwdG9yLnJlZ2lzdGVyKCcqJywgJyonLCAnYmVmb3JlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3Qgc3dhcm1UeXBlTmFtZSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3N3YXJtVHlwZU5hbWUnKTtcclxuICAgIGNvbnN0IHBoYXNlTmFtZSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3BoYXNlTmFtZScpO1xyXG4gICAgY29uc3Qgc3dhcm1JZCA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3N3YXJtSWQnKTtcclxuICAgIGNvbnN0IGV4ZWN1dGlvbklkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgdGhpcy5zZXRNZXRhZGF0YSgnZXhlY3V0aW9uSWQnLCBleGVjdXRpb25JZCk7XHJcblxyXG4gICAgJCQuZXZlbnQoJ3N3YXJtLmNhbGwuYmVmb3JlJywge3N3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgZXhlY3V0aW9uSWR9KTtcclxufSk7XHJcblxyXG4kJC5pbnRlcmNlcHRvci5yZWdpc3RlcignKicsICcqJywgJ2FmdGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3Qgc3dhcm1UeXBlTmFtZSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3N3YXJtVHlwZU5hbWUnKTtcclxuICAgIGNvbnN0IHBoYXNlTmFtZSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3BoYXNlTmFtZScpO1xyXG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSB0aGlzLmdldE1ldGFkYXRhKCdleGVjdXRpb25JZCcpO1xyXG5cclxuICAgIHRoaXMuc2V0TWV0YWRhdGEoJ2V4ZWN1dGlvbklkJywgdW5kZWZpbmVkKTtcclxuXHJcbiAgICAkJC5ldmVudCgnc3dhcm0uY2FsbC50aW1lJywge3N3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgZXhlY3V0aW9uSWR9KTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFx0XHRcdFx0Y3JlYXRlU3dhcm1FbmdpbmU6IHJlcXVpcmUoXCIuL2xpYi9zd2FybURlc2NyaXB0aW9uXCIpLmNyZWF0ZVN3YXJtRW5naW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUpvaW5Qb2ludDogcmVxdWlyZShcIi4vbGliL3BhcmFsbGVsSm9pblBvaW50XCIpLmNyZWF0ZUpvaW5Qb2ludCxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTZXJpYWxKb2luUG9pbnQ6IHJlcXVpcmUoXCIuL2xpYi9zZXJpYWxKb2luUG9pbnRcIikuY3JlYXRlU2VyaWFsSm9pblBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHN3YXJtSW5zdGFuY2VNYW5hZ2VyOiByZXF1aXJlKFwiLi9saWIvY2hvcmVvZ3JhcGhpZXMvc3dhcm1JbnN0YW5jZXNNYW5hZ2VyXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUludGVybmFsU3dhcm1Sb3V0aW5nOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkdW1teVZNKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc29sdmVTd2FybShzd2FybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCQuc3dhcm1zSW5zdGFuY2VzTWFuYWdlci5yZXZpdmVfc3dhcm0oc3dhcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIuc3Vic2NyaWJlKG5hbWUsIHNvbHZlU3dhcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBhIGZha2UgZXhlY3V0aW9uIGNvbnRleHQuLi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbXlWTSgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cdFx0XHRcdH07XHJcbiIsImlmKHR5cGVvZiBzaW5nbGV0b25fY29udGFpbmVyX21vZHVsZV93b3JrYXJvdW5kX2Zvcl93aXJlZF9ub2RlX2pzX2NhY2hpbmcgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHNpbmdsZXRvbl9jb250YWluZXJfbW9kdWxlX3dvcmthcm91bmRfZm9yX3dpcmVkX25vZGVfanNfY2FjaGluZyAgID0gbW9kdWxlO1xyXG59IGVsc2Uge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaW5nbGV0b25fY29udGFpbmVyX21vZHVsZV93b3JrYXJvdW5kX2Zvcl93aXJlZF9ub2RlX2pzX2NhY2hpbmcgLmV4cG9ydHM7XHJcbiAgICByZXR1cm4gbW9kdWxlO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBzYWxib2FpZSBvbiA0LzI3LzE1LlxyXG4gKi9cclxuZnVuY3Rpb24gQ29udGFpbmVyKGVycm9ySGFuZGxlcil7XHJcbiAgICB2YXIgdGhpbmdzID0ge307ICAgICAgICAvL3RoZSBhY3R1YWwgdmFsdWVzIGZvciBvdXIgc2VydmljZXMsIHRoaW5nc1xyXG4gICAgdmFyIGltbWVkaWF0ZSA9IHt9OyAgICAgLy9ob3cgZGVwZW5kZW5jaWVzIHdlcmUgZGVjbGFyZWRcclxuICAgIHZhciBjYWxsYmFja3MgPSB7fTsgICAgIC8vY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIGZvciBlYWNoIGRlcGVuZGVuY3kgZGVjbGFyYXRpb25cclxuICAgIHZhciBkZXBzQ291bnRlciA9IHt9OyAgIC8vY291bnQgZGVwZW5kZW5jaWVzXHJcbiAgICB2YXIgcmV2ZXJzZWRUcmVlID0ge307ICAvL3JldmVyc2VkIGRlcGVuZGVuY2llcywgb3Bwb3NpdGUgb2YgaW1tZWRpYXRlIG9iamVjdFxyXG5cclxuICAgICB0aGlzLmR1bXAgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkNvbmF0aW5lciBkdW1wXFxuIFRoaW5nczpcIiwgdGhpbmdzLCBcIlxcbkRlcHMgY291bnRlcjogXCIsIGRlcHNDb3VudGVyLCBcIlxcblN0cmlnaHQ6XCIsIGltbWVkaWF0ZSwgXCJcXG5SZXZlcnNlZDpcIiwgcmV2ZXJzZWRUcmVlKTtcclxuICAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGluY0NvdW50ZXIobmFtZSl7XHJcbiAgICAgICAgaWYoIWRlcHNDb3VudGVyW25hbWVdKXtcclxuICAgICAgICAgICAgZGVwc0NvdW50ZXJbbmFtZV0gPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRlcHNDb3VudGVyW25hbWVdKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc2VydERlcGVuZGVuY3lpblJUKG5vZGVOYW1lLCBkZXBlbmRlbmNpZXMpe1xyXG4gICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW1OYW1lKXtcclxuICAgICAgICAgICAgdmFyIGwgPSByZXZlcnNlZFRyZWVbaXRlbU5hbWVdO1xyXG4gICAgICAgICAgICBpZighbCl7XHJcbiAgICAgICAgICAgICAgICBsID0gcmV2ZXJzZWRUcmVlW2l0ZW1OYW1lXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxbbm9kZU5hbWVdID0gbm9kZU5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGRpc2NvdmVyVXBOb2Rlcyhub2RlTmFtZSl7XHJcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBERlMobm4pe1xyXG4gICAgICAgICAgICB2YXIgbCA9IHJldmVyc2VkVHJlZVtubl07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBsKXtcclxuICAgICAgICAgICAgICAgIGlmKCFyZXNbaV0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgREZTKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBERlMobm9kZU5hbWUpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2V0Q291bnRlcihuYW1lKXtcclxuICAgICAgICB2YXIgZGVwZW5kZW5jeUFycmF5ID0gaW1tZWRpYXRlW25hbWVdO1xyXG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcclxuICAgICAgICBpZihkZXBlbmRlbmN5QXJyYXkpe1xyXG4gICAgICAgICAgICBkZXBlbmRlbmN5QXJyYXkuZm9yRWFjaChmdW5jdGlvbihkZXApe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpbmdzW2RlcF0gPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jQ291bnRlcihuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXBzQ291bnRlcltuYW1lXSA9IGNvdW50ZXI7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNvdW50ZXIgZm9yIFwiLCBuYW1lLCAnIGlzICcsIGNvdW50ZXIpO1xyXG4gICAgICAgIHJldHVybiBjb3VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIHJldHVybnMgdGhvc2UgdGhhdCBhcmUgcmVhZHkgdG8gYmUgcmVzb2x2ZWQqL1xyXG4gICAgZnVuY3Rpb24gcmVzZXRVcENvdW50ZXJzKG5hbWUpe1xyXG4gICAgICAgIHZhciByZXQgPSBbXTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdSZXNldGluZyB1cCBjb3VudGVycyBmb3IgJywgbmFtZSwgXCJSZXZlcnNlOlwiLCByZXZlcnNlZFRyZWVbbmFtZV0pO1xyXG4gICAgICAgIHZhciB1cHMgPSByZXZlcnNlZFRyZWVbbmFtZV07XHJcbiAgICAgICAgZm9yKHZhciB2IGluIHVwcyl7XHJcbiAgICAgICAgICAgIGlmKHJlc2V0Q291bnRlcih2KSA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXQucHVzaCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgICAgIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG5hbWUgZm9yIGEgc2VydmljZSwgdmFyaWFibGUsYSAgdGhpbmcgdGhhdCBzaG91bGQgYmUgaW5pdGlhbGlzZWQsIHJlY3JlYXRlZCwgZXRjXHJcbiAgICAgICAgIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW4gYXJyYXkgd2l0aCBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbihlcnIsLi4uKSB0aGF0IGlzIGNhbGxlZCB3aGVuIGRlcGVuZGVuY2llcyBhcmUgcmVhZHkgb3IgcmVjYWxsZWQgd2hlbiBhcmUgbm90IHJlYWR5IChzdG9wIHdhcyBjYWxsZWQpXHJcbiAgICAgICAgIElmIGVyciBpcyBub3QgdW5kZWZpbmVkIGl0IG1lYW5zIHRoYXQgb25lIG9yIGFueSB1bmRlZmluZWQgdmFyaWFibGVzIGFyZSBub3QgcmVhZHkgYW5kIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBsYXRlclxyXG4gICAgICAgICBBbGwgdGhlIG90aGVyIGFyZ3VtZW50cyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRzIG9mIHRoZSBjYWxsYmFjayB3aWxsIGJlIHRoZSBhY3R1YWwgdmFsdWVzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGRlcGVuZGVuY3lcclxuICAgICAgICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIChvciBudWxsKVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlY2xhcmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24obmFtZSwgZGVwZW5kZW5jeUFycmF5LCBjYWxsYmFjayl7XHJcbiAgICAgICAgaWYoY2FsbGJhY2tzW25hbWVdKXtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmlnbm9yZVBvc3NpYmxlRXJyb3IoXCJEdXBsaWNhdGUgZGVwZW5kZW5jeTpcIiArIG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrc1tuYW1lXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICBpbW1lZGlhdGVbbmFtZV0gICA9IGRlcGVuZGVuY3lBcnJheTtcclxuICAgICAgICAgICAgaW5zZXJ0RGVwZW5kZW5jeWluUlQobmFtZSwgZGVwZW5kZW5jeUFycmF5KTtcclxuICAgICAgICAgICAgdGhpbmdzW25hbWVdID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB1bnNhdGlzZmllZENvdW50ZXIgPSByZXNldENvdW50ZXIobmFtZSk7XHJcbiAgICAgICAgaWYodW5zYXRpc2ZpZWRDb3VudGVyID09PSAwICl7XHJcbiAgICAgICAgICAgIGNhbGxGb3JUaGluZyhuYW1lLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbEZvclRoaW5nKG5hbWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgICAgY3JlYXRlIGEgc2VydmljZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlcnZpY2UgPSBmdW5jdGlvbihuYW1lLCBkZXBlbmRlbmN5QXJyYXksIGNvbnN0cnVjdG9yKXtcclxuICAgICAgICB0aGlzLmRlY2xhcmVEZXBlbmRlbmN5KG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3IpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIHN1YnN5c3RlbUNvdW50ZXIgPSAwO1xyXG4gICAgLypcclxuICAgICBjcmVhdGUgYSBhbm9ueW1vdXMgc3Vic3lzdGVtXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3Vic3lzdGVtID0gZnVuY3Rpb24oZGVwZW5kZW5jeUFycmF5LCBjb25zdHJ1Y3Rvcil7XHJcbiAgICAgICAgc3Vic3lzdGVtQ291bnRlcisrO1xyXG4gICAgICAgIHRoaXMuZGVjbGFyZURlcGVuZGVuY3koXCJkaWNvbnRhaW5lcl9zdWJzeXN0ZW1fcGxhY2Vob2xkZXJcIiArIHN1YnN5c3RlbUNvdW50ZXIsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiBub3QgZG9jdW1lbnRlZC4uIGxpbWJvIHN0YXRlKi9cclxuICAgIHRoaXMuZmFjdG9yeSA9IGZ1bmN0aW9uKG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3Ipe1xyXG4gICAgICAgIHRoaXMuZGVjbGFyZURlcGVuZGVuY3kobmFtZSwgZGVwZW5kZW5jeUFycmF5LCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGxGb3JUaGluZyhuYW1lLCBvdXRPZlNlcnZpY2Upe1xyXG4gICAgICAgIHZhciBhcmdzID0gaW1tZWRpYXRlW25hbWVdLm1hcChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaW5nc1tpdGVtXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhcmdzLnVuc2hpZnQob3V0T2ZTZXJ2aWNlKTtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhbGxiYWNrc1tuYW1lXS5hcHBseSh7fSxhcmdzKTtcclxuICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlci50aHJvd0Vycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYob3V0T2ZTZXJ2aWNlIHx8IHZhbHVlPT09bnVsbCl7ICAgLy9lbmFibGUgcmV0dXJuaW5nIGEgdGVtcG9yYXJ5IGRlcGVuZGVuY3kgcmVzb2x1dGlvbiFcclxuICAgICAgICAgICAgaWYodGhpbmdzW25hbWVdKXtcclxuICAgICAgICAgICAgICAgIHRoaW5nc1tuYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXNldFVwQ291bnRlcnMobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3VjY2VzcyByZXNvbHZpbmcgXCIsIG5hbWUsIFwiOlwiLCB2YWx1ZSwgXCJPdGhlciByZWFkeTpcIiwgb3RoZXJSZWFkeSk7XHJcbiAgICAgICAgICAgIGlmKCF2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICB7XCJwbGFjZWhvbGRlclwiOiBuYW1lfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFyIG90aGVyUmVhZHkgPSByZXNldFVwQ291bnRlcnMobmFtZSk7XHJcbiAgICAgICAgICAgIG90aGVyUmVhZHkuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgICAgIGNhbGxGb3JUaGluZyhpdGVtLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICAgIERlY2xhcmUgdGhhdCBhIG5hbWUgaXMgcmVhZHksIHJlc29sdmVkIGFuZCBzaG91bGQgdHJ5IHRvIHJlc29sdmUgYWxsIG90aGVyIHdhaXRpbmcgZm9yIGl0XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzb2x2ZSAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcclxuICAgICAgICB0aGluZ3NbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB2YXIgb3RoZXJSZWFkeSA9IHJlc2V0VXBDb3VudGVycyhuYW1lKTtcclxuXHJcbiAgICAgICAgb3RoZXJSZWFkeS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBjYWxsRm9yVGhpbmcoaXRlbSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gZnVuY3Rpb24obmFtZSwgZGVwZW5kZW5jeUFycmF5LCBjb25zdHJ1Y3Rvcil7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyLm5vdEltcGxlbWVudGVkKFwiaW5zdGFuY2VGYWN0b3J5IGlzIHBsYW5uZWQgYnV0IG5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICAgICBEZWNsYXJlIHRoYXQgYSBzZXJ2aWNlIG9yIGZlYXR1cmUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuIEFsbCBzZXJ2aWNlcyBkZXBlbmRpbmcgb24gdGhpcyB3aWxsIGdldCBub3RpZmllZFxyXG4gICAgICovXHJcbiAgICB0aGlzLm91dE9mU2VydmljZSAgICA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgICAgIHRoaW5nc1tuYW1lXSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHVwTm9kZXMgPSBkaXNjb3ZlclVwTm9kZXMobmFtZSk7XHJcbiAgICAgICAgdXBOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICBjYWxsRm9yVGhpbmcobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuZXhwb3J0cy5uZXdDb250YWluZXIgICAgPSBmdW5jdGlvbihjaGVja3NMaWJyYXJ5KXtcclxuICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoZWNrc0xpYnJhcnkpO1xyXG59O1xyXG5cclxuLy9leHBvcnRzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoJCQuZXJyb3JIYW5kbGVyKTsiLCJleHBvcnRzLmRvbWFpblB1YlN1YiA9IHJlcXVpcmUoXCIuL2RvbWFpblB1YlN1YlwiKTsiLCJcclxuLyoqXHJcbiAqIEdlbmVyaWMgZnVuY3Rpb24gdXNlZCB0byByZWdpc3RlcnMgbWV0aG9kcyBzdWNoIGFzIGFzc2VydHMsIGxvZ2dpbmcsIGV0Yy4gb24gdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICogQHBhcmFtIG5hbWUge1N0cmluZyl9IC0gbmFtZSBvZiB0aGUgbWV0aG9kICh1c2UgY2FzZSkgdG8gYmUgcmVnaXN0ZXJlZC5cclxuICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGhhbmRsZXIgdG8gYmUgaW52b2tlZC5cclxuICogQHBhcmFtIHBhcmFtc0Rlc2NyaXB0aW9uIHtPYmplY3R9IC0gcGFyYW1ldGVycyBkZXNjcmlwdGlvbnNcclxuICogQHBhcmFtIGFmdGVyIHtGdW5jdGlvbn0gLSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIGV4ZWN1dGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkVXNlQ2FzZShuYW1lLCBmdW5jLCBwYXJhbXNEZXNjcmlwdGlvbiwgYWZ0ZXIpe1xyXG4gICAgdmFyIG5ld0Z1bmMgPSBmdW5jO1xyXG4gICAgaWYodHlwZW9mIGFmdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBuZXdGdW5jID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgYWZ0ZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIG92ZXJyaWRkZW5cclxuICAgIGNvbnN0IHByb3RlY3RlZFByb3BlcnRpZXMgPSBbICdhZGRDaGVjaycsICdhZGRDYXNlJywgJ3JlZ2lzdGVyJyBdO1xyXG4gICAgaWYocHJvdGVjdGVkUHJvcGVydGllcy5pbmRleE9mKG5hbWUpID09PSAtMSl7XHJcbiAgICAgICAgdGhpc1tuYW1lXSA9IG5ld0Z1bmM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudCBvdmVyd3JpdGUgJyArIG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHBhcmFtc0Rlc2NyaXB0aW9uKXtcclxuICAgICAgICB0aGlzLnBhcmFtc1tuYW1lXSA9IHBhcmFtc0Rlc2NyaXB0aW9uO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhbGlhcyB0byBhbiBleGlzdGluZyBmdW5jdGlvbi5cclxuICogQHBhcmFtIG5hbWUxIHtTdHJpbmd9IC0gTmV3IGZ1bmN0aW9uIG5hbWUuXHJcbiAqIEBwYXJhbSBuYW1lMiB7U3RyaW5nfSAtIEV4aXN0aW5nIGZ1bmN0aW9uIG5hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbGlhcyhuYW1lMSwgbmFtZTIpe1xyXG4gICAgdGhpc1tuYW1lMV0gPSB0aGlzW25hbWUyXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBmb3IgYWRkaW5nIHZhcmlvdXMgZnVuY3Rpb25zIGZvciB1c2UgY2FzZXMgcmVnYXJkaW5nIGxvZ2dpbmcuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTG9nc0NvcmUoKXtcclxuICAgIHRoaXMucGFyYW1zID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gZm9yIGFkZGluZyB5b3VyIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBhc3NlcnRzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEFzc2VydENvcmUoKXtcclxuICAgIHRoaXMucGFyYW1zID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gZm9yIGFkZGluZyB5b3VyIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBjaGVja3MuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQ2hlY2tDb3JlKCl7XHJcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogU2luZ2xldG9uIGZvciBhZGRpbmcgeW91ciB2YXJpb3VzIGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyBleGNlcHRpb25zLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV4Y2VwdGlvbnNDb3JlKCl7XHJcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogU2luZ2xldG9uIGZvciBhZGRpbmcgeW91ciB2YXJpb3VzIGZ1bmN0aW9ucyBmb3IgcnVubmluZyB0ZXN0cy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUZXN0UnVubmVyQ29yZSgpe1xyXG59XHJcblxyXG5Mb2dzQ29yZS5wcm90b3R5cGUuYWRkQ2FzZSAgICAgICAgICAgPSBhZGRVc2VDYXNlO1xyXG5Bc3NlcnRDb3JlLnByb3RvdHlwZS5hZGRDaGVjayAgICAgICAgPSBhZGRVc2VDYXNlO1xyXG5DaGVja0NvcmUucHJvdG90eXBlLmFkZENoZWNrICAgICAgICAgPSBhZGRVc2VDYXNlO1xyXG5FeGNlcHRpb25zQ29yZS5wcm90b3R5cGUucmVnaXN0ZXIgICAgPSBhZGRVc2VDYXNlO1xyXG5cclxuTG9nc0NvcmUucHJvdG90eXBlLmFsaWFzICAgICAgICAgICAgID0gYWxpYXM7XHJcbkFzc2VydENvcmUucHJvdG90eXBlLmFsaWFzICAgICAgICAgICA9IGFsaWFzO1xyXG5DaGVja0NvcmUucHJvdG90eXBlLmFsaWFzICAgICAgICAgICAgPSBhbGlhcztcclxuRXhjZXB0aW9uc0NvcmUucHJvdG90eXBlLmFsaWFzICAgICAgID0gYWxpYXM7XHJcblxyXG4vLyBDcmVhdGUgbW9kdWxlc1xyXG52YXIgYXNzZXJ0T2JqICAgICAgID0gbmV3IEFzc2VydENvcmUoKTtcclxudmFyIGNoZWNrT2JqICAgICAgICA9IG5ldyBDaGVja0NvcmUoKTtcclxudmFyIGV4Y2VwdGlvbnNPYmogICA9IG5ldyBFeGNlcHRpb25zQ29yZSgpO1xyXG52YXIgbG9nZ2VyT2JqICAgICAgID0gbmV3IExvZ3NDb3JlKCk7XHJcbnZhciB0ZXN0UnVubmVyT2JqICAgPSBuZXcgVGVzdFJ1bm5lckNvcmUoKTtcclxuXHJcbi8vIEV4cG9ydCBtb2R1bGVzXHJcbmV4cG9ydHMuYXNzZXJ0ICAgICAgPSBhc3NlcnRPYmo7XHJcbmV4cG9ydHMuY2hlY2sgICAgICAgPSBjaGVja09iajtcclxuZXhwb3J0cy5leGNlcHRpb25zICA9IGV4Y2VwdGlvbnNPYmo7XHJcbmV4cG9ydHMubG9nZ2VyICAgICAgPSBsb2dnZXJPYmo7XHJcbmV4cG9ydHMudGVzdFJ1bm5lciAgPSB0ZXN0UnVubmVyT2JqO1xyXG5cclxuLy8gSW5pdGlhbGlzZSBtb2R1bGVzXHJcbnJlcXVpcmUoXCIuL3N0YW5kYXJkQXNzZXJ0cy5qc1wiKS5pbml0KGV4cG9ydHMsIGxvZ2dlck9iaik7XHJcbnJlcXVpcmUoXCIuL3N0YW5kYXJkTG9ncy5qc1wiKS5pbml0KGV4cG9ydHMpO1xyXG5yZXF1aXJlKFwiLi9zdGFuZGFyZEV4Y2VwdGlvbnMuanNcIikuaW5pdChleHBvcnRzKTtcclxucmVxdWlyZShcIi4vc3RhbmRhcmRDaGVja3MuanNcIikuaW5pdChleHBvcnRzKTtcclxucmVxdWlyZShcIi4vdGVzdFJ1bm5lci5qc1wiKS5pbml0KGV4cG9ydHMpO1xyXG5cclxuLy8gR2xvYmFsIFVuY2F1Z2h0IEV4Y2VwdGlvbiBoYW5kbGVyLlxyXG5pZihwcm9jZXNzLm9uKVxyXG57XHJcbiAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChlcnIpIHtcclxuXHRcdGNvbnN0IHRhZyA9IFwidW5jYXVnaHRFeGNlcHRpb25cIjtcclxuXHRcdGNvbnNvbGUubG9nKHRhZywgZXJyKTtcclxuXHRcdGNvbnNvbGUubG9nKHRhZywgZXJyLnN0YWNrKTtcclxuXHR9KTtcclxufVxyXG5cclxuXHJcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbmZ1bmN0aW9uIGRlbGV0ZUZvbGRlclJlY3Vyc2l2ZShwYXRoKSB7XHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSkge1xyXG4gICAgICAgIGZzLnJlYWRkaXJTeW5jKHBhdGgpLmZvckVhY2goZnVuY3Rpb24oZmlsZSwgaW5kZXgpe1xyXG4gICAgICAgICAgICB2YXIgY3VyUGF0aCA9IHBhdGggKyBcIi9cIiArIGZpbGU7XHJcbiAgICAgICAgICAgIGlmIChmcy5sc3RhdFN5bmMoY3VyUGF0aCkuaXNEaXJlY3RvcnkoKSkgeyAvLyByZWN1cnNlXHJcbiAgICAgICAgICAgICAgICBkZWxldGVGb2xkZXJSZWN1cnNpdmUoY3VyUGF0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRlbGV0ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGN1clBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnMucm1kaXJTeW5jKHBhdGgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5kZWxldGVGb2xkZXJSZWN1cnNpdmUgPSBkZWxldGVGb2xkZXJSZWN1cnNpdmU7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlVGVzdEZvbGRlciA9IGZ1bmN0aW9uKHByZWZpeCwgY2xsYmFjayl7XHJcbiAgICBmcy5ta2R0ZW1wKHByZWZpeCwgZnVuY3Rpb24oZXJyLCByZXMpe1xyXG4gICAgICAgIGxldCBjbGVhbkZvbGRlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGRlbGV0ZUZvbGRlclJlY3Vyc2l2ZShyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRzLmFzc2VydC5hZGRDbGVhbmluZ0Z1bmN0aW9uKGNsZWFuRm9sZGVyKTtcclxuICAgICAgICBjbGxiYWNrKGVycixyZXMpO1xyXG4gICAgfSk7XHJcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRcdFx0XHRcdGNyZWF0ZVF1ZTogcmVxdWlyZShcIi4vbGliL2ZvbGRlck1RXCIpLmdldEZvbGRlclF1ZXVlXHJcblx0XHRcdFx0XHQvL2ZvbGRlck1ROiByZXF1aXJlKFwiLi9saWIvZm9sZGVyTVFcIilcclxufTsiLCIvL2NvbnNvbGUubG9nKHJlcXVpcmUucmVzb2x2ZShcIi4vY29tcG9uZW50cy5qc1wiKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gJCQubGlicmFyeShmdW5jdGlvbigpe1xyXG5cdHJlcXVpcmUoXCIuL2NvbXBvbmVudHMuanNcIik7XHJcblx0LypyZXF1aXJlKFwiLi9ta0RpclJlYy5qc1wiKTsqL1xyXG59KSIsImNvbnN0IFBTS0J1ZmZlciA9IHJlcXVpcmUoJy4vbGliL1BTS0J1ZmZlcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQU0tCdWZmZXI7XHJcbiIsImNvbnN0IFBza0NyeXB0byA9IHJlcXVpcmUoXCIuL2xpYi9Qc2tDcnlwdG9cIik7XHJcbmNvbnN0IHNzdXRpbCA9IHJlcXVpcmUoXCIuL3NpZ25zZW5zdXNEUy9zc3V0aWxcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBza0NyeXB0bztcclxuXHJcbm1vZHVsZS5leHBvcnRzLmhhc2hWYWx1ZXMgPSBzc3V0aWwuaGFzaFZhbHVlcztcclxuXHJcbmlmKHR5cGVvZihfX19ESVNBQkxFX09CU09MRVRFX1pJUF9BUkNISVZFUl9XQUlUX0ZPUl9CQVJTKSA9PT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgbW9kdWxlLmV4cG9ydHMuUHNrQXJjaGl2ZXIgPSByZXF1aXJlKFwiLi9saWIvcHNrLWFyY2hpdmVyXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5EdXBsZXhTdHJlYW0gPSByZXF1aXJlKFwiLi9saWIvdXRpbHMvRHVwbGV4U3RyZWFtXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuaXNTdHJlYW0gPSByZXF1aXJlKFwiLi9saWIvdXRpbHMvaXNTdHJlYW1cIik7IiwiY29uc3QgUFNLTG9nZ2VyID0gcmVxdWlyZSgnLi9zcmMvUFNLTG9nZ2VyQ2xpZW50L2luZGV4Jyk7XHJcbmNvbnN0IEVudmlyb25tZW50RGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMnKS5FbnZpcm9ubWVudERhdGFQcm92aWRlcjtcclxuXHJcblxyXG5pZighZ2xvYmFsLmhhc093blByb3BlcnR5KCckJCcpKSB7XHJcbiAgICBnbG9iYWwuJCQgPSB7fTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBQU0tMb2dnZXIgc2hvdWxkIGJlIHVzZWQgYXMgaXMgd2l0aG91dCBvdmVyd3JpdGluZyBjb25zb2xlLlxyXG4gKiBUaGUgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgYWRkZWQgdG8gUFNLTG9nZ2VyIHRvIGxvZyB0byBjb25zb2xlIHRoZSBtZXNzYWdlIGFuZCB1c2VmdWwgbWV0YWRhdGFcclxuICovXHJcbmZ1bmN0aW9uIG92ZXJ3cml0ZUNvbnNvbGUoKSB7XHJcbiAgICBpZihwcm9jZXNzLmVudi5jb250ZXh0ID09PSAnc2FuZGJveCcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkV4ZWN1dGlvbiBkZXRlY3RlZCBpbiBzYW5kYm94LCBjb25zb2xlIHdvbid0IGJlIG92ZXJ3cml0dGVuXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsb2dnZXIgPSBQU0tMb2dnZXIuZ2V0TG9nZ2VyKCk7XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlID0ge307XHJcbiAgICBPYmplY3Qua2V5cyhjb25zb2xlKS5mb3JFYWNoKGtleSA9PiBvcmlnaW5hbENvbnNvbGVba2V5XSA9IGNvbnNvbGVba2V5XSk7XHJcblxyXG4gICAgT2JqZWN0LmtleXMobG9nZ2VyKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYoa2V5ICE9IFwibG9nXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZVtrZXldID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGxvZ2dlcltrZXldLmFwcGx5KGxvZ2dlciwgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0Q29udGV4dEZvck1ldGEobG9nLm1ldGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENvbnNvbGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZVtrZXldLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgW2BbJHtjb250ZXh0fV1gLCAuLi5sb2cubWVzc2FnZXNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nID0gZnVuY3Rpb24oLi4uYXJncyl7XHJcbiAgICAgICAgICAgICAgICBpZihhcmdzWzBdID09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiUHJpbnRpbmcgYW4gdW5kZWZpbmVkIHRocm93cyB0aGlzIGVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKC4uLmFyZ3MpOyBpZ25vcmUgY29uc29sZSBsb2dzLi4uIDspXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2cgPSBsb2dnZXJba2V5XS5hcHBseShsb2dnZXIsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKmNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yTWV0YShsb2cubWV0YSkgKyBcIiBsb2c6XFxuXFxyXCI7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoY29udGV4dCkgKi9cclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZS5sb2coLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dEZvck1ldGEobWV0YSkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHRzID0ge1xyXG4gICAgICAgICAgICBub2RlOiAobWV0YSkgPT4gYG5vZGU6JHttZXRhLmNvbnRleHR9YCxcclxuICAgICAgICAgICAgZG9tYWluOiAobWV0YSkgPT5gZG9tYWluOiR7bWV0YS5kb21haW59YCxcclxuICAgICAgICAgICAgYWdlbnQ6IChtZXRhKSA9PiBgZG9tYWluOiR7bWV0YS5kb21haW59OmFnZW50OiR7bWV0YS5hZ2VudH1gLFxyXG4gICAgICAgICAgICBzYW5kYm94OiAoKSA9PiBgc2FuZGJveGBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoY29udGV4dHMuaGFzT3duUHJvcGVydHkobWV0YS5vcmlnaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0c1ttZXRhLm9yaWdpbl0obWV0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuaWYgKHByb2Nlc3MuZW52LmNvbnRleHQgIT09ICdzYW5kYm94Jykge1xyXG5cclxuICAgIGNvbnN0IE1lc3NhZ2VQdWJsaXNoZXIgPSByZXF1aXJlKCcuL3NyYy9NZXNzYWdlUHVibGlzaGVyJyk7XHJcbiAgICBjb25zdCBNZXNzYWdlU3Vic2NyaWJlciA9IHJlcXVpcmUoJy4vc3JjL01lc3NhZ2VTdWJzY3JpYmVyJyk7XHJcbiAgICBjb25zdCBQdWJTdWJQcm94eSA9IHJlcXVpcmUoJy4vc3JjL1B1YlN1YlByb3h5Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5hYmxlRW52aXJvbm1lbnREYXRhRGVmYXVsdCgpIHtcclxuICAgICAgICBnbG9iYWwuJCQuZ2V0RW52aXJvbm1lbnREYXRhID0gRW52aXJvbm1lbnREYXRhUHJvdmlkZXIuZ2V0RW52aXJvbm1lbnREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuYWJsZUVudmlyb25tZW50RGF0YUZvckFnZW50KCkge1xyXG4gICAgICAgIGdsb2JhbC4kJC5nZXRFbnZpcm9ubWVudERhdGEgPSBFbnZpcm9ubWVudERhdGFQcm92aWRlci5nZXRFbnZpcm9ubWVudERhdGFGb3JBZ2VudDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmFibGVFbnZpcm9ubWVudERhdGFGb3JEb21haW4oKSB7XHJcbiAgICAgICAgZ2xvYmFsLiQkLmdldEVudmlyb25tZW50RGF0YSA9IEVudmlyb25tZW50RGF0YVByb3ZpZGVyLmdldEVudmlyb25tZW50RGF0YUZvckRvbWFpbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVyd3JpdGUgdGhpcyB0byBwcm92aWRlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvciBvdGhlciBlbnZpcm9ubWVudHMgKGV4OiBmb3IgZG9tYWlucywgYnJvd3NlciBldGMuKVxyXG4gICAgICovXHJcbiAgICBpZihwcm9jZXNzLmVudi5oYXNPd25Qcm9wZXJ0eSgnUFJJVkFURVNLWV9BR0VOVF9OQU1FJykpIHtcclxuICAgICAgICBlbmFibGVFbnZpcm9ubWVudERhdGFGb3JBZ2VudCgpO1xyXG4gICAgfSBlbHNlIGlmKHByb2Nlc3MuZW52Lmhhc093blByb3BlcnR5KCdQUklWQVRFU0tZX0RPTUFJTl9OQU1FJykpIHtcclxuICAgICAgICBlbmFibGVFbnZpcm9ubWVudERhdGFGb3JEb21haW4oKVxyXG4gICAgfSBlbHNlIGlmKCFnbG9iYWwuJCQuaGFzT3duUHJvcGVydHkoJ2dldEVudmlyb25tZW50RGF0YScpKSB7XHJcbiAgICAgICAgZW5hYmxlRW52aXJvbm1lbnREYXRhRGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzLk1lc3NhZ2VQdWJsaXNoZXJNb2R1bGUgID0gTWVzc2FnZVB1Ymxpc2hlcjtcclxuICAgIG1vZHVsZS5leHBvcnRzLk1lc3NhZ2VTdWJzY3JpYmVyTW9kdWxlID0gTWVzc2FnZVN1YnNjcmliZXI7XHJcbiAgICBtb2R1bGUuZXhwb3J0cy5QdWJTdWJQcm94eU1vZHVsZSAgICAgICA9IFB1YlN1YlByb3h5O1xyXG59IGVsc2Uge1xyXG4gICAgZ2xvYmFsLiQkLmdldEVudmlyb25tZW50RGF0YSA9IEVudmlyb25tZW50RGF0YVByb3ZpZGVyLmdldEVudmlyb25tZW50RGF0YUZvclNhbmRib3g7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVDb25zb2xlID0gb3ZlcndyaXRlQ29uc29sZTtcclxubW9kdWxlLmV4cG9ydHMuUFNLTG9nZ2VyID0gUFNLTG9nZ2VyO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRcdFx0XHRcdHNvdW5kUHViU3ViOiByZXF1aXJlKFwiLi9saWIvc291bmRQdWJTdWJcIikuc291bmRQdWJTdWJcclxufTsiLCJtb2R1bGUuZXhwb3J0cy5Pd00gPSByZXF1aXJlKFwiLi9saWIvT3dNXCIpO1xyXG5tb2R1bGUuZXhwb3J0cy5iZWVzSGVhbGVyID0gcmVxdWlyZShcIi4vbGliL2JlZXNIZWFsZXJcIik7XHJcblxyXG5jb25zdCB1aWRHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9saWIvdWlkR2VuZXJhdG9yXCIpLmNyZWF0ZVVpZEdlbmVyYXRvcigyMDAsIDMyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNhZmVfdXVpZCA9IHJlcXVpcmUoXCIuL2xpYi9zYWZlLXV1aWRcIikuaW5pdCh1aWRHZW5lcmF0b3IpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuUXVldWUgPSByZXF1aXJlKFwiLi9saWIvUXVldWVcIik7XHJcbm1vZHVsZS5leHBvcnRzLmNvbWJvcyA9IHJlcXVpcmUoXCIuL2xpYi9Db21ib3NcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy51aWRHZW5lcmF0b3IgPSB1aWRHZW5lcmF0b3I7XHJcbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRlVWlkID0gdWlkR2VuZXJhdG9yLmdlbmVyYXRlVWlkO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuY3JlYXRlUHNrQ29uc29sZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gcmVxdWlyZSgnLi9saWIvcHNrY29uc29sZScpO1xyXG59O1xyXG5cclxuXHJcbmlmKHR5cGVvZiBnbG9iYWwuJCQgPT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgZ2xvYmFsLiQkID0ge307XHJcbn1cclxuXHJcbmlmKHR5cGVvZiBnbG9iYWwuJCQudWlkR2VuZXJhdG9yID09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgJCQudWlkR2VuZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMuc2FmZV91dWlkO1xyXG59XHJcbiIsImV4cG9ydHMuZnNFeHQgPSByZXF1aXJlKFwiLi9GU0V4dGVuc2lvblwiKS5mc0V4dDsiXX0=
